<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="utf-8">
<link rel="icon" href="/logo.svg" type="image/svg+xml" />
<title>Linux Dersleri | Kabuk Nasıl Çalışır ? &#8211; Linux Eğitimi</title>
<meta name="description" content="Bash kabuğunun komutları nasıl anlamlandırabildiğinden bahsediyoruz.">
<meta name="keywords" content="bash, kabuk, argüman, seçenek, parametre, PATH, değişken, export, source, konfigürasyon dosyaları">








<link rel="canonical" href="https://superua1.github.io//egitim/kabuk-nasil-calisir/">
<link href="https://superua1.github.io//feed.xml" type="application/atom+xml" rel="alternate" title="Linux Eğitimi Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="https://superua1.github.io//assets/css/font-awesome.min.css">
<link rel="stylesheet" href="https://superua1.github.io//assets/css/bootstrap.min.css">
<link rel="stylesheet" href="https://superua1.github.io//assets/css/style.css">


<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="https://superua1.github.io//favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="https://superua1.github.io//favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="https://superua1.github.io//images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="https://superua1.github.io//images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="https://superua1.github.io//images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://superua1.github.io//images/apple-touch-icon-144x144-precomposed.png">

<link rel="stylesheet" href="https://superua1.github.io//assets/css/read.css">
<style>
 .grid {
        column-count: 2;
        column-gap: 1rem;
      }

  </style>
</head>
<body>

<div class="bs-canvas-overlay bs-canvas-anim bg-dark position-fixed w-100 h-100"></div>
<nav class="navbar x-navbar sticky-top navbar-expand-lg navbar-light bg-light border-bottom">
	
  <div class="collapse navbar-collapse">
    <a class="navbar-brand active" href="https://superua1.github.io//">
      <img src="https://superua1.github.io//logo.svg" width="30" height="30" class="align-top" alt="">
      Linux Dersleri
    </a>
    <ul class="navbar-nav">
      <li class="nav-item active">
        <a class="nav-link" href="https://superua1.github.io//egitim.html">Eğitimler</a>
      </li>
      <li class="nav-item active">
        <a class="nav-link" href="https://superua1.github.io//blog/">Blog</a>
      </li>
	  <li class="nav-item active">
        <a class="nav-link" href="https://superua1.github.io//komutlar">Komut Listesi</a>
      </li>
	  <li class="nav-item active">
        <a class="nav-link" href="https://superua1.github.io//test">Test</a>
      </li>
      <li class="nav-item active">
        <a class="nav-link" href="https://superua1.github.io//etiketler">Etiketler</a>
      </li>
	 <li class="nav-item active">
        <a class="nav-link" href="https://superua1.github.io//hakkında.html">Hakkında</a>
      </li>
    </ul>
	
  </div>
 
<a class="btn" data-toggle="modal" data-target="#searchModal"><i class="fa fa-search" style="width:16px;height:16px"></i></a>
	<a onclick="tema()" class="btn" ><i class="fa fa-adjust fa-lg"></i></a> 
	<a href="https://superua1.github.io//bildirim.html" class="btn" ><i class="fa fa-paper-plane"></i></a> 
</nav>	
<nav class="navbar y-navbar sticky-top navbar-expand-lg navbar-light bg-light border-bottom">
<button class="btn"  data-toggle="canvas" data-target="#bs-canvas-left" aria-expanded="false" aria-controls="bs-canvas-left"><i class="fa fa-align-justify fa-lg"></i></button>
		<a href="https://superua1.github.io//" class="btn"  ><i class="fa fa-home fa-lg"></i></a>     
	<a class="btn" data-toggle="modal" data-target="#searchModal"><i class="fa fa-search" style="width:16px;height:16px"></i></a>
		
		<a onclick="tema()" class="btn" ><i class="fa fa-adjust fa-lg"></i></a> 
		<a href="https://superua1.github.io//bildirim.html" class="btn" ><i class="fa fa-paper-plane"></i></a> 
		
</nav>

<div style="background-color: var(--background);" id="bs-canvas-left" class="bs-canvas bs-canvas-anim bs-canvas-left position-fixed h-100" >
   <div class="container">
    
      <a class="btn bs-canvas-close close" aria-label="Close">
        <span aria-hidden="true">&times;</span>
      </a>
      <a class="navbar-brand" href="https://superua1.github.io//">
        <img src="https://superua1.github.io//logo.svg" width="30" height="30" class="align-top" alt="">
        Linux Dersleri
      </a>
  
    
    
   <hr>
 <a data-toggle="modal" data-target="#searchModal" class="btn">🕵️ Arama</a>
  <a href="https://superua1.github.io//egitim" class="btn">🎓 Eğitimler</a>
  <a href="https://superua1.github.io//blog" class="btn">🗃️ Blog</a>
  <a href="https://superua1.github.io//komutlar" class="btn">📜 Komut Listesi</a>
  <a href="https://superua1.github.io//test" class="btn">🎯 Test</a>
  <a href="https://superua1.github.io//etiketler" class="btn">🏷️ Etiketler</a>
  <a href="https://superua1.github.io//hakkında.html" class="btn">🐧 Hakkında</a>
 
  <a href="https://superua1.github.io//bildirim.html" class="btn">📮 Geri Bildirim</a>
  <hr>
  
  <div align="center">
  <h5>Android Uygulaması</h5>
      <ul class="list-unstyled text-small">
        <a href="https://play.google.com/store/apps/details?id=com.bildik.linuxdersleri&amp;pcampaignid=pcampaignidMKT-Other-global-all-co-prtnr-py-PartBadge-Mar2515-1"><img style="width: 75%;" alt="Google Play" den="" alın'="" src="https://play.google.com/intl/en_us/badges/static/images/badges/tr_badge_web_generic.png"></a>
	  </ul>
	  <hr>
 <h5><a href="/">Linux Dersleri</a> | <a target="_blank" href="https://github.com/Linux-Dersleri/linux-dersleri.github.io"><i class="fa fa-github fa-lg"></i></a></h5>
 <p class="small">GNU/Linux için Türkçe içerik sağlamak üzere kurulmuş bir platformdur.</p>

	  </div>
    
</div>

</div>



<!-- Modal -->
<div class="modal fade" id="searchModal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
  <div class="modal-dialog" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="searchModalLabel">🕵️ Site Geneli Arama:</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <link href="https://superua1.github.io//pagefind/pagefind-ui.css" rel="stylesheet">
<script src="https://superua1.github.io//pagefind/pagefind-ui.js" type="text/javascript"></script>

<div id="search"></div>
<script>

    window.addEventListener('DOMContentLoaded', (event) => {
        new PagefindUI({ element: "#search", showImages: false });
		
    });
	
</script>
      </div>

    </div>
  </div>
</div>

<script src="https://superua1.github.io//assets/js/jquery-3.3.1.slim.min.js" type="text/javascript"></script>
<div id="progress-bar-container">
  <div id="progress-bar"></div>
</div>
      <div class="container-fluid">
  <div class="row mb-2">
      <div style="font-size: 18px;" class="col-md-9" data-pagefind-filter="Bölüm:Eğitim Serisi:">
        	<h1 align="center">4. Ders: Kabuk Nasıl Çalışır ?</h1> 
<div align="center"><i class="fa fa-tags" aria-hidden="true"></i>
          <a href="https://superua1.github.io//etiketler.html#bash" class="btn btn-outline-primary btn-sm" title="Pages tagged bash">bash</a> <a href="https://superua1.github.io//etiketler.html#kabuk" class="btn btn-outline-primary btn-sm" title="Pages tagged kabuk">kabuk</a> <a href="https://superua1.github.io//etiketler.html#argüman" class="btn btn-outline-primary btn-sm" title="Pages tagged argüman">argüman</a> <a href="https://superua1.github.io//etiketler.html#seçenek" class="btn btn-outline-primary btn-sm" title="Pages tagged seçenek">seçenek</a> <a href="https://superua1.github.io//etiketler.html#parametre" class="btn btn-outline-primary btn-sm" title="Pages tagged parametre">parametre</a> <a href="https://superua1.github.io//etiketler.html#PATH" class="btn btn-outline-primary btn-sm" title="Pages tagged PATH">PATH</a> <a href="https://superua1.github.io//etiketler.html#değişken" class="btn btn-outline-primary btn-sm" title="Pages tagged değişken">değişken</a> <a href="https://superua1.github.io//etiketler.html#export" class="btn btn-outline-primary btn-sm" title="Pages tagged export">export</a> <a href="https://superua1.github.io//etiketler.html#source" class="btn btn-outline-primary btn-sm" title="Pages tagged source">source</a> <a href="https://superua1.github.io//etiketler.html#konfigürasyon dosyaları" class="btn btn-outline-primary btn-sm" title="Pages tagged konfigürasyon dosyaları">konfigürasyon dosyaları</a>   
		 <p></p> 
		  <div align="center" class="col-sm-3">
		<img class="responsive" src="https://superua1.github.io//egitim/kabukcover.png" alt="">
		  </div>	</div>	  

		  <hr>	
		  <h6 align="right" id="meta-da">
			<i class="fa fa-clock-o" aria-hidden="true"></i>

37 dk.


		   

  <i class="fa fa-user" aria-hidden="true"></i><a href="https://superua1.github.io//hakkında.html"> Taylan Özgür Bildik</a>


		  
		  </h6>  
		  
		  
        <p>Bu bölümde kabuğun nasıl çalıştığından bahsediyor olacağız. Lütfen bu bölümü dikkatinizi vererek tamamlayın. Eğer dikkatlice okuyup uygulamazsanız pek çok hatayla karşılaşmanın yanı sıra eğitimin devamından alacağınız verimi de düşürmüş olursunuz.</p>

<p>Ben bu eğitimde kabuğun çalışma yapısının bazı detaylarını atlıyor olacağım çünkü bazı konulardan bu eğitimde bahsetsek bile henüz Linux sistemini yani tanımaya başladığımız için yani gereken altyapıya henüz sahip olmadığımız için ek detaylar anlaşılır olmayacak. Bu doğrultuda odak noktamızı yani Linux sistem yönetiminin temellerini öğrenme hedefimizi şaşırmadan devam etmeye çalışalım. Eğitime devam ettikçe zaten kabukla ilgili pek çok yeni bilgiyi parça parça öğreniyor olacağız. Yani öğrenmek için acele edip konuları sıkıştırmanın bir anlamı yok. Gerekli olan temel bilgi altyapısı için biz tüm konuları sindire sindire ilerlemeye çalışalım.</p>

<p>Anlatımlarımıza öncelikle kabuğun bizim girdiğimiz komutları nasıl algıladığından bahsederek başlayabiliriz. Bu konuyla başlıyoruz çünkü kabuğun bizi nasıl anladığını bilmek, kabuğa anlayacağı türden komutlar girebilmemiz için çok önemli.</p>

<p>Örnek olması için sistem üzerinde dosyaları ve klasörleri bulma konusunda bize yardımcı olan <code class="language-plaintext highlighter-rouge">find</code> aracını kullanarak bash kabuğunun bizim girdiğimiz komutları nasıl ele aldığından çok kısaca bahsetmek istiyorum. Biliyorum henüz hiç bir komutu ele almadık ve tabii ki <code class="language-plaintext highlighter-rouge">find</code> komutunu da bilmiyoruz fakat siz benim örnek için kullandığım bu komutun ne olduğuna şimdilik takılmayın. Ben burada bash kabuğuna girdiğimiz komutların nasıl çalıştırıldıklarından bahsetmek istiyorum.</p>

<p>Bulunmasını istediğimiz dosyaları kendimiz oluşturabiliriz. Bunun için grafiksel arayüzü de kullanabiliriz fakat ben komut satırından kolayca oluşturmak için <code class="language-plaintext highlighter-rouge">touch ~/test.txt ~/Desktop/test.txt</code> komutunu giriyorum. Bu komut sayesinde kendi ev dizinimde ve ev dizimin altındaki Desktop klasörü içinde “test.txt” isimli birer dosya oluşturulmuş olacak. Komutu anlamasanız bile şimdilik dosyaları oluşturmak için kopyala yapıştır şekilde kullanabilirsiniz.</p>

<p>Şimdi find aracını kullanarak bu dosyaların nasıl bulunabileceğinde bahsederken, bash kabuğunun çalışma yapısını ele almaya çalışalım.</p>

<p>Örnek senaryomuz için diyelim ki benim ev dizinimde birçok dosya ve klasör bulunuyor ve ben de dosya ismi “test.txt” olan dosyalar burada mevcut mu varsa tam olarak hangi dizinde yer alıyorlar diye öğrenmek istiyorum. İşte bu örnek senaryomuz için find aracını kullanabiliriz. Ben kendi ev dizinimdeki test isimli tüm dosyaların bulunması için <code class="language-plaintext highlighter-rouge">find /home/ -name test</code>.txt komutunu giriyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]                                    
└─<span class="nv">$ </span>find /home/ <span class="nt">-name</span> test.txt                        
/home/taylan/test.txt                                   
/home/taylan/Desktop/test.txt
</code></pre></div></div>

<p>Bakın find aracı tam da istediğim şekilde “<strong><em>test.txt</em></strong>” dosyaları bulundu ve konsola çıktı olarak bastırıldı. Peki ama bu tam olarak nasıl gerçekleşti ? Yani bash kabuğu benim yapmak istediğim işlemi nasıl anladı ve doğru aracı bulup doğru şekilde çalıştırabildi ?</p>

<p>Öncelikle bash kabuğunun bizim girdiğimiz komutu nasıl doğru şekilde anlamlandırabildiğinden kısaca bahsetmemiz gerekirse;</p>

<p>Kabuğa <code class="language-plaintext highlighter-rouge">find /home/ -name test.txt</code> komutunu girdik. Kabuk öncelikle arasında boşluk bulunan tüm ifadeleri argümanlar olarak ayırdı.</p>

<p><img src="https://superua1.github.io//egitim/kabuk/1.png" alt="1.png" class="responsive img-zoomable" /></p>

<p>İlk girilen komut yani ilk argüman <strong>find</strong> olduğu için kabuk “find” ifadesini çalıştırılacak araç olarak kabul ediliyor. Ve bu aracı çalıştırmak için de tabii ki önce bu aracı bulması gerekiyor. Bunun için de ilk olarak bu isimle ile eşleşen dahili bir araç var mı diye bakıyor. Hatırlıyorsanız eğitimin başında kabukların dahili araçları bulunduğundan bahsetmiştik. İşte kabuk bir aracı çalıştırmadan önce kendisine verilmiş olan komuttaki ilk argümanın, dahili bir aracın ismi olup olmadığını kontrol ediyor. find aracı bash kabuğunda dahili bir araç olmadığı için elbette herhangi bir eşleşme olmuyor. find komutu dahili bir komut olmadığı için kabuk bu kez PATH olarak geçen birtakım dizinlerin içinde find ismiyle eşleşen çalıştırabilir bir dosya var mı diye bakıyor. Ve neticede bu dizinlerin birinde find aracının dosyası bulunduğu için bu dosya kabuk tarafından çalıştırıyor.</p>

<p><img src="https://superua1.github.io//egitim/kabuk/2.png" alt="2.png" class="responsive img-zoomable" /></p>

<p>Çalıştırılacak araç bulunduktan sonra burada yer alan ilk argümandan sonraki argümanlar, istisnai durumlar dışında çalıştırılan araca verilecek argümanlar olarak kabul ediliyor. Dolayısıyla find argümanından ardından yazılmış olan argümanlar find aracının çalışma şeklini tanımlamak için bulunuyor. Örneğin ikinci argüman find aracının nerede araştırma yapması yani nereye bakması gerektiğini belirten bir <strong>parametredir</strong>. Buradaki argümana “<strong>parametre</strong>” diyorum çünkü bu argüman find aracının spesifik olarak nereye bakması gerektiğini haber veren bir bilgi bulunduruyor. Buradaki “<strong>/home/taylan/</strong>” dizini yerine başka herhangi bir dizin de belirtilebilir. Yani buradaki argüman aslında çalıştırılan araç için bir parametre.</p>

<p>Üçüncü argüman ise find aracına hangi tipte veri araması gerektiğini belirtmemizi sağlayan <strong>seçenektir</strong>. Seçenekler yazılırken tıpkı bu komutumuzda da olduğu gibi genellikle başında tek ya da çift kısa çizgi bulunduruyor. Tek ya da çift kısa çizgi olması tamamen kullandığınız aracın seçenekleri nasıl kabul ettiğine bağlı. Çünkü seçenekler aslında zaten araç geliştiricileri tarafından aracın çeşitli özelliklerinin kullanılabilmesi için önceden tanımlamış bazı özel ifadelerdir. İleride farklı araçları ele aldığımızda seçeneklerin başında tek veya çift kısa çizgi bulunabildiğini bizzat görmüş olacaksınız zaten.</p>

<p>Burada “<code class="language-plaintext highlighter-rouge">-name</code>” <strong>seçeneğinin</strong> ardından girdiğimiz “<strong>test</strong>” <strong>argümanı</strong> da aranacak dosya veya klasörün ismini belirten parametredir. Biz <code class="language-plaintext highlighter-rouge">-name</code> seçeneği sayesinde find aracına “<strong>test.txt</strong>” ismini araştırmasını özellikle belirtebiliyoruz.</p>

<p><img src="https://superua1.github.io//egitim/kabuk/3.png" alt="3.png" class="responsive img-zoomable" /></p>

<p>En nihayetinde doğru şekilde kullandığımız tüm seçenek ve parametrelerle birlikte find aracına istediğimiz görevi yazılı şekilde iletip, işin yerine getirilmesini sağlayabiliyoruz.</p>

<p>Tekrar özetleyecek olursak: kabuk find aracını bulup çalıştırdı ona buradaki argümanları iletti, find aracı da aldığı argümanları kendisine göre yorumlayıp görevini yerine getirdi. Tüm işleyişin özeti bu.</p>

<p>Elbette kullanılan araca göre seçeneklerin veya parametrelerin çeşidi ve sıralaması farklı olabilir. Çünkü her aracın kendisine verilen argümanları ele alış biçimi farklıdır. Yani aracın yapısına göre girilmesi gereken seçenek ve parametrelerin sıralaması değişebileceği için benim ele aldığım örnekteki sıralamanın ve seçeneklerin doğrudan bir önemi yok, burada önemli olan kavramlardır. <strong>Argüman</strong> ne demek, <strong>seçenek</strong> ne demek, <strong>parametre</strong> ne demek bunları bilmeniz önemli. Çünkü tüm eğitim boyunca bu kavramları kullanarak açıklama yapıyor olacağım. Dolayısıyla benim söylemek istediklerimi doğru şekilde anlayabilmek için bu temel kavramları da biliyor olmanız gerekiyor.</p>

<p>Temel kavramlardan da bahsettiğimize göre anlatım sırasında bahsi geçen <strong>PATH</strong> dizini kavramından bahsederek devam edebiliriz.</p>

<h2 id="path-yolu">PATH Yolu</h2>

<p>PATH esasen sistem üzerinde tanımlı olan bir değişkendir. Bu değişken, kabuğun çalıştırılacak dosyaları araması gereken dizin adreslerini tutuyor. Bu adresleri öğrenmek için daha önce varsayılan kabuğumuzu öğrenirken sorguladığımız <strong>SHELL</strong> değişkinine benzer şekilde PATH değişkenini sorgulamak için kabuğa <code class="language-plaintext highlighter-rouge">echo $PATH</code> komutunu girebiliriz. Buradaki dolar işareti <code class="language-plaintext highlighter-rouge">echo</code> aracının, <strong>PATH</strong> isimli değişkenin değerini konsola bastırmasını sağlıyor. Bu durumdan daha sonra ayrıca detaylı şekilde bahsedeceğiz. Şimdi aldığımız çıktıya odaklanacak olursak:</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">└─</span><span class="nx">$</span> <span class="nx">echo</span> <span class="nx">$PATH</span>
<span class="o">/</span><span class="nx">usr</span><span class="o">/</span><span class="nx">local</span><span class="o">/</span><span class="nx">sbin</span><span class="p">:</span><span class="o">/</span><span class="nx">usr</span><span class="o">/</span><span class="nx">local</span><span class="o">/</span><span class="nx">bin</span><span class="p">:</span><span class="o">/</span><span class="nx">usr</span><span class="o">/</span><span class="nx">sbin</span><span class="p">:</span><span class="o">/</span><span class="nx">usr</span><span class="o">/</span><span class="nx">bin</span><span class="p">:</span><span class="o">/</span><span class="nx">sbin</span><span class="p">:</span><span class="o">/</span><span class="nx">bin</span><span class="p">:</span><span class="o">/</span><span class="nx">usr</span><span class="o">/</span><span class="nx">local</span><span class="o">/</span><span class="nx">games</span><span class="p">:</span><span class="o">/</span><span class="nx">usr</span><span class="o">/</span><span class="nx">games</span>
</code></pre></div></div>

<p>Bakın sıralı şekilde bazı dizin adresleri çıktı olarak bastırıldı. Burada gördüğümüz iki nokta işareti ile ayrılmış olan her bir dizin adresi, kabuğun bir aracın çalıştırılabilir dosyasını ararken soldan sağa doğru sırasıyla bakacağı dizinlerin adresidir. İşte sırasıyla bakılan bu dizinlere de PATH yolu deniyor. Kabuk, harici bir komutu hangi dizinlerde arayacağını bu PATH değişkinine bakarak öğreniyor. Dolayısıyla eğer kabuk üzerinden bir aracı çalıştırmak istiyorsanız, aracın çalıştırılabilir dosyası mutlaka PATH değişkeninde tanımlı olan dizinlerden birinde olmalı. Ayrıca dilerseniz, PATH değişkenine yeni dizin adresleri ekleyerek, kabuğun bakması gereken dizinleri de çoğaltabilirsiniz. Neticede kabuk çalıştırılabilir dosyaları nerelerde araması gerektiğini PATH değişkeninden öğreniyor.</p>

<p>Kabuğa bir komut girdiğimizde, kabuğun bu komut ile eşleşen dosyayı PATH yolunda aradığını ve bulabilirse çalıştırdığını kanıtlamak için hemen basit bir test yapabiliriz.</p>

<p>Test edebilmek için PATH yolundaki herhangi bir dizinde bulunmayan ve çalıştırıldığını bize kanıtlayabilecek bir programa ihtiyacımız var.</p>

<p>Bunun için kabuğa girdiğimiz komutları bir dosyaya kaydedip, komutların bu dosyadan çalıştırılmasını sağlayan bir betik dosyası yani basit bir program oluşturabiliriz. Zaten kabuğun programlanabilir olduğundan daha önce de çok kısaca bahsetmiştim. Kabuk aynı zamanda programlanabilir olduğu için, komutları dosya içine yerleştirip kendi amaçlarımıza uygun betik dosyaları oluşturabiliyoruz. Hemen canlı örneğini görmek için kendimize bir kabuk programı yazalım.</p>

<p>Ben, çalıştığında konsola “<strong>Program Çalıştı!</strong>” ifadesini basacak çok basit bir betik dosyası oluşturmak istiyorum. Tüm işlemleri de komut satırı üzerinden yapacağım. Ancak merak etmeyin burada kullandığım tüm komutları ileride ayrıca ele alıyor olacağız.(Sürekli sonra ele alacağız diyorum, ancak tüm konular birbiri ile bağlı olduğu için böyle olmak zorunda.) Sizin şimdilik sadece beni takip etmeniz yeterli.</p>

<p>Öncelikle içerisinde komutları girebileceğim bir betik dosyası oluşturmak istiyorum. Bunun için konsola <code class="language-plaintext highlighter-rouge">cat &gt; betik.sh</code> şeklinde yazıp komutumuzu girebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]                                    
└─<span class="nv">$ </span><span class="nb">cat</span> <span class="o">&gt;</span> betik.sh                      

</code></pre></div></div>

<p>Buradaki <code class="language-plaintext highlighter-rouge">cat</code> komutunun ardından kullandığımız <code class="language-plaintext highlighter-rouge">&gt;</code> operatörü ile “betik.sh” isimli bir dosya oluşturulmasını ve bu dosyaya konsoldan yeni veriler gireceğimizi belirtmiş olduk. Konsol da bir alt satıra geçip bizden dosyaya yazılacak verileri beklemeye başladı.</p>

<p>Şimdi buraya yazacağımız verileri betik dosyasına kaydetmemiz mümkün. Yani bir nevi komut satırı üzerinden not defteri özelliği gibi düşünebilirsiniz. Ben çalıştırıldığı zaman konsola “<strong>Program Çalıştı</strong>” ifadesini bastıracak bir kabuk programı oluşturmak istiyorum. Bunun için de buraya <code class="language-plaintext highlighter-rouge">echo “Program Çalıştı”</code> şeklinde komutumu ekliyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]                                    
└─<span class="nv">$ </span><span class="nb">cat</span> <span class="o">&gt;</span> betik.sh                      
<span class="nb">echo</span> <span class="s2">"Program Çalıştı"</span>
</code></pre></div></div>

<p>Şimdi artık buraya yazdığım komutun bu dosyaya kaydolması için, yazdıklarımın bittiğini haber vermem gerekiyor. Bunun için de <kbd>Ctrl</kbd> + <kbd>D</kbd> tuşlaması yapmam yeterli. Bu sayede <code class="language-plaintext highlighter-rouge">cat</code> komutu veri girişinin tamamlandığını anlayıp, “betik.sh” isimli dosyaya girdiğim verileri kaydedecek. Hatta kontrol etmek için <code class="language-plaintext highlighter-rouge">cat betik.sh</code> komutu ile dosyanın içeriğini konsola bastırabiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]                                    
└─<span class="nv">$ </span><span class="nb">cat </span>betik.sh                      
<span class="nb">echo</span> <span class="s2">"Program Çalıştı"</span>
┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]                                    
└─<span class="err">$</span>
</code></pre></div></div>

<p>Bakın yazmış olduğum komut bu dosyaya kaydedilmiş.</p>

<p>Böylelikle istediğim amaca uygun bir betik dosyası oluşturmuş oldum. Bu dosyanın çalıştırılabilmesi için son olarak çalıştırma yetkisini de vermemiz gerekiyor. Eğer dosyanın çalıştırma yetkisi yoksa dosya bulunsa dahi çalıştırılamaz. Bu durumu teyit etmek için <code class="language-plaintext highlighter-rouge">./betik.sh</code> komutu ile betik dosyasını çalıştırmayı deneyebiliriz.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">└─</span><span class="nx">$</span> <span class="p">.</span><span class="o">/</span><span class="nx">betik</span>
<span class="nx">bash</span><span class="p">:</span> <span class="p">.</span><span class="o">/</span><span class="nx">betik</span><span class="p">:</span> <span class="nx">Permission</span> <span class="nx">denied</span>
</code></pre></div></div>

<p>Bakın gördüğünüz gibi yetki hatası aldık çünkü bu dosyanın henüz çalıştırılma yetkisi yok. Şimdi bu sorunu aşmak için dosyamıza <code class="language-plaintext highlighter-rouge">chmod +x betik.sh</code> komutu ile çalıştırma yetkisi verelim. Buradaki <code class="language-plaintext highlighter-rouge">chmod</code> komutu okuma yazma ve çalıştırma gibi yetkilerin yönetimi için kullandığımız bir araç.</p>

<p>Neticede bu komutumuzla birlikte artık “betik.sh” dosyasına çalıştırma yetkisini de kazandırmış olduk. Şimdi teyit etmek için tekrar <code class="language-plaintext highlighter-rouge">./betik.sh</code> şeklinde komutumuzu girelim.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">└─</span><span class="nx">$</span> <span class="p">.</span><span class="o">/</span><span class="nx">betik</span><span class="p">.</span><span class="nx">sh</span> 
<span class="nx">Program</span> <span class="nx">Çalıştı</span> <span class="o">!</span>
</code></pre></div></div>

<p>Gördüğünüz gibi bu kez betik dosyası sorunsuzca çalıştı ve konsola “<strong>Program Çalıştı</strong>” ifadesini bastırdı. Artık çalıştırılabilir bir program dosyamız olduğuna göre ve çalıştığını da bizzat teyit ettiğimize göre PATH yolunun amacını uygulamalı olarak test edebiliriz.</p>

<p>Ayrıca burada benim dosyayı çalıştırmak için kullandığım <code class="language-plaintext highlighter-rouge">./betik.sh</code> komutunu merak etmiş olabilirsiniz. Kabuğa çalıştırılacak dosyayı tam konumu ile verdiğinizde kabuk o dosyanın uygun ortamda çalıştırılmasını sağlıyor.  Normalde benim girdiğim <code class="language-plaintext highlighter-rouge">./betik.sh</code> komutu, çalıştırılacak dosyanın tam konumunu belirtiyor. Betik dosyasını şu an kabuğun çalışmakta olduğu dizinde oluşturduğum için, bulunduğum dizini <code class="language-plaintext highlighter-rouge">.</code> <strong>nokta</strong> ile belirtip <code class="language-plaintext highlighter-rouge">/</code> <strong>slash</strong> işaretinin ardından dosyanın ismini yazdığımda kabuk benim “<strong><em>betik.sh</em></strong>” dosyasını çalıştırmak istediğimi anlıyor ve çalıştırıyor. Yani harici olarak PATH yoluna bakmasına gerek kalmıyor çünkü biz doğrudan çalıştırılacak dosyanın konumunu kabuğa bildirmiş oluyoruz.</p>

<p>Neticede kabuğun bir dosyayı çalıştırabilmesi için o dosyanın tam konumunu biliyor olması gerekiyor. Eğer bu dosya kabuğun çalışmakta olduğu mevcut dizinde değilse dosyanın tam dizin adresini uzun uzadıya yazmamız gerekir.</p>

<p>Bu durumu gözlemlemek için dosyamızı farklı bir dizine taşıyalım. Taşıma işlemini komut satırından yapmak istersek İngilizce “move” yani “taşınma” ifadesinin kısaltması olan <code class="language-plaintext highlighter-rouge">mv</code> komutunu kullanabiliriz. Dosyayı taşımak için <code class="language-plaintext highlighter-rouge">mv</code> komutundan sonra taşımak istediğimiz dosyanın tam adresini ve nereye taşımak istediğimizi belirtiyoruz. Betik.sh dosyasını Downloads klasörüne taşıyacağım için ilk olarak betik dosyasının adresini bu şekilde yazdım. Daha sonra dosyanın taşınmasını istediğim dizini de ikinci argüman olarak girdim. Yani taşımak için  <code class="language-plaintext highlighter-rouge">mv betik.sh ~/Downloads/</code> komutunu girip <strong><em>Downloads</em></strong> dizini altına taşıyacağım.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">mv </span>betik.sh ~/Downloads/
</code></pre></div></div>

<p>Konumu değiştiği için konsoldan bu dosyaya ulaşmak için artık <code class="language-plaintext highlighter-rouge">./Downloads/betik.sh</code> şeklinde komut girmem gerekecek. Çünkü betik dosyası kabuğun bulunduğu ev dizini altındaki <strong><em>Downloads</em></strong> klasörü içinde yer alıyor.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>./Downloads/betik.sh 
Program Çalıştı
</code></pre></div></div>

<p>Tabii ki her seferinde dosyaların konumunu hatırlamak ve bu şekilde uzun uzadıya yazmak pek de verimli değil. Çünkü sık kullandığımız bunun gibi pek çok farklı konumda dosyamız olabilir. Bunun yerine çalıştırılacak dosyayı <strong>PATH</strong> yolu üzerinde yer alan bir dizin altına taşırsak, kabuğa yalnızca dosyanın adını vererek istediğimiz konumdan dosyayı çalıştırabiliriz.</p>

<p>Ben bu durumu teyit etmek için <strong>PATH</strong> değişkeninde tanımlı olan dizinlerden birine betik dosyamı taşımak istiyorum. PATH değişkeninde tanımlı olan herhangi bir dizin içine taşıyabiliriz. Ben örnek olarak <strong><em>/usr/local/bin</em></strong> dizini altına taşımak istiyorum.</p>

<p>Fakat PATH yolu üzerinde yer alan dizinler kabuk tarafından taranıp buradaki dosyalar çalıştırıldığı için yetkisi olmayan kullanıcılar buraya yeni dosya ekleyemezler. Sadece yetkisi olan kullanıcılar buraya yeni dosya ekleyebilir. Denemek için <code class="language-plaintext highlighter-rouge">mv ~/Downloads/betik.sh /usr/local/bin</code> komutunu girebiliriz.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">└─</span><span class="nx">$</span> <span class="nx">mv</span> <span class="o">~</span><span class="sr">/Downloads/</span><span class="nx">betik</span><span class="p">.</span><span class="nx">sh</span> <span class="o">/</span><span class="nx">usr</span><span class="o">/</span><span class="nx">local</span><span class="o">/</span><span class="nx">bin</span>                                             
<span class="nx">mv</span><span class="p">:</span> <span class="nx">cannot</span> <span class="nx">move</span> <span class="dl">'</span><span class="s1">betik.sh</span><span class="dl">'</span> <span class="nx">to</span> <span class="dl">'</span><span class="s1">/usr/local/bin/betik.sh</span><span class="dl">'</span><span class="p">:</span> <span class="nx">Permission</span> <span class="nx">denied</span>
</code></pre></div></div>

<p>Neticede gördüğünüz gibi girmiş olduğumuz komut doğru olsa da yetki hatası aldık. Çünkü taşıma işlemini yapmak için yetkili olduğumuzu kanıtlamadık.</p>

<p>Yetkili olduğumuzu kanıtlamak için komutun başına <code class="language-plaintext highlighter-rouge">sudo</code> eklememiz ve mevcut hesabımızın parolasını girmemiz gerekiyor. Komutumuzu bu şekilde düzenleyip tekrar girelim.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">└─</span><span class="nx">$</span> <span class="nx">sudo</span> <span class="nx">mv</span> <span class="o">~</span><span class="sr">/Downloads/</span><span class="nx">betik</span><span class="p">.</span><span class="nx">sh</span> <span class="o">/</span><span class="nx">usr</span><span class="o">/</span><span class="nx">local</span><span class="o">/</span><span class="nx">bin</span>   
<span class="p">[</span><span class="nx">sudo</span><span class="p">]</span> <span class="nx">password</span> <span class="k">for</span> <span class="nx">taylan</span><span class="p">:</span>
</code></pre></div></div>

<p>Bakın benden parola girmemi istiyor, hesabımın parolasını girip onayladığımda dosya ilgili konuma sorunsuzca taşınmış olacak.</p>

<p>Artık bu sayede kabuk hangi konumda çalışıyor olursa olsun betik.sh komutunu girdiğimizde, betik dosyamız çalışacak. Çünkü biz <code class="language-plaintext highlighter-rouge">betik.sh</code> ifadesini girdiğimizde kabuk öncelikle yerleşik komutlara bakacak ve burada olmadığını fark edince <strong>PATH</strong> dizinindeki tüm klasörlere sırasıyla bakarak bu isimle eşleşen dosyayı arayacak. Neticede bizim eklemiş olduğumuz dosyayı bulacak ve çalıştıracak. Yani artık özellikle dosyanın konumunu belirtmemiz gerekmiyor. Hadi hemen denemek için konsola <code class="language-plaintext highlighter-rouge">betik.sh</code> şeklinde yazalım.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">└─</span><span class="nx">$</span> <span class="nx">betik</span><span class="p">.</span><span class="nx">sh</span> 
<span class="nx">Program</span> <span class="nx">Çalıştı</span> <span class="o">!</span>
</code></pre></div></div>

<p>Bakın betik dosyası şu an kabuğun çalıştığı dizinde bulunmuyor olmasına rağmen yalnızca ismini girerek dosyanın çalıştırılmasını sağlayabildik. Hatta dilerseniz daha somut bir teyit olması için grafiksel arayüzden başka bir dizine gidip burada sağ tıklayıp yeni bir bir konsol açıp <code class="language-plaintext highlighter-rouge">betik.sh</code> komutunu burada girmeyi deneyebilirsiniz. Örneğin ben masaüstüne sağ tıklayıp konsolumu açtım ve <code class="language-plaintext highlighter-rouge">betik.sh</code> komutunu girdim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/Desktop]
└─<span class="nv">$ </span>betik.sh
Program Çalıştı!
</code></pre></div></div>

<p>İşte bizzat teyit ettiğimiz gibi bu örnek, kabuğun harici bir programı çalıştırmak için <strong>PATH</strong> olarak geçen dizinlere baktığını kanıtlıyor. Sizler de bu şekilde, kabuk üzerinden ismiyle çağırıp çalıştırmak istediğiniz programlarınızı <strong>PATH</strong> dizinlerinden birine taşıyabilirsiniz. Ayrıca dilersek PATH üzerinde yer alan dizinlere yeni bir dizin daha ekleyebiliriz. Bu sayede eklediğimiz dizin içinde yer alan dosyalar bash kabuğu tarafından çalıştırılacak dosya ismi olarak görülebilirler.</p>

<h3 id="path-yoluna-yeni-dizin-eklemek">PATH Yoluna Yeni Dizin Eklemek</h3>

<p>Anlatımla başlamadan önce PATH yoluna yeni bir dizin eklemenin güvenlik açısından pek önerilen bir işlem olmadığını belirtmek istiyorum. Güvenli değil çünkü yeni eklediğiniz dizin adresi için gereken yetkilendirme ve sıkılaştırma önlemlerini almamış olabiliyoruz. Varsayılan olarak tanımlı olan PATH adreslerinde ise zaten yetkilendirme ayarları yapılmış oluyor. Hatırlarsanız zaten betik dosyamızı taşımak için <code class="language-plaintext highlighter-rouge">sudo</code> komutu ile yetkili olduğumuzu kanıtlamamız gerekmişti. Yani varsayılan PATH dizinlerinin yalnızca yetkili kişilerce düzenlenebilecek şekilde sıkılaştırıldığını bizzat deneyimledik. Bizim sonradan ekleyeceğimiz dizinin yetki ayarları doğu şekilde tanımlı olmazsa bu dizine yetkisiz kullanıcılar da dosya taşıyabilir ve kabuğun bu dosyaları da çalıştırmasını sağlayabilir. Bu durum elbette güvenlik riski demek oluyor.</p>

<p>Dolayısıyla varsayılan olarak tanımlı olan PATH adreslerini kullanmanız çok daha doğru ve güvenli bir yaklaşımdır. Yine de ihtiyaç duymanız halinde kullanabilmeniz, ve kabuğun çalışma yapısını daha iyi kavrayabilmeniz için kısaca PATH yoluna nasıl yeni dizin ekleyebileceğimize de değinmek istiyorum.</p>

<p>Bildiğiniz gibi PATH yolu üzerindeki dizinlerin hangileri olduğunu öğrenmek için <code class="language-plaintext highlighter-rouge">echo $PATH</code> komutunu kullanıyoruz. Hatta kullandığımız bu komutun anlamını özellikle çok kısaca da olsa açıklamıştık hatırlıyorsanız. <code class="language-plaintext highlighter-rouge">echo</code> komutu, kendisine argüman olarak verilen değerleri çıktı olarak bastırıyor. Buradaki <code class="language-plaintext highlighter-rouge">$PATH</code> ifadesi ise bir değişkendir. Eğer programlama geçmişiniz varsa zaten değişkenlerin ne olduğunu mutlaka biliyorsunuzdur. Değişkenler, tanımlı olan değerlere tekrar tekrar tek bir değişken ismi üzerinden ulaşılabilmesini sağlayan yapılardır. Bash kabuğunda da bizzat daha önce de gördüğümüz SHELL ve PATH gibi değişkenler olduğunu zaten biliyoruz. Eğer biz PATH yolunu değiştirmek istiyorsak, PATH değişkeninde tanımlı olan dizinleri yani PATH değişkenin değerini yeniden düzenleyebiliriz. Ancak yeni bir PATH dizini eklemeden önce bash kabuğunda değişkenlerin nasıl çalıştığına temel olarak değinmek istiyorum. Bu sayede gerçekleştireceğimiz işlemleri çok daha bilinçli şekilde yerine getiriyor olacağız.</p>

<h2 id="değişkenler">Değişkenler</h2>

<p>Bask kabuğunda değişken tanımlamak çok kolay. Ben basit bir örnek olması için <code class="language-plaintext highlighter-rouge">ad=taylan</code> şeklinde yazıp <strong>ad</strong> isimli değişkene “<strong>taylan</strong>” değerini tanımlıyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ ad</span><span class="o">=</span>taylan
┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="err">$</span>
</code></pre></div></div>

<p>Bu sayede ne zaman ad isimli değişkeni çağıracak olursam “taylan” verisine ulaşabiliyor olacağım. Hemen denemek için <code class="language-plaintext highlighter-rouge">echo $ad</code> komutuyla değişkenin değerini konsola bastıralım.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$ad</span>
taylan
</code></pre></div></div>

<p>Bakın “taylan” çıktısını almış oldum. Çünkü <code class="language-plaintext highlighter-rouge">echo</code> aracına buradaki <strong>ad</strong> isimli değişkeni konsola bastırması için argüman olarak verdik, <code class="language-plaintext highlighter-rouge">echo</code> aracı da görevini yapıp bu değişkenin değerine bastırdı. Zaten daha önce <strong>PATH</strong> ve <strong>SHELL</strong> değişkenlerini de bu şekilde konsola bastırmıştık. Değişkenlerden önce dolar işareti koyduğumuzda <code class="language-plaintext highlighter-rouge">echo</code> bu ifadenin değişken olduğunu anlıyor.</p>

<p><strong>tanımlamak için:</strong> <code class="language-plaintext highlighter-rouge">değişken-ismi=değişken-değeri</code></p>

<p><strong>bastırmak için:</strong> <code class="language-plaintext highlighter-rouge">echo $değisken-ismi</code></p>

<p>İşte en yalın haliyle bir değişken tanımlamak ve değişkenin değerine görüntülemek bu şekilde. Değişkenler ile ilgili diğer detaylara girmeyeceğiz fakat çok ufak bir detaydan haberdar olmamız gerekir. Bu detay da değişkenin alt kabuklar üzerinde de geçerli olabilmesini sağlayan <code class="language-plaintext highlighter-rouge">export</code> komutu.</p>

<h3 id="export-komutu--global-değişkenler"><code class="language-plaintext highlighter-rouge">export</code> Komutu | Global Değişkenler</h3>

<p>Eğer biz tanımlamış olduğumuz değişkeni <code class="language-plaintext highlighter-rouge">export</code> ile global hale getirmezsek, mevcut kabuğun altında başlatılan diğer kabuklar üzerinden bu değişken değerine ulaşamıyoruz. Bu durumu daha iyi anlamak için mevcut konsolumuza bash komutunu girip yeni bir kabuk başlatalım.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>bash
┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="err">$</span>
</code></pre></div></div>

<p>Bakın ben “bash” komutunu girerek şu anda yeni bir kabuk başlatıp bu kabuğa geçiş yapmış oldum. Yani şu an gireceğim tüm komutlar bu yeni kabuk tarafından işlenecek. Teyit etmek için biraz önce tanımladığım <strong>ad</strong> isimli değişkeni burada da bastırmayı deneyebiliriz. Bunun için tekrar <code class="language-plaintext highlighter-rouge">echo $ad</code> şeklinde komutumuzu girelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$ad</span>
                                            
                                            
┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]                          
└─<span class="err">$</span>
</code></pre></div></div>

<p>Bakın herhangi bir çıktı almadık çünkü ben bu <strong>ad</strong> değişkenini <code class="language-plaintext highlighter-rouge">export</code> komutu ile global hale getirmemiştim. Dolayısıyla yeni açtığım ve şu anda emirler verdiğim bu kabuğun da bu değişkenden haberi yok.</p>

<p>Şimdi bu yeni başlattığımız kabuğu <code class="language-plaintext highlighter-rouge">exit</code> komutu ile kapatıp bir önceki kabuğa dönelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]                          
└─<span class="nv">$ </span><span class="nb">exit                                    
exit</span>                                        
                                            
┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]                          
└─<span class="err">$</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">exit</code> komutu sayesinde yeni başlattığım kabuk kapatıldı, emin olmak için yine <strong>ad</strong> isimli değişkeni <code class="language-plaintext highlighter-rouge">echo $ad</code> komutu ile bastırmayı deneyebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]                          
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$ad</span>
taylan

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="err">$</span>
</code></pre></div></div>

<p>Bakın bu kez sorunsuzca bastırabildim çünkü bu değişkeni zaten bu kabukta tanımlamıştım. Şimdi <strong>ad</strong> isimli değişkenin alt kabuklar tarafından da bulunabilmesi için <code class="language-plaintext highlighter-rouge">export ad</code> komutu ile global hale getirelim ve tekrar <code class="language-plaintext highlighter-rouge">bash</code> komutunu girip yeni bir alt kabuk başlatalım. Kabuk başlatıldıktan sonra da <code class="language-plaintext highlighter-rouge">echo $ad</code> komutu ile değişkenin bu alt kabukta tanınma durumunu yani global olup olmadığını sorgulayalım.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">export </span>ad                               

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>bash                                    
┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$ad</span>                                
taylan

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="err">$</span>
</code></pre></div></div>

<p>Bakın bu kez sorunsuzca değişken değerine ulaşabildik çünkü <code class="language-plaintext highlighter-rouge">export</code> komutu ile bu değişkeni global hale getirdik.</p>

<p>İyi güzel ama, ya yeni bir konsol açarsam, yani mevcut kabuk altında yeni bir kabuk başlatmaktansa yeni bir bağımsız konsoldaki kabuğu kullanırsam ne olur ?</p>

<p>Denemek için yeni bir konsol penceresi açıp <code class="language-plaintext highlighter-rouge">echo $ad</code> komutu ile değişkeni sorgulayabiliriz.</p>

<p><img src="https://superua1.github.io//egitim/kabuk/4.png" alt="4.png" class="responsive img-zoomable" /></p>

<p>Yeni açtığımız konsolda hiç bir çıktı alamadık. Şimdi bir de bu konsol üzerinden <strong>PATH</strong> değişkenini bastırmayı deneyelim.</p>

<p><img src="https://superua1.github.io//egitim/kabuk/5.png" alt="5.png" class="responsive img-zoomable" /></p>

<p>Gördüğünüz gibi her iki konsolda da PATH değişken değeri basıldı. Peki ama nasıl oluyor da bizim <code class="language-plaintext highlighter-rouge">export</code> komutu ile global hale getirdiğimiz değişkene başka bir konsoldan ulaşamıyorken, <strong>PATH</strong> değişkenine tüm konsollardan ulaşabiliyoruz ?</p>

<p>Bu durumun sebebi miras yapısıdır. Mevcut kabuk yalnızca kendisinin başlatmış olduğu yeni işlemlere değişken gibi değerleri miras bırakabiliyor. Biz yeni bir konsol penceresi açtığımızda, halihazırda çalışmakta olan kabuklardan bağımsız yeni bir kabuk bu konsolda başlatılıyor. Dolayısıyla bağımsız bir kabuk tarafından <strong>export</strong> edilen değişken, bir diğer bağımsız kabuk tarafından miras alınamıyor. Çünkü arasında değişken aktarımını gerektirecek bir mirasa bağı bulunmuyor. Mevcut kabuk üzerinden <code class="language-plaintext highlighter-rouge">bash</code> komutu ile yeni kabuk başlattığımızdaysa, mevcut kabuk bu işlemi kendisi başlattığı için değişkenlerini yeni kabuğa miras olarak aktarabiliyor. Tüm meselenin özeti aslında bu.</p>

<p>Peki ama <strong>PATH</strong> değişkenine nasıl tüm konsollardan yani tüm bağımsız kabuklardan ortak olarak ulaşabiliyoruz ?</p>

<p>Bu durumun sebebi, <strong>PATH</strong> değişkeninin kabuk başlatılırken kabuk tarafından okunan konfigürasyon dosyalarından birinde tanımlanmış olması.</p>

<p>Eğer biz de değişkenlerimizi kabuk tarafından okunan bu konfigürasyon dosyalarından birine eklersek, değişkenimiz her yeni başlatılan kabuk tarafından okunacağı için tüm kabuklardan bu değişkene ortak şekilde erişebileceğiz. Peki bu konfigürasyon dosyaları hangi dosyalar diye soracak olursanız:</p>

<p>Bash kabuğu konfigürasyonlar için temelde iki tür dosyayı okuyor. Bunlar; sistem genelinde <strong>tüm kullanıcılar için geçerli olan</strong> ve <strong>spesifik kullanıcıya özel olan</strong> iki farklı türdeki konfigürasyon dosyalarıdır.</p>

<h2 id="konfigürasyon-dosyaları">Konfigürasyon Dosyaları</h2>

<h5 class="turuncu">Sistem Geneli İçin Yapılandırma</h5>

<p>Linux çok kullanıcılı bir işletim sistemi olduğu için tüm kullanıcılar üzerinde geçerli olabilecek toplu yapılandırma kuralları tanımlayabilmek adına sistem genelinde kullanılan yapılandırma dosyalarında düzenlemeler yapabiliriz.</p>

<p><strong class="turuncu">Sistem Geneli:</strong></p>

<ul>
  <li>/etc/profile</li>
  <li>/etc/bashrc</li>
  <li>/etc/bash.bashrc</li>
</ul>

<h5 class="yesil">Kullanıcı Bazlı Yapılandırma</h5>

<p>Değişikliklerin tüm kullanıcıları değil de özel olarak tek bir kullanıcıyı etkilemesini istersek, kullanıcının kendi ev dizininde bulunan yapılandırma dosyalarında düzenlemeler yapabiliriz.</p>

<p><strong class="yesil">Kullanıcıya Özel:</strong></p>

<ul>
  <li>~/.bash_profile</li>
  <li>~/.bashrc</li>
  <li>~/.bash_login</li>
  <li>~/.profile</li>
</ul>

<p>İşte ihtiyaçlarımıza göre hangi kapsamda değişiklik yapmak istiyorsak ona uygun dosyalarda düzenleme yapmamız gerekiyor.</p>

<p>Ben hepsini listeledim ancak tabii ki tüm sistemlerde saydığım tüm bu dosyalar varsayılan olarak bulunmuyor olabilir. Tek yapmanız gereken benim saymış olduğum dosyalardan hangisi sizin sisteminizde mevcutsa o dosyada değişiklik yapmak. Çünkü farklı dağıtımlar farklı dosyaları konfigürasyon için kullanabiliyor. Ancak merak etmeyin farklılıkların doğrudan bir önemi yok. Sizin kullanmakta olduğunuz sistemde hangi yapılandırma dosyası mevcutsa onu düzenleyip kullanabilirsiniz. Zaten muhtemelen kullandığınız dağıtımda benim bahsettiğim dosyalardan biri yoksa diğeri mutlaka vardır. Biraz göz atarsanız hangisini kullanmanız gerektiğini kolayca fark edebilirsiniz.</p>

<p>Birden fazla dosya bulunuyor olmasının bir nedeni var ancak ben temel eğitim için bahsedip kafanızı karıştırmak istemiyorum. Buradaki dosyaların hepsinin kullanım amacı ve okunma sıralaması farklı. Eğer daha fazla detay öğrenmek isterseniz <a href="https://superua1.github.io//bash-konfigurasyon-dosyaları.html">buraya</a> göz atabilirsiniz.</p>

<p>Tekrar konumuza dönecek olursak, siz bash kabuğundaki değişiklikleri hangi düzeyde gerçekleştirmek istiyorsanız ona uygun olan konfigürasyon dosyalarından birinde düzenleme yapmanız gerekiyor. Örneğin ben sistemdeki tüm kullanıcıların PATH yolunu düzenlemek istersem, benim kullanmakta olduğum dağıtımda mevcut bulunan ve tüm kullanıcılar için geçerli olan <strong><em>/etc/bash.bashrc</em></strong> dosyasında düzenleme yapabilirim. Ya da spesifik olarak yalnızca kendi kullanıcı hesabım için PATH yolunu değiştirmek istersem bu değişikliği kendi ev dizinimdeki yani örneğin <strong><em>/home/taylan</em></strong> dizini altındaki <strong><em>.bashrc</em></strong> dosyasında yapabilirim.</p>

<p>Bu kadar açıklama yeter. Bizzat uygulayarak bahsetmiş olduklarımızın sonuçlarını gözlemleyelim. Örnek olarak PATH yoluna yeni bir dizin adresi eklemeyi deneyebiliriz.</p>

<h2 id="path-yoluna-yeni-dizin-eklemek-1">PATH Yoluna Yeni Dizin Eklemek</h2>

<p>Ben PATH yolundaki değişikliğin tüm sistem genelinde yani tüm kullanıcılar üzerinde ortak olarak etkili olmasını istediğim için <strong><em>/etc/bash.bashrc</em></strong> dosyasında değişiklik yapacağım.</p>

<p>Öncelikle ekleyeceğimiz yeni dizini oluşturmak üzere <code class="language-plaintext highlighter-rouge">mkdir ~/Desktop/yeni-dizin</code>komutu ile masaüstü dizinimizde “<strong><em>yeni-dizin</em></strong>” isimli klasörümüzü oluşturalım.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">mkdir</span> ~/Desktop/yeni-klasor
</code></pre></div></div>

<p>Şimdi bu klasörün tam dizin adresini PATH yoluna ekleyebiliriz. Eklemek için <code class="language-plaintext highlighter-rouge">sudo nano /etc/bash.bashrc</code> komutu ile konfigürasyon dosyasını açalım. <code class="language-plaintext highlighter-rouge">sudo</code> komutu parola girmenizi isteyecektir, hesabınızın parolasını girip <kbd>enter</kbd> tuşu ile onaylayın.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">sudo </span>nano /etc/bash.bashrc
<span class="o">[</span><span class="nb">sudo</span><span class="o">]</span> password <span class="k">for </span>taylan:
</code></pre></div></div>

<p><img src="https://superua1.github.io//egitim/kabuk/6.gif" alt="6.gif" class="responsive img-zoomable" /></p>

<p class="mavi"><strong>Not:</strong> Burada dosyanın ismini nokta da dahil eksiksiz yazdığınızdan emin olun. Eğer doğru yazmasanız veya gereksiz yere boşluk bırakırsanız dosya açılmaz çünkü ilgili dosya bulunamaz. </p>

<p>Açılmış olan bu dosya içerisine <strong>PATH</strong> değişkeninin değeri olarak yeni oluşturduğumuz dizini de eklememiz gerekiyor. Bu noktada eklemek istediğiniz dizinin tam adresini doğru şekilde girmeniz şart. Örneğin ben taylan kullanıcısının ev dizini altındaki <strong><em>Desktop</em></strong> klasörü içerisinde “yeni-dizin” isimli klasörü eklemek istediğim için tam olarak “<strong><em>/home/taylan/Desktop/yeni-dizin</em></strong>” dizinini belirtmem gerek. Siz de kendi dizininize göre bu adresi belirtmelisiniz. Eğer eklemek istediğiniz dizinin tam konumunu bilmiyorsanız ilgili dizindeyken sağ tıklayıp konsolu burada başlata seçeneği ile konsolu açın ve <code class="language-plaintext highlighter-rouge">pwd</code> komutunu girip mevcut dizin adresini öğrenin.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/Desktop/yeni-dizin]       
└─<span class="nv">$ </span><span class="nb">pwd</span>                                      
/home/taylan/Desktop/yeni-dizin
</code></pre></div></div>

<p>Dizin adresinden emin olduktan sonra <code class="language-plaintext highlighter-rouge">export PATH=”$PATH:yeni-dizin-adresi”</code> şeklinde <strong>PATH</strong> yoluna eklemek istediğiniz yeni dizini tanımlamanız gerek. Örneğin ben aşağıdaki şekilde tanımlıyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span>”<span class="nv">$PATH</span>:/home/taylan/Desktop/yeni-dizin/”
</code></pre></div></div>

<p><img src="https://superua1.github.io//egitim/kabuk/7.png" alt="7.png" class="responsive img-zoomable" /></p>

<p>Tanımlamayı açıklayacak olursak buradaki <code class="language-plaintext highlighter-rouge">export</code> komutu bildiğiniz gibi kendisinden sonraki değişkeni global hale getiriyor. Buradaki değişikliğin bu konfigürasyon dosyasını okuyan tüm kabuklarda geçerli olması için <code class="language-plaintext highlighter-rouge">export</code> kullandık. <code class="language-plaintext highlighter-rouge">export</code> komutundan sonra tekrar <strong>PATH</strong> isimli değişken tanımlayıp <code class="language-plaintext highlighter-rouge">$PATH</code> sayesinde mevcut PATH değişkenin değerini koruduk. Mevcut değişken değerinden sonra iki nokta karakterinin hemen ardından da yeni dizin adresini ekledik. Bu sayede PATH yolundaki eski dizin adresleri korunup, yeni dizin adresi de sonuna eklenmiş oldu.</p>

<p>Eğer kafanıza takıldıysa, burada iki nokta üst üste işareti kullandım çünkü <strong>PATH</strong> yolundaki tüm dizinler birbirinden iki nokta üst üste karakteri ile ayrılıyor. Ben de mevcut <strong>PATH</strong> yolundaki dizinlere ek olarak yeni oluşturduğum klasörün tam dizin adresini de eklemiş oldum.</p>

<p>Benim kullanıcı hesabım <strong>taylan</strong> olduğu için benim ev dizinim de <strong><em>/home/taylan/</em></strong> dizini altında bulunuyor. Ben bu klasörü kendi ev dizimde oluşturduğum için de buraya <strong><em>/home/taylan/Desktop/yeni-dizin</em></strong> şeklinde tam olarak yazdım. Örneğin sizin kullanıcı adınız <strong>hasan</strong> veya <strong>ayse</strong> ise sizin ev dizininiz <strong><em>/home/ayse</em></strong> veya <strong><em>/home/hasan</em></strong> şeklinde olacağı için dizin adresini doğru şekilde yazdığınızdan emin olun. Aksi halde bu tanımlama geçersiz olur. Tekrar ediyorum; <strong>PATH</strong> yoluna eklemek için oluşturduğunu yeni dizinin tam adresini ve klasör ismini eksiksiz şekilde girmeniz gerekiyor. Bu dizinin ne olduğundan emin olmak isterseniz grafiksel arayüzünden dosya yöneticisi yardımıyla oluşturduğunuz klasörün içine girip veya burada konsol başlatıp <code class="language-plaintext highlighter-rouge">pwd</code> komutuyla dosya yolu hakkında bilgi alabilirsiniz. Zaten zor bir şey değil fakat genellikle dikkatsiz öğrenciler karışıklık yaşayabiliyor.</p>

<p>Tamamdır, neticede yeni dizinimizi konfigürasyon dosyasına ekledik. Şimdi bu değişikliğin kaydolması için bu konfigürasyon dosyasını kaydetmemiz gerekiyor. Daha önce de yaptığımız gibi nano aracından çıkıp dosyayı kaydetmek için <kbd>Ctrl</kbd> + <kbd>X</kbd> tuşlaması yapıp, kayıt için <kbd>Y</kbd> tuşu ile onay vermemiz ve <kbd>enter</kbd> ile dosyayı kapatmamız yeterli.</p>

<p><img src="https://superua1.github.io//egitim/kabuk/8.gif" alt="8.gif" class="responsive img-zoomable" /></p>

<p>Dosyamızı kaydettikten sonra değişikliğin geçerli olması için oturumumuzu kapatıp tekrar açmamız gerek çünkü bu dosya biz oturum açarken okunan bir konfigürasyon dosyası. Ayrıca eğer oturumu kapatıp açmak istemezseniz <code class="language-plaintext highlighter-rouge">source</code> komutundan sonra değişikliğin okunup geçerli olmasını istediğiniz dosyanın ismini de girebilirsiniz. Örneğin <code class="language-plaintext highlighter-rouge">*/etc/bash.bashrc*</code> dosyasında değişiklik yaptığım için <code class="language-plaintext highlighter-rouge">source /etc/bash.bashrc</code> şeklinde komut girebilirim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">source</span> /etc/bash.bashrc

taylan@linuxdersleri.net:~<span class="err">$</span>
</code></pre></div></div>

<p>Tamamdır <code class="language-plaintext highlighter-rouge">source</code> komutum sayesinde değişiklik anında geçerli oldu. Teyit etmek için <code class="language-plaintext highlighter-rouge">echo $PATH</code> komutu ile <strong>PATH</strong> değişkenini bastırabiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>taylan@linuxdersleri.net:~<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$PATH</span>
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/games:/usr/games:/home/taylan/Desktop/yeni-dizin

</code></pre></div></div>

<p>Bakın yeni eklemiş olduğun dizin adresi <strong>PATH</strong> yolu üzerinde gözüküyor. Bu da demek oluyor ki artık bu klasör içinde bulunan tüm dosyalar, biz isimlerini kabuğa yazdığımızda kabuk tarafından bulunup çalıştırılabiliyor olacaklar. Denemek için hemen basit bir örnek yapalım.</p>

<p>Örnek için <code class="language-plaintext highlighter-rouge">cat &gt; test.sh</code> şeklinde yeni bir dosya oluşturmak üzere komutumuzu girelim. Konsola çıktı bastırması için de <code class="language-plaintext highlighter-rouge">echo “bu bir test programıdır”</code> şeklinde yazıp <kbd>Ctrl</kbd> + <kbd>D</kbd> tuşlaması ile dosyanın kaydolmasını sağlayalım. Son olarak çalıştırılabilmesi için <code class="language-plaintext highlighter-rouge">chmod +x  test.sh</code> komutu ile çalıştırma yetkisini de verelim. Son olarak bu dosyayı yeni oluşturduğunuz “<strong><em>yeni-dizin</em></strong>” dizinine taşımak için <code class="language-plaintext highlighter-rouge">mv test.sh ~/Desktop/yeni-dizin/</code> komutunu girelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>taylan@linuxdersleri.net:~<span class="nv">$ </span><span class="nb">cat</span> <span class="o">&gt;</span> test.sh
<span class="nb">echo</span> <span class="s2">"bu bir test programıdır"</span>                
                                                   
taylan@linuxdersleri.net:~<span class="nv">$ </span><span class="nb">chmod</span> +x test.sh                      
                                                          
taylan@linuxdersleri.net:~<span class="nv">$ </span><span class="nb">mv </span>test.sh ~/Desktop/yeni-dizin/                
                                                              
taylan@linuxdersleri.net:~<span class="err">$</span>
</code></pre></div></div>

<p>Böylelikle, test betiğimizi PATH yoluna eklemiş olduğumuz yeni dizine taşımış olduk. Yani artık konsola test.sh yazdığımda bu dosya çalışıyor olacak.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>taylan@linuxdersleri.net:~<span class="nv">$ </span>test.sh
bu bir <span class="nb">test </span>programıdır

taylan@linuxdersleri.net:~<span class="err">$</span>
</code></pre></div></div>

<p>Bakın dosyanın konumunu belirtmeden yalnızca dosya ismiyle çalıştırabildim çünkü “yeni-dizin” isimli klasör, kabuğun komutları çalıştırmadan önce baktığı <strong>PATH</strong> yoluna ekli ve bu betik dosyası da bu dizin içinde. Tabii ki bu pek güvenli bir yöntem olmadığı için varsayılan <strong>PATH</strong> yoluna yeni bir dizine eklemenizi eğer ne yaptığınızdan emin değilseniz kesinle önermiyorum.</p>

<p>Yine de anlatımları dikkatli biçimde takip ettiyseniz <strong>PATH</strong> yoluna yeni dizin eklemenin ne kadar kolay olduğunu sizler de fark etmişsinizdir.</p>

<p>Eğer eklediğimiz yeni dizini silmek istersek değişiklik yaptığımız konfigürasyon dosyasını tekrar açıp, yaptığımız değişikliği sildikten sonra dosyayı kaydetmemiz yeterli. Tabii ki değişikliğin geçerli olması için de oturumunuzu kapatıp tekrar açabilir ya da <code class="language-plaintext highlighter-rouge">source</code> komutu ile ilgili konfigürasyon dosyasındaki değişikliklerin geçerli olmasını sağlayabilirsiniz.</p>

<p>Ben örnek olması için tüm kullanıcıları etkileyen <strong><em>/etc/bash.bashrc</em></strong> dosyasında değişiklik yaptım. Eğer siz yalnızca tek bir kullanıcıyı etkileyecek şekilde değişiklik yapmak isterseniz kullanıcının kendi ev dizininde bulunan ilgili konfigürasyon dosyasında değişiklik yapabilirsiniz. Örneğin ben kendi kullanıcıma özel olan bir konfigürasyon tanımlamak istersem /<strong><em>home/taylan/</em></strong> dizinimde bulunan <strong><em>.bashrc</em></strong> dosyasında değişiklik yapabilirim. Aynı işlem olduğu için ben tekrar bu değişiklikten bahsetmeyeceğim fakat dediğim gibi spesifik bir kullanıcıyı etkileyecek değişiklik için o kullanıcının ev dizinindeki <strong><em>.bashrc</em></strong> dosyasında tıpkı burada ele aldığımız gibi değişiklik yapabilirsiniz.</p>

<h2 id="gizli-klasörler-hakkında">Gizli Klasörler Hakkında</h2>

<p>Hazır yeri gelmişken belirtelim, Linux sisteminde isminin başında nokta bulunan dosya ve klasörler gizli olarak sayılıyorlar. Örneğin grafiksel arayüzdeki dosya yöneticisini açtığınızda bu dosya yöneticisi varsayılan olarak ev dizininizde çalışmaya başlar. Fakat buraya göz atacak olursanız burada <strong><em>.bashrc</em></strong> isimli bir dosya göremezsiniz. Çünkü bu dosya isminin başındaki nokta karakteri bu dosyanın gizli olmasını sağlıyor.</p>

<p><img src="https://superua1.github.io//egitim/kabuk/9.png" alt="9.png" class="responsive img-zoomable" /></p>

<p>Grafiksel arayüzden gizli dosyaları görmek için dosya yöneticisinin ayarlarına göz atıp gizli dosyaları gösterme özelliğini aktifleştirebiliriz. Biraz kurcalarsanız sizin kullandığınız dosya yöneticisinde nasıl yapabileceğinizi kolaylıkla keşfedebilirsiniz. Gizli dosyaları nasıl görünür kılacağınızı kendiniz keşfetmelisiniz çünkü bu ayarın konumu, kullandığınız dosya yöneticisine göre değişiklik gösterecektir.</p>

<p><img src="https://superua1.github.io//egitim/kabuk/10.gif" alt="10.gif" class="responsive img-zoomable" /></p>

<p>Bakın gizli olanları gösterme özelliğini aktifleştirdiğimde, aslında ev dizinimde gizli dosya ve klasörler olduğunu grafiksel arayüz üzerinden de görebiliyorum. Hatta emin olmak istersek burada isminin başında nokta karakteri olacak şekilde yeni bir klasör ve yeni bir dosya oluşturmayı da deneyebilirsiniz. Dosya ve klasörleri oluşturduktan sonra gizlilik ayarlarını değiştirerek durumlarını teyit edebilirsiniz.</p>

<p>Neticede bizzat deneyimlediğimiz gibi isminin başında nokta bulunan tüm dosya ve klasörler Linux üzerinde gizli statüsündedir. Bu durumu yalnızca grafiksel arayüze özel olarak da düşünmeyin. Komut satırı üzerinde de gizli dosyalar üzerinde çalışmak için  komutlarımızı gizli dosya ve klasörleri etkileyecek şekilde girmemiz gerekiyor.</p>

<p>Bu durumu teyit etmek için yeni bir konsol açıp ls komutunu girebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">ls
</span>Desktop    Downloads  Pictures  Templates
Documents  Music      Public    Videos

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="err">$</span>
</code></pre></div></div>

<p>Bakın benim ev dizinimde gizli olmayan içerikler listelendi. Eğer gizli olanlar da dahil tüm içeriği listelemek istersem <code class="language-plaintext highlighter-rouge">ls</code> komutuma bu kez <code class="language-plaintext highlighter-rouge">-a</code> seçeneğini eklemem gerek.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-a</span>
<span class="nb">.</span>
..
.bash_history
.bash_logout
.bashrc
.bashrc.original
.bashrc.save
.bashrc.save.1
.bashrc.save.2
.cache
.config
Desktop
.dmrc
Documents
Downloads
.face
.face.icon
.gizli-dosya
.gizli-klasor
.gnupg
.ICEauthority
.java
.lesshst
.local
.mozilla
Music
Pictures
.profile
Public
.swp
Templates
.vboxclient-clipboard.pid
.vboxclient-display-svga-x11.pid
.vboxclient-draganddrop.pid
.vboxclient-seamless.pid
Videos
.wget-hsts
.Xauthority
.xsession-errors
.xsession-errors.old
.zsh_history
.zshrc

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="err">$</span>
</code></pre></div></div>

<p>İşte tıpkı burada ele aldığımız <code class="language-plaintext highlighter-rouge">ls</code> komutu gibi, komut girerken gizli içerikleri de dahil etmek için komutlarımızın uygun seçeneklerini kullanmamız gerekiyor.</p>

<p>Tabii ki gizlilik özelliği çoğunlukla önemli dosya ve klasörleri korumak adına kullanılan bir özellik. Örneğin .bashrc dosyası önemli bir konfigürasyon dosyası olduğu için bu dosyayı gizleyerek yanlışlıkla silinmesi veya üzerinde işlem yapılması gibi olası hatalar da önlemiş oluyor. Zaten bu sebeple istisnalar hariç neredeyse hiç bir araç <code class="language-plaintext highlighter-rouge">ls</code> komutunda olduğu gibi biz özellikle belirtmediğimiz sürece gizli olan dosya ve klasörleri işleme dahil etmezler. Bu sayede gizli içeriklerin bilinçsizce zarar görmesi de engellenmiş oluyor.</p>

<p>Tekrar ana konumuza dönecek olursak size son olarak konfigürasyon dosyalarında değişiklik yaparken dikkatli olmanız gerektiğini söylemek istiyorum. Eğer değişiklik yapmanız gerekiyorsa, konfigürasyon dosyalarınızın var olan yapısını bozmadan neler eklediğinizin de farkında olarak değişiklik yapın. <strong>Ve değişiklik yapmadan önce mutlaka mevcut dosyanın yedeğini alın.</strong> Bu sayede hatalı konfigürasyonlardan kolayca eskisine dönüş yapabilirsiniz. Özellikle zamanla içerisine pek çok ekstra konfigürasyon tanımlaması eklenmiş dosyaların yeni eklemelerden önce mutlaka yedeklerinin alınması gerekiyor. Aksi halde kabuğun doğru şekilde çalışmamasına ve sistem güvenliğinin ihlaline sebep olabilirsiniz.</p>

<p>Böylelikle konsola bir komut girdiğimizde, temelde neler olduğunu öğrenmiş olduk.</p>

<p>Tabii ki bölümün başında da belirttiğim gibi aslında konuşulabilecek çok daha fazla ek detay bulunuyor ancak Linux’u temel seviyede kullanmak için diğer detaylar fazla gelip kafanızı karıştırabilir. Hatta belki ilk defa Linux ile tanışanlar bu bölümdeki anlatımları takip ederken biraz zorlanmış olabilirler. Eğer öyleyse size önerim bu bölümü baştan tekrar edip anladığınıza emin olduktan sonra eğitime devam etmeniz. Çünkü bu bölümde ele aldıklarımız aslında çok basit ama birbiriyle bağlantılı önemli temel kavramlardan oluşuyor. Tam olarak dikkatinizi veremediyseniz veya yorgunken takip ettiyseniz belki sıkıcı veya biraz karışık gelmiş olabilir. Tek ihtiyacınız dikkatli bir biçimde adım adım takip etmek.</p>

<p>Eğer şahsi olarak daha ileri araştırma yapmak isterseniz buradan öğrendiklerinize ek olarak internet üzerinde bu konu özelinde araştırma yapabilirsiniz. Ben herkese hitap edebilecek temel seviye eğitim sunmak istediğim için diğer detaylara girip kafanızı karıştırmak istemiyorum. Burada öğrendiklerimiz bu eğitimi takip edip temel seviye Linux kullanımını öğrenmek için gayet yeterli. Eğitimin devamında burada edindiğimiz temel üzerine yeni bilgilerimizi ekliyor olacağız.</p>

<p>Bir sonraki bölümde bize hız kazandırabilecek bazı kısayollardan bahsederek devam ediyor olacağız.</p>

<p></p>
          <div align="center" class="custom-control custom-switch">
                
            <input type="checkbox" class="custom-control-input" id="readCheckbox"  onchange="markAsRead()">
            <label class="custom-control-label" for="readCheckbox">Okundu Olarak İşaretle  </label>
          </div>
          <p></p>
          <div align="center">
            <button id="linkedinShareButton" class="mavi btn btn-outline-primary">
              <svg width="24px" height="24px" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" fill="none"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"><path fill="#0A66C2" d="M12.225 12.225h-1.778V9.44c0-.664-.012-1.519-.925-1.519-.926 0-1.068.724-1.068 1.47v2.834H6.676V6.498h1.707v.783h.024c.348-.594.996-.95 1.684-.925 1.802 0 2.135 1.185 2.135 2.728l-.001 3.14zM4.67 5.715a1.037 1.037 0 01-1.032-1.031c0-.566.466-1.032 1.032-1.032.566 0 1.031.466 1.032 1.032 0 .566-.466 1.032-1.032 1.032zm.889 6.51h-1.78V6.498h1.78v5.727zM13.11 2H2.885A.88.88 0 002 2.866v10.268a.88.88 0 00.885.866h10.226a.882.882 0 00.889-.866V2.865a.88.88 0 00-.889-.864z"></path></g></svg>
              Paylaş
            </button>
            <button id="twitterShareButton" class="mavi btn btn-outline-primary">
              <svg width="24px" height="24px" viewBox="0 -4 48 48" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000000"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <title>Twitter-color</title> <desc>Created with Sketch.</desc> <defs> </defs> <g id="Icons" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"> <g id="Color-" transform="translate(-300.000000, -164.000000)" fill="#00AAEC"> <path d="M348,168.735283 C346.236309,169.538462 344.337383,170.081618 342.345483,170.324305 C344.379644,169.076201 345.940482,167.097147 346.675823,164.739617 C344.771263,165.895269 342.666667,166.736006 340.418384,167.18671 C338.626519,165.224991 336.065504,164 333.231203,164 C327.796443,164 323.387216,168.521488 323.387216,174.097508 C323.387216,174.88913 323.471738,175.657638 323.640782,176.397255 C315.456242,175.975442 308.201444,171.959552 303.341433,165.843265 C302.493397,167.339834 302.008804,169.076201 302.008804,170.925244 C302.008804,174.426869 303.747139,177.518238 306.389857,179.329722 C304.778306,179.280607 303.256911,178.821235 301.9271,178.070061 L301.9271,178.194294 C301.9271,183.08848 305.322064,187.17082 309.8299,188.095341 C309.004402,188.33225 308.133826,188.450704 307.235077,188.450704 C306.601162,188.450704 305.981335,188.390033 305.381229,188.271578 C306.634971,192.28169 310.269414,195.2026 314.580032,195.280607 C311.210424,197.99061 306.961789,199.605634 302.349709,199.605634 C301.555203,199.605634 300.769149,199.559408 300,199.466956 C304.358514,202.327194 309.53689,204 315.095615,204 C333.211481,204 343.114633,188.615385 343.114633,175.270495 C343.114633,174.831347 343.106181,174.392199 343.089276,173.961719 C345.013559,172.537378 346.684275,170.760563 348,168.735283" id="Twitter"> </path> </g> </g> </g></svg>
              Paylaş
            </button>
            <p></p>
            <h5>📮 Hata, eksik ve öneri bildirimlerinizi <a href="https://superua1.github.io//bildirim.html">buradan</a> iletebilirsiniz. </h5>
          </div>

        <p></p>



  

  

  

  

  
    
    
    
    


<div data-pagefind-ignore="all" class="row mb-2">
  
      
    <div class="col-md-6">
      <div class="no-gutters border rounded overflow-hidden flex-md-row mb-4 shadow-sm h-md-250 position-relative">
        <div class="col p-4 d-flex flex-column position-static">
          <div class="row">
            <div align="left" class="align-self-center col-2">
              <svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 320 512">
                <!--! Font Awesome icon code -->
                <path d="M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l192 192c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L77.3 256 246.6 86.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-192 192z" fill="currentColor"/>
              </svg>
            </div>
            <div align="right" class="col-10">
              <div class="mb-1 text-muted"><strong>Önceki</strong></div>
              <p class="card-text">Sistem Mimarisine Giriş</p>
            </div>
          </div>
          <a href="https://superua1.github.io//egitim/linux-sistem-mimarisine-giris/" title="Sistem Mimarisine Giriş" class="stretched-link"></a>
        </div>
      </div>
    </div>
  

  
      
    <div class="col-md-6">
      <div class="no-gutters border rounded overflow-hidden flex-md-row mb-4 shadow-sm h-md-250 position-relative">
        <div class="col p-4 d-flex flex-column position-static">
          <div class="row">
            <div align="left" class="col-10">
              <div class="mb-1 text-muted"><strong>Sonraki</strong></div>
              <p class="card-text">Linux Kısayolları</p>
            </div>
            <div align="right" class="align-self-center col-2">
              <svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 320 512">
                <!--! Font Awesome icon code -->
                <path d="M310.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-192 192c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L242.7 256 73.4 86.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l192 192z" fill="currentColor"/>
              </svg>
            </div>
          </div>
          <a href="https://superua1.github.io//egitim/linux-k%C4%B1sayollar%C4%B1/" title="Linux Kısayolları" class="stretched-link"></a>
        </div>
      </div>
    </div>
  
</div>


      </div>

      <div class="col-md-3">
        <p></p>
        <div class="no-gutters border rounded overflow-hidden flex-md-row mb-4 shadow-sm h-md-250 position-relative">
          <h3 align="center" class="mavi">Sayfa İçeriği</h3>
          <div data-pagefind-subpage>
            <ul id="toc" class="section-nav">
<li class="toc-entry <hh2"><a href="#path-yolu">PATH Yolu</a>
<ul>
<li class="toc-entry <hh3"><a href="#path-yoluna-yeni-dizin-eklemek">PATH Yoluna Yeni Dizin Eklemek</a></li>
</ul>
</li>
<li class="toc-entry <hh2"><a href="#değişkenler">Değişkenler</a>
<ul>
<li class="toc-entry <hh3"><a href="#export-komutu--global-değişkenler">export Komutu | Global Değişkenler</a></li>
</ul>
</li>
<li class="toc-entry <hh2"><a href="#konfigürasyon-dosyaları">Konfigürasyon Dosyaları</a>
<ul>
<li class="toc-entry <hh5"><a href="#sistem-geneli-i%CC%87%C3%A7in-yap%C4%B1land%C4%B1rma">Sistem Geneli İçin Yapılandırma</a></li>
<li class="toc-entry <hh5"><a href="#kullan%C4%B1c%C4%B1-bazl%C4%B1-yap%C4%B1land%C4%B1rma">Kullanıcı Bazlı Yapılandırma</a></li>
</ul>
</li>
<li class="toc-entry <hh2"><a href="#path-yoluna-yeni-dizin-eklemek-1">PATH Yoluna Yeni Dizin Eklemek</a></li>
<li class="toc-entry <hh2"><a href="#gizli-klasörler-hakkında">Gizli Klasörler Hakkında</a></li>
</ul>
          </div>
        </div>
        <p></p>

	  
	  
      <div class="no-gutters border rounded overflow-hidden flex-md-row mb-4 shadow-sm h-md-250 position-relative">
        <div class="col p-4 d-flex flex-column position-static">
			<p align="center" class="mavi text-primary">Video Eğitim</p>
		<img src="https://superua1.github.io//video-egitim.png"/>
          <p class="card-text mb-auto">Buradaki anlatımları, video eğitim üzerinden takip etmek ve gerektiğinde soru sorabilmek isterseniz kursa gözatın.</p>
         <a href="https://www.udemy.com/course/kali-linux-ile-sifirdan-temel-linux-egitimi/?referralCode=04ABD09E6ED5DA93F7A2" class=" stretched-link"></a>
        </div>
        </div>
  
        <p></p>

	  
	  
      <div class="no-gutters border rounded overflow-hidden flex-md-row mb-4 shadow-sm h-md-250 position-relative">
        <div class="col p-4 d-flex flex-column position-static">
			<p align="center" class="kirmizi text-danger">Kitap</p>
		<img src="https://superua1.github.io//kitap.png"/>
          <p class="card-text mb-auto">Linux sistem yönetimine giriş için kitap arıyorsnız gözatın.</p>
         <a href="https://www.udemy.com/course/kali-linux-ile-sifirdan-temel-linux-egitimi/?referralCode=04ABD09E6ED5DA93F7A2" class=" stretched-link"></a>
        </div>
        </div>
  
      </div>
	  
    </div>
</div>
  
  <hr>

<footer class="container py-5">
  <div class="row">
    <div class="col-6 col-md">
 <h5><a href="/">Linux Dersleri</a> | <a target="_blank" href="https://github.com/Linux-Dersleri/linux-dersleri.github.io"><i class="fa fa-github fa-lg"></i></a></h5>
 <p class="small">GNU/Linux için Türkçe içerik sağlamak üzere kurulmuş bir platformdur.</p>
	 
	  
    </div>
    <div class="col-6 col-md">
      <h5>Eğitim Serileri</h5>
      <ul class="list-unstyled text-small">
        <li><a class="text-muted" href="#">Sıralı Doküman</a></li>
        <li><a class="text-muted" href="#">Video Eğitim</a></li>
      </ul>
    </div>
    
  
    <div class="col-6 col-md">
      <h5>Hakkında</h5>
      <ul class="list-unstyled text-small">
        <li><a class="text-muted" href="https://superua1.github.io//sıkca-sorulan-sorular.html">S.S.S.</a></li>
        <li><a class="text-muted" href="https://superua1.github.io//gizlilik.html">Veri Politikası</a></li>
        <li><a class="text-muted" href="https://superua1.github.io//bildirim.html">Geri Bildirim</a></li>
		<li><a class="text-muted" href="mailto: info@linuxdersleri.net">İletişim</a></li>
      </ul>
    </div>
	<div class="col-6 col-md">
      <h5>Android Uygulaması</h5>
      <ul class="list-unstyled text-small">
        <a href='https://play.google.com/store/apps/details?id=com.bildik.linuxdersleri&pcampaignid=pcampaignidMKT-Other-global-all-co-prtnr-py-PartBadge-Mar2515-1'><img style="width: 75%;" alt='Google Play'den alın' src='https://play.google.com/intl/en_us/badges/static/images/badges/tr_badge_web_generic.png'/></a>
	  </ul>
	  
    </div>
  </div>
</footer>


<script src="https://superua1.github.io//assets/js/jquery-3.3.1.slim.min.js"></script>
<script src="https://superua1.github.io//assets/js/script.js"></script>		
<script src="https://superua1.github.io//assets/js/bootstrap.min.js"></script>

<script>
    // Twitter share button functionality
    var twitterShareButton = document.getElementById("twitterShareButton");
        twitterShareButton.addEventListener("click", function() {
          var tweetText = " #Linux Dersleri platformundaki \"Kabuk Nasıl Çalışır ?\" içeriğini faydalı bulduğum için paylaşmak istedim. https://superua1.github.io//egitim/kabuk-nasil-calisir/";
          var tweetUrl = "https://twitter.com/intent/tweet?text=" + encodeURIComponent(tweetText);
          window.open(tweetUrl, "_blank");
        });
  
        // LinkedIn share button functionality
        var linkedinShareButton = document.getElementById("linkedinShareButton");
        linkedinShareButton.addEventListener("click", function() {
          var postUrl = "https://www.linkedin.com/sharing/share-offsite/?mini=true&url=https://superua1.github.io//egitim/kabuk-nasil-calisir/&title=Kabuk Nasıl Çalışır ?&summary=\"Kabuk Nasıl Çalışır ?\" içeriğini faydalı bulduğum için paylaşmak istedim.";
          window.open(postUrl, "_blank");
        });
        </script>
<script src="https://superua1.github.io//assets/js/read.js"></script>
<script src="https://superua1.github.io//assets/js/zooming.min.js"></script>
<script>
   // Listen to images after DOM content is fully loaded
   document.addEventListener('DOMContentLoaded', function () {
        new Zooming({
          // options...
        }).listen('.img-zoomable')
      })
</script>
</body>

</html>
