<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="utf-8">
<link rel="icon" href="/logo.svg" type="image/svg+xml" />
<title>Linux Dersleri | Kopyalama Taşıma Silme &#8211; Linux Eğitimi</title>
<meta name="description" content="Komut satırında kopyalama, taşıma silme gibi işlemleri ele alıyoruz.">
<meta name="keywords" content="cp, mv, rm, shred, inode, sembolik link, katı link">








<link rel="canonical" href="http://localhost:4000/egitim/kopyalama-ta%C5%9F%C4%B1ma-silme-i%C5%9Flemleri/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Linux Eğitimi Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/font-awesome.min.css">
<link rel="stylesheet" href="http://localhost:4000/assets/css/bootstrap.min.css">
<link rel="stylesheet" href="http://localhost:4000/assets/css/style.css">


<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.png">

<link rel="stylesheet" href="http://localhost:4000/assets/css/read.css">
<style>
 .grid {
        column-count: 2;
        column-gap: 1rem;
      }

  </style>
</head>
<body>

<div class="bs-canvas-overlay bs-canvas-anim bg-dark position-fixed w-100 h-100"></div>
<nav class="navbar x-navbar sticky-top navbar-expand-lg navbar-light bg-light border-bottom">
	
  <div class="collapse navbar-collapse">
    <a class="navbar-brand active" href="http://localhost:4000/">
      <img src="http://localhost:4000/logo.svg" width="30" height="30" class="align-top" alt="">
      Linux Dersleri
    </a>
    <ul class="navbar-nav">
      <li class="nav-item active">
        <a class="nav-link" href="http://localhost:4000/egitim.html">Eğitimler</a>
      </li>
      <li class="nav-item active">
        <a class="nav-link" href="http://localhost:4000/blog/">Blog</a>
      </li>
	  <li class="nav-item active">
        <a class="nav-link" href="http://localhost:4000/komutlar">Komut Listesi</a>
      </li>
	  <li class="nav-item active">
        <a class="nav-link" href="http://localhost:4000/test">Test</a>
      </li>
      <li class="nav-item active">
        <a class="nav-link" href="http://localhost:4000/etiketler">Etiketler</a>
      </li>
	 <li class="nav-item active">
        <a class="nav-link" href="http://localhost:4000/hakkında.html">Hakkında</a>
      </li>
    </ul>
	
  </div>
 
<a class="btn" data-toggle="modal" data-target="#searchModal"><i class="fa fa-search" style="width:16px;height:16px"></i></a>
	<a onclick="tema()" class="btn" ><i class="fa fa-adjust fa-lg"></i></a> 
	<a href="http://localhost:4000/bildirim.html" class="btn" ><i class="fa fa-paper-plane"></i></a> 
</nav>	
<nav class="navbar y-navbar sticky-top navbar-expand-lg navbar-light bg-light border-bottom">
<button class="btn"  data-toggle="canvas" data-target="#bs-canvas-left" aria-expanded="false" aria-controls="bs-canvas-left"><i class="fa fa-align-justify fa-lg"></i></button>
		<a href="http://localhost:4000/" class="btn"  ><i class="fa fa-home fa-lg"></i></a>     
	<a class="btn" data-toggle="modal" data-target="#searchModal"><i class="fa fa-search" style="width:16px;height:16px"></i></a>
		
		<a onclick="tema()" class="btn" ><i class="fa fa-adjust fa-lg"></i></a> 
		<a href="http://localhost:4000/bildirim.html" class="btn" ><i class="fa fa-paper-plane"></i></a> 
		
</nav>

<div style="background-color: var(--background);" id="bs-canvas-left" class="bs-canvas bs-canvas-anim bs-canvas-left position-fixed h-100" >
   <div class="container">
    
      <a class="btn bs-canvas-close close" aria-label="Close">
        <span aria-hidden="true">&times;</span>
      </a>
      <a class="navbar-brand" href="http://localhost:4000/">
        <img src="http://localhost:4000/logo.svg" width="30" height="30" class="align-top" alt="">
        Linux Dersleri
      </a>
  
    
    
   <hr>
 <a data-toggle="modal" data-target="#searchModal" class="btn">🕵️ Arama</a>
  <a href="http://localhost:4000/egitim" class="btn">🎓 Eğitimler</a>
  <a href="http://localhost:4000/blog" class="btn">🗃️ Blog</a>
  <a href="http://localhost:4000/komutlar" class="btn">📜 Komut Listesi</a>
  <a href="http://localhost:4000/test" class="btn">🎯 Test</a>
  <a href="http://localhost:4000/etiketler" class="btn">🏷️ Etiketler</a>
  <a href="http://localhost:4000/hakkında.html" class="btn">🐧 Hakkında</a>
 
  <a href="http://localhost:4000/bildirim.html" class="btn">📮 Geri Bildirim</a>
  <hr>
  
  <div align="center">
  <h5>Android Uygulaması</h5>
      <ul class="list-unstyled text-small">
        <a href="https://play.google.com/store/apps/details?id=com.bildik.linuxdersleri&amp;pcampaignid=pcampaignidMKT-Other-global-all-co-prtnr-py-PartBadge-Mar2515-1"><img style="width: 75%;" alt="Google Play" den="" alın'="" src="https://play.google.com/intl/en_us/badges/static/images/badges/tr_badge_web_generic.png"></a>
	  </ul>
	  <hr>
 <h5><a href="/">Linux Dersleri</a> | <a target="_blank" href="https://github.com/Linux-Dersleri/linux-dersleri.github.io"><i class="fa fa-github fa-lg"></i></a></h5>
 <p class="small">GNU/Linux için Türkçe içerik sağlamak üzere kurulmuş bir platformdur.</p>

	  </div>
    
</div>

</div>



<!-- Modal -->
<div class="modal fade" id="searchModal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
  <div class="modal-dialog" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="searchModalLabel">🕵️ Site Geneli Arama:</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <link href="http://localhost:4000/pagefind/pagefind-ui.css" rel="stylesheet">
<script src="http://localhost:4000/pagefind/pagefind-ui.js" type="text/javascript"></script>

<div id="search"></div>
<script>

    window.addEventListener('DOMContentLoaded', (event) => {
        new PagefindUI({ element: "#search", showImages: false });
		
    });
	
</script>
      </div>

    </div>
  </div>
</div>

<script src="http://localhost:4000/assets/js/jquery-3.3.1.slim.min.js" type="text/javascript"></script>
<div id="progress-bar-container">
  <div id="progress-bar"></div>
</div>
      <div class="container-fluid">
  <div class="row mb-2">
      <div style="font-size: 18px;" class="col-md-9" data-pagefind-filter="Bölüm:Eğitim Serisi:">
        	<h1 align="center">11. Ders: Kopyalama Taşıma Silme</h1> 
<div align="center"><i class="fa fa-tags" aria-hidden="true"></i>
          <a href="http://localhost:4000/etiketler.html#cp" class="btn btn-outline-primary btn-sm" title="Pages tagged cp">cp</a> <a href="http://localhost:4000/etiketler.html#mv" class="btn btn-outline-primary btn-sm" title="Pages tagged mv">mv</a> <a href="http://localhost:4000/etiketler.html#rm" class="btn btn-outline-primary btn-sm" title="Pages tagged rm">rm</a> <a href="http://localhost:4000/etiketler.html#shred" class="btn btn-outline-primary btn-sm" title="Pages tagged shred">shred</a> <a href="http://localhost:4000/etiketler.html#inode" class="btn btn-outline-primary btn-sm" title="Pages tagged inode">inode</a> <a href="http://localhost:4000/etiketler.html#sembolik link" class="btn btn-outline-primary btn-sm" title="Pages tagged sembolik link">sembolik link</a> <a href="http://localhost:4000/etiketler.html#katı link" class="btn btn-outline-primary btn-sm" title="Pages tagged katı link">katı link</a>   
		 <p></p> 
		  <div align="center" class="col-sm-3">
		<img class="responsive" src="http://localhost:4000/egitim/metinselvericover.png" alt="">
		  </div>	</div>	  

		  <hr>	
		  <h6 align="right" id="meta-da">
			<i class="fa fa-clock-o" aria-hidden="true"></i>

47 dk.


		   

  <i class="fa fa-user" aria-hidden="true"></i><a href="http://localhost:4000/hakkında.html"> Taylan Özgür Bildik</a>


		  
		  </h6>  
		  
		  
        <p>Şimdiye kadar dosya oluşturma ve düzenlemeye dair pek çok araçtan söz etmiş olduk. Anlatımın devamında dosyalarla ilgili birkaç ayrıntıdan daha bahsediyor olacağız. Fakat diğer ayrıntılardan bahsetmeden önce belki de en temel işlevler olan kopyalama taşıma ve silme işlevlerini yerine getirebileceğimiz araçlarından bahsetmeden istiyorum.</p>

<h1 id="cp-komutu">cp Komutu</h1>

<p>Komut satırı üzerinden dosya veya dizinleri kopyalamak istediğimizde “<strong>c</strong>o<strong>p</strong>y” ifadesinin kısaltmasından gelen <code class="language-plaintext highlighter-rouge">cp</code> aracını kullanabiliyoruz.</p>

<p>Ben denemek için öncelikle “orijinal” isminde bir dosya oluşturup, içerisine “ben dosyayım” yazıp kaydediyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"ben dosyayım"</span> <span class="o">&gt;</span> orijinal

└─<span class="nv">$ </span><span class="nb">cat </span>orijinal 
ben dosyayım
</code></pre></div></div>

<p>Bakın dosyam sorunsuzca kaydedildi.</p>

<h2 id="dosya-i̇smini-değiştirmek">Dosya İsmini Değiştirmek</h2>

<p>Eğer bu dosyayı bulunduğum dizine farklı bir isimle kopyalamak istersem <code class="language-plaintext highlighter-rouge">cp orijinal dosya dosyanın_kopyası</code> şeklinde komut girebilirim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">cp </span>orijinal kopya

└─<span class="nv">$ </span><span class="nb">ls
</span>kopya  orijinal

└─<span class="nv">$ </span><span class="nb">paste </span>orijinal kopya 
ben dosyayım    ben dosyayım
</code></pre></div></div>

<p>Bakın orijinal dosya ile kopyalamış olduğum dosyanın içeriği birebir aynı. Tek fark kopyalanırken oluşturulan dosya isminin benim istediğim şekilde olması. <code class="language-plaintext highlighter-rouge">cp</code> komutunun en temel kullanımı bu şekilde.</p>

<p>Eğer mevcut bulunduğumuz dizine değil de istediğimiz farklı bir dizine dosya veya dizin kopyalamak istersek tek yapmamız gereken kopyanın tam olarak hangi dizine hangi isimle kaydolacağını belirtmek. Ben orijinal dosyasını, kendi ev dizinimdeki <strong><em>Documents</em></strong> klasörünün altına aynı isimde kopyalamak istiyorum. Bunun için <code class="language-plaintext highlighter-rouge">cp orijinal ~/Documents</code> şeklinde yazıyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">cp </span>orijinal ~/Documents/

└─<span class="nv">$ </span><span class="nb">ls</span> ~/Documents/                                              
belgeler  bulbeni  metinler  metin.txt  orijinal
</code></pre></div></div>

<p>Bakın burada ilk olarak orijinal dosyanın yani kopyalanacak dosyanın ismini girip, daha sonra kopyanın tam olarak nereye kaydolması gerektiğini belirtebiliyoruz. Burada klasör isminden sonra özellikle bir dosya ismi belirtmediğim için orijinal dosyanın ismi de birebir kopyalanıp bu dizine kaydoldu.</p>

<p>Eğer dosyayı farklı bir isimle kopyalamak isteseydim, dizin adresinden sonra dosyanın ismini belirtebilirdim. Örneğin <code class="language-plaintext highlighter-rouge">cp orijinal ~/Documents/kopya</code> şeklinde komut girebilirim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">cp </span>orijinal ~/Documents/kopya                                

└─<span class="nv">$ </span><span class="nb">ls</span> ~/Documents/                                              
belgeler  bulbeni  kopya  metinler  metin.txt  orijinal
</code></pre></div></div>

<p>Bakın istediğim dizine tam olarak istediğim isimde dosyamı sorunsuzca kopyalayabildim.</p>

<p>Tabii ki ben yalnızca mevcut bulunduğum dizindeki bir dosyayı başka bir dizine kopyalamak üzere örnekler gösterdim ama yetkiniz olduğu sürece istediğiniz dizindeki dosyayı istediğiniz başka bir konuma kopyalayabilirsiniz. Örneğin ben <code class="language-plaintext highlighter-rouge">cp ~/Documents/orijinal /tmp/</code> komutu ile <strong><em>Documents</em></strong> dizini altındaki “<strong><em>orijinal</em></strong>” isimli dosyayı <strong><em>/tmp</em></strong> dizini altında kopyalayabilirim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">cp</span> ~/Documents/orijinal /tmp/                                

└─<span class="nv">$ </span><span class="nb">cat</span> /tmp/orijinal                                            
ben dosyayım
</code></pre></div></div>

<p>Bakın dosyam sorunsuzca kopyalanmış.</p>

<p>Şimdiye kadar tek bir dosayı kopyalamayı ele aldım ama aslında birden fazla dosyayı da aynı anda kopyalayabiliriz. Örnek olması için öncelikle <code class="language-plaintext highlighter-rouge">touch a b c d</code> komutu ile <strong><em>a b c</em></strong> ve <strong><em>d</em></strong> isimli dosyalar oluşturup bu dosyalarımı tek seferde <strong><em>Document</em></strong> klasörüne kopyalamak istersem komutumu <code class="language-plaintext highlighter-rouge">cp a b c d ~/Documents/</code> şeklinde girmem yeterli.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">touch </span>a b c d

└─<span class="nv">$ </span><span class="nb">cp </span>a b c d ~/Documents/

└─<span class="nv">$ </span><span class="nb">ls</span> ~/Documents/
a  belgeler  c  kopya     metin.txt
b  bulbeni   d  metinler  orijinal
</code></pre></div></div>

<p>Bakın tek seferde birden fazla dosyamızı istediğimiz dizine kopyalamayı başarmışız.</p>

<p>Bu çoklu kopyalama işleminden sonra muhtemelen <code class="language-plaintext highlighter-rouge">cp</code> aracının girdiğimiz argümanlardan hangilerinin kopyalanacak dosyalar, hangisinin dosyaların kopyalanacağı dizin olduğunu nasıl anladığını merak etmiş olabilirsiniz. Aslında çok basit, birden fazla dosya ismi belirtildiği durumda en sondaki argümanın bu dosyaların kopyalanacağı adres olması zorunlu. Yani <code class="language-plaintext highlighter-rouge">cp</code> aracı bu beklenti ile komutumuzu okuyor. Dolayısıyla girdiğimiz komuttaki en son argüman <code class="language-plaintext highlighter-rouge">cp</code> aracı için, bu argümandan önceki tüm dosyaların kopyalanacağı dizini temsil ediyor.</p>

<p>Neticede birden fazla dosyamızı tek seferde başarılı şekilde kopyalamayı başardık. Bu harika fakat bazen kopyalama işlemini kontrollü şekilde gerçekleştirmek de isteyebiliriz. Çünkü özellikle çoklu şekilde dosyaları bir yerden başka bir yere kopyalarken, hedef gösterdiğimiz dizinde bizim kopyaladığımız dosyalar ile aynı isimde dosyalar bulunabiliyor. Eğer özellikle önlem almazsak, kopyalama emri verdiğimiz için kopyaladığımız dosyalar aynı isimli dosyaların üzerine yazılıyor. Yani ilgili dizindeki aynı isimli dosyaların içerikleri tahrip ediliyor. Bu duruma çözüm olarak, üzerine yazılma durumu varsa <code class="language-plaintext highlighter-rouge">cp</code> aracının bizi uyarıp bizden izin istemesini talep edebiliriz. Bunun için <code class="language-plaintext highlighter-rouge">-i</code> seçeneğini kullanmamız yeterli.</p>

<p>Ben aynı isimli dosyayı <code class="language-plaintext highlighter-rouge">cp</code> komutu ile ilgiliniz dizine taşıyacak olursak, herhangi bir uyarı vermeden yeni taşınan dosya eskisinin üzerine yazılacak. Yani eski dosyadaki veriler silinecek.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">cat </span>yeni/dosya 
bu bir dosya

└─<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"bu yeni"</span> <span class="o">&gt;</span> dosya                                       

└─<span class="nv">$ </span><span class="nb">cp </span>dosya yeni/

└─<span class="nv">$ </span><span class="nb">cat </span>yeni/dosya 
bu yeni
</code></pre></div></div>

<p>Bakın herhangi bir uyarı olmadan eski dosya silindi. Eğer biz üzerine yazma konusunda uyarılmak yani kontrollü şekilde kopyalamak yapmak istiyorsak <code class="language-plaintext highlighter-rouge">i</code> seçeneğini kullanabiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"bu son"</span> <span class="o">&gt;</span> dosya

└─<span class="nv">$ </span><span class="nb">cp</span> <span class="nt">-i</span> dosya yeni/                                            
<span class="nb">cp</span>: overwrite <span class="s1">'yeni/dosya'</span>? y
</code></pre></div></div>

<p>Aynı isimli dosya mevcut olduğu için kopyalamadan önce üzerine yazma için “<strong>y</strong>” yani “yes” ile onay alındı. Eğer üzerine yazmak istemeseydim “<strong>n</strong>” yani “no” ile reddedebilirdim.</p>

<h2 id="klasörleri-kopyalamak">Klasörleri Kopyalamak</h2>

<p>Şimdiye kadar hep dosyalar üzerinde çalıştık ancak dilersek dizinleri de kopyalayabiliyoruz. Fakat dizinler kendi içlerinde alt dizinler ve dosyalar barındırabileceği için bir dizini kopyalarken alt dizinlerin de kopyalanması için “recursive” yani “özyinelemeli” kopyalama seçeneğini de komutumuzu eklememiz gerekiyor. Buradaki “özyineleme” ifadesi, dizin altındaki tüm alt dizinlere teker teker bakıp, tüm dosya ve klasörlerin otomatik olarak seçilip kopyalanabilmesini sağlıyor. Zaten Linux üzerinde dizinlerle çalışırken içi dolu olan dizinler üzerinde işlem yapmak için istisnalar hariç hep “recursive” yani “özyineleme” seçeneğini özellikle aktifleştirmemiz gerekiyor. Şimdiye kadar bu durumu zaten bizzat tekrar tekrar deneyimledik. Şimdi tekrar <code class="language-plaintext highlighter-rouge">cp</code> aracına dönecek olursak, öncelikle herhangi bir seçenek belirtmeden bir dizini kopyalamayı deneyebiliriz.</p>

<p>Ben denemek için kendi ev dizinimdeki “<strong><em>yeni</em></strong>” isimli klasörü “<strong><em>Documents</em></strong>” dizini altına taşımak üzere <code class="language-plaintext highlighter-rouge">cp ~/yeni/ ~/Documents/</code> şeklinde komutumu giriyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">cp</span> ~/yeni/ ~/Documents/
<span class="nb">cp</span>: <span class="nt">-r</span> not specified<span class="p">;</span> omitting directory <span class="s1">'/home/taylan/yeni/
</span></code></pre></div></div>

<p>Bakın komut hata verdi ve hata çıktısında <code class="language-plaintext highlighter-rouge">-r</code> seçeneğini kullanmadığım için dizinin kopyalanamadığı belirtilmiş. Şimdi aynı komutumuzu çağırıp bu kez <code class="language-plaintext highlighter-rouge">-r</code> seçeneğini de ekleyip tekrar deneyelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">cp</span> <span class="nt">-r</span> yeni/ Documents/

└─<span class="nv">$ </span><span class="nb">ls</span> ~/Documents/
a  belgeler  c  kopya     metin.txt  yeni
b  bulbeni   d  metinler  orijinal
</code></pre></div></div>

<p>Bu kez herhangi bir hata almadık ve <code class="language-plaintext highlighter-rouge">ls</code> komutu ile de bu dizin taşınmış olduğunuz bizzat teyit etmiş olduk.</p>

<p>Ben yalnızca en sık kullanacağımız yöntemleri ele aldım ancak <code class="language-plaintext highlighter-rouge">cp —help</code> komutu ile bizzat görebileceğiniz gibi <code class="language-plaintext highlighter-rouge">cp</code> aracının pek çok ek seçeneği mevcut. İhtiyaç duymanız halinde bu özelliklere göz atıp kullanabilirsiniz.</p>

<h1 id="mv-komutu">mv Komutu</h1>

<p>Dosya veya dizinleri kopyalamak yerine taşımak yani yerini değiştirmek istediğimizde İngilizce “<strong>m</strong>o<strong>v</strong>e” yani “taşıma” ifadesinin kısaltmasından gelen <code class="language-plaintext highlighter-rouge">mv</code> aracını kullanabiliyoruz. <code class="language-plaintext highlighter-rouge">mv</code> aracının kullanımı da tıpkı <code class="language-plaintext highlighter-rouge">cp</code> aracı gibi oldukça kolay. Zaten her iki aracın da hemen hemen pek çok seçeneği ortak kısaltmalar ile tanımlandığı için rahatlıkla kullanabiliyoruz. Gelin örnekler üzerinden temel kullanımını ele alalım.</p>

<p>Taşımak istediğimiz dosyayı <code class="language-plaintext highlighter-rouge">mv dosya_adı tanışanacağı_yeni_konum</code> şeklinde belirtmemiz yeterli oluyor. Ben örnek olarak mevcut bulunduğum dizindeki “dosya” isimli dosyayı Documents dizini altında taşımak üzere mv dosya Documents şeklinde komutumu giriyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">mv </span>dosya Documents/

└─<span class="nv">$ </span><span class="nb">ls </span>Documents/                                                
a  belgeler  c  dosya  metinler   orijinal
b  bulbeni   d  kopya  metin.txt
</code></pre></div></div>

<p>Gördüğünüz gibi ilgili dosya taşınmış oldu. Benzer şekilde klasör de taşıyabiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">mv </span>klasor/ Documents/                                        

└─<span class="nv">$ </span><span class="nb">ls </span>Documents/                                                
a  belgeler  c  dosya   kopya     metin.txt
b  bulbeni   d  klasor  metinler  orijinal
</code></pre></div></div>

<p>Benzer şekilde istersek aynı anda birden fazla klasörü veya dosyayı da taşıyabiliriz. Ben denemek için genişletme karakterinin de yardımıyla “dosya” “kopya” ve “klasör” için komutumu giriyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">mv </span>Documents/<span class="o">{</span>dosya,kopya,klasor<span class="o">}</span> Pictures/                

└─<span class="nv">$ </span><span class="nb">ls </span>Pictures/                                                 
 bulbeni
 dosya
 klasor
 kopya
</code></pre></div></div>

<p>Gördüğünüz gibi aynı anda birden fazla dosya ve klasörü taşımamız da mümkün. Ben örnek sırasında kolaylık olsun diye köşeli parantez genişletmesini kullandım fakat çoklu taşıma için elbette genişletme kullanmak zorunda değilsiniz. Taşınması gerekenlerin dizinlerini ve isimlerini eksiksiz şekilde belirtmeniz yeterli.</p>

<p>Ben örnekler sırasında dosya veya klasörlerin isimlerini değiştirmek istemediğim için yalnızca taşınacakları adresleri belirttim. Bunun yerine taşındıkları konumda hangi isimle kaydedilmeleri gerektiğini de spesifik olarak belirtebiliyoruz aslında. Ben örnek olarak “<strong><em>Pictures</em></strong>” dizini altındaki “<strong><em>dosya</em></strong>” isimli dosyayı Desktop konumuna “<strong><em>yepyeni-dosya</em></strong>” ismiyle taşımak istiyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">mv </span>Pictures/dosya Desktop/yepyeni-dosya                      

└─<span class="nv">$ </span><span class="nb">ls </span>Desktop/
test.txt  yeni-dizin  yepyeni-dosya
</code></pre></div></div>

<p>Gördüğünüz gibi taşınacağı konumun ardından isim belirttiğimizde taşıma ile birlikte isim değişikliğini de gerçekleştirmiş oluyoruz. Bu yaklaşım herhangi bir dosya ve klasörün ismini değiştirmek için kullanılan temel yaklaşımdır. Yani örneğin ben mevcut bulunduğum dizindeki klasörün yalnızca ismini değiştirmek için kullanabilirim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">ls </span>Pictures/
 bulbeni
 klasor
 kopya
<span class="s1">'Yeni Klasor'</span>

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">mv </span>Pictures/klasor/ Pictures/yeni-isim

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">ls </span>Pictures/                                                 
 bulbeni
 kopya
 yeni-isim
<span class="s1">'Yeni Klasor'</span>
</code></pre></div></div>

<p>Gördüğünüz gibi ilgili klasörün dizin adresini değiştirmeden yalnızca ismini değiştirmiş olduk. İsim değiştirebilme özelliği süper ama isim değiştirmek için <code class="language-plaintext highlighter-rouge">mv</code> komutunu kullanırken, <strong>o dizinde daha önceden yeni tanımladığınız isimde bir klasör olmamasına mutlaka dikkat edin</strong>. Aksi halde <code class="language-plaintext highlighter-rouge">mv</code> komutu isim değiştirmek yerine, o isimdeki klasörün içerisine taşır.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
└─<span class="nv">$ </span><span class="nb">mv </span>Pictures/yeni-isim/ Pictures/Yeni<span class="se">\ </span>Klasor

└─<span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-R</span> Pictures/                 
Pictures/:
 bulbeni
 kopya
<span class="s1">'Yeni Klasor'</span>

Pictures/bulbeni:

<span class="s1">'Pictures/Yeni Klasor'</span>:
yeni-isim

<span class="s1">'Pictures/Yeni Klasor/yeni-isim'</span>:
deneme.txt  dosya1  dosya2  dosys3  liste  liste2  oku-beni
</code></pre></div></div>

<p>Gördüğünüz gibi ben klasör ismini daha önce var olan “<strong><em>Yeni Klasor</em></strong>” olarak değiştirmek üzere <code class="language-plaintext highlighter-rouge">mv</code> komutunu kullandığımda, <code class="language-plaintext highlighter-rouge">mv</code> aracı isim değişikliğinden ziyade bu klasörün hedef dizin adresi olduğunu düşündüğü için bu dizin altında taşıma yapıyor. Zaten bu durumu tahmin etmek zor değil ancak, yine de dikkat etmeniz için özellikle vurgulamak istedim.</p>

<p>Ayrıca olası veri kayıplarını önlemek adına daha önce <code class="language-plaintext highlighter-rouge">cp</code> aracını ele alırken de bahsetmiş olduğum üzerine yazma durumlarından da kısaca bahsetmek istiyorum. Örneğin çoklu şekilde dosya veya klasörleri taşıyorsak daha önce <code class="language-plaintext highlighter-rouge">cp</code> komutunda olduğu gibi her adımda bizden onay alınmasını talep edebiliriz.</p>

<p>Örneğin benim bulunduğum dizinde a b c d isimli dosyalar var. Ayrıca yeni isimli klasör içinde de aynı isimli dosyalar mevcut. Eğer ben mevcut bulunduğum dizindeki dosyaları yeni klasörüne taşırsam, dosyalar bu klasörün içindekilerin üzerine yazılıyor olacak.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">ls </span>yeni/                                                     
a  b  c  d  dosya  kopya  orijinal

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">mv </span>a b c d yeni

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">ls </span>yeni/                                              
a  b  c  d  dosya  kopya  orijinal
</code></pre></div></div>

<p>Gördüğünüz gibi herhangi bir uyarı almadan taşıma işlemi gerçekleştirildi. Ben taşıma işlemi sırasında onay alınması için <code class="language-plaintext highlighter-rouge">-i</code> seçeneğini kullanmak istiyorum. Bunun için yine aynı isimli dosyalar oluşturup bunları kontrollü şekilde taşımayı deneyelim. Hatta benzersiz dosyaları da dahil edelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">touch </span>a b c d                                      

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">mv</span> <span class="nt">-i</span> a b c d dosya1 dosya2 yeni/                                   
<span class="nb">mv</span>: overwrite <span class="s1">'yeni/a'</span>? y
<span class="nb">mv</span>: overwrite <span class="s1">'yeni/b'</span>? y
<span class="nb">mv</span>: overwrite <span class="s1">'yeni/c'</span>? n
<span class="nb">mv</span>: overwrite <span class="s1">'yeni/d'</span>? n

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">ls </span>yeni/
a  b  c  d  dosya  dosya1  dosya2  kopya  orijinal
</code></pre></div></div>

<p>Gördüğünüz gibi yalnızca aynı isimli dosyaların taşınması için onay istendi. Benim “y” ile onayladıklarım taşınırken, “n” ile reddettiklerim taşınmadı. Ayrıca benzersiz olan dosyalar da herhangi bir soru sorulmadan taşınmış oldu. Bu yaklaşım sayesinde üzerine yazma tehlikesi olmadan, çoklu şekilde dosya taşımamız mümkün oluyor.</p>

<p>Denemek için “<strong><em>Documents”</em></strong> dizini altındaki “<strong><em>a” “b” “c” “d”</em></strong> ve “<strong><em>bulbeni”</em></strong> isimli dosyaları “<strong><em>yeni/”</em></strong> dizinine taşıyabiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">ls </span>Documents/
a  b  belgeler  bulbeni  c  d  metinler  metin.txt  orijinal

└─<span class="nv">$ </span><span class="nb">mv</span> <span class="nt">-n</span> Documents/[a-d] Documents/bulbeni yeni/

└─<span class="nv">$ </span><span class="nb">ls </span>Documents/                                                                                                
a  b  belgeler  c  d  metinler  metin.txt  orijinal

└─<span class="nv">$ </span><span class="nb">ls </span>yeni/                                                                                                     
a  b  bulbeni  c  d  dosya  dosya1  dosya2  kopya  orijinal
</code></pre></div></div>

<p>Gördüğünüz gibi “<strong><em>a” “b” “c” “d”</em></strong> dosyaları ile aynı isimli dosyalar “<strong><em>yeni/”</em></strong> klasöründe bulunduğu için bunlar taşınmazken, “<strong><em>bulbeni</em></strong>” isimli dosya taşınmış olduk. Örnek üzerinden bizzat teyit ettiğimiz gibi siz de üzerine yazmaya karşı otomatik olarak korumak isterseniz <code class="language-plaintext highlighter-rouge">-n</code> seçeneğini kullanabilirsiniz.</p>

<p><code class="language-plaintext highlighter-rouge">mv</code> komutu hakkında temelde bilmemiz gerekenler bunlar. Kendi kendinize biraz daha kurcalarsanız ne kadar kolay kullanılabilir olduğunu bizzat deneyimleyebilirsiniz. Ben kendimi tekrar etmek istemediğim için çok fazla örnek vermedim ama siz kendi kendinize hem dosya hem de dizinleri taşıyarak alıştırmalar yapıp <code class="language-plaintext highlighter-rouge">mv</code> aracının kullanımını iyi biçimde kavrayın. Ayrıca her zaman olduğu gibi elbette daha fazlası için <code class="language-plaintext highlighter-rouge">mv —help</code> komutu ile diğer seçenekleri ve özellikleri görüntüleyebilirsiniz.</p>

<h1 id="rm-komutu">rm Komutu</h1>

<p>Kopyalama ve taşıma araçlarından ve bunların temel kullanımlarından bahsettik. Şimdi bir diğer temel işlev olan silme işlevinden de bahsetmek istiyorum. Daha önce de çok kısaca bahsettiğimiz gibi mevcut dosya ve klasörleri komut satırı üzerinden silmek istediğimizde <code class="language-plaintext highlighter-rouge">rm</code> aracını kullanabiliyoruz. <code class="language-plaintext highlighter-rouge">rm</code> aracının ismi İngilizce “<strong>r</strong>e<strong>m</strong>ove” yani “silme/kaldırma” ifadesinin kısaltmasından geliyor. Tıpkı <code class="language-plaintext highlighter-rouge">cp</code> ve <code class="language-plaintext highlighter-rouge">mv</code> aracında olduğu gibi <code class="language-plaintext highlighter-rouge">rm</code> aracının kullanımı da son derece kolay.</p>

<p>İstersek tek bir dosyayı istersek de aynı anda birden fazla dosyayı silmek için tek yapmamız gereken, silmek istediğimiz dosyaların isimlerini <code class="language-plaintext highlighter-rouge">rm</code> komutundan sonra yazmak. Ben bulunduğum dizindeki “a” isimli dosyayı silmek istiyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">ls                                                           
</span>a  b  bulbeni  c  d  dosya  dosya1  dosya2  kopya  orijinal

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/yeni]
└─<span class="nv">$ </span><span class="nb">rm </span>a

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/yeni]
└─<span class="nv">$ </span><span class="nb">ls                                                           
</span>b  bulbeni  c  d  dosya  dosya1  dosya2  kopya  orijinal
</code></pre></div></div>

<p>Bakın “a” isimli dosya artık bulunmuyor.</p>

<p>Eğer birden fazla dosyayı silmek istersem isimlerin peş peşe yazmam yeterli.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">ls                                                           
</span>b  bulbeni  c  d  dosya  dosya1  dosya2  kopya  orijinal

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/yeni]
└─<span class="nv">$ </span><span class="nb">rm </span>b c d                                                     

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/yeni]
└─<span class="nv">$ </span><span class="nb">ls                                                           
</span>bulbeni  dosya  dosya1  dosya2  kopya  orijinal
</code></pre></div></div>

<p>Gördüğünüz gibi birden fazla dosyayı sorunsuzca silmiş olduk. Ben bulunduğum konumdaki dosyaları sildim. Ancak elbette sistem üzerinde yetkinizin bulunduğu tüm dosyaları tam dizin adreslerini belirterek silebilirsiniz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">ls</span> ~/Documents/
a  b  belgeler  c  d  metinler  metin.txt  orijinal

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/yeni]
└─<span class="nv">$ </span><span class="nb">rm</span> ~/Documents/orijinal 

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/yeni]
└─<span class="nv">$ </span><span class="nb">ls</span> ~/Documents/                                     
a  b  belgeler  c  d  metinler  metin.txt
</code></pre></div></div>

<p><strong><em>Documents</em></strong> klasörü altındaki “<strong><em>orijinal</em></strong>” isimli dosyayı sorunsuzca silmiş oldum.</p>

<p>İşte dosyaları tekil veya çoklu şekilde silmek bu kadar kolay. Tek yapmanız gereken silmek istediğiniz dosyanın tam olarak konumunu belirtmek.</p>

<p>Ayrıca ben üzerinde özellikle durmadım ama fark ettiyseniz toplu şekilde dosya silerken bizden ekstra bir onay alınmadan tek seferde tüm dosyalar silinmişti. Bu durum kimi zaman istenmeyen sonuçlara yol açabilir. Önlem olarak eğer istersek silmeden önce her dosya için bizden onay istenmesini sağlayabiliriz. Bu sayede toplu silme işlemlerinde yanlış dosyaları silme riskinden kaçınabiliriz. Örnek senaryomuzda, bir dizin içinde tüm dosyaları silmek üzere konsola <code class="language-plaintext highlighter-rouge">rm *</code> komutunu girdiğimizi farz edelim. Bu durumda kabuk yıldız işareti sayesinde bulunduğumuz dizindeki tüm dosyaları kapsayacağı için tüm dosyaların silinmesi emrini vermiş oluyoruz.</p>

<p>Örneğin ben şu an içinde bulunduğum “<strong><em>yeni</em></strong>” klasörü içerisindeki yer şeyi silmek üzere <code class="language-plaintext highlighter-rouge">rm *</code> komutunu girebilirim. Fakat ben tüm dosyaları silmek istemiyorum, bazılarını eleyip geri kalanları silmek istiyorum. Bunun için <code class="language-plaintext highlighter-rouge">cp</code> ve <code class="language-plaintext highlighter-rouge">mv</code> komutlarında da olduğu gibi <code class="language-plaintext highlighter-rouge">-i</code> seçeneğini kullanabiliriz. Denemek için komutumuza <code class="language-plaintext highlighter-rouge">-i</code> seçeneğini de ekleyip bu şekilde girelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">ls                                                           
</span>bulbeni  dosya  dosya1  dosya2  kopya  orijinal

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/yeni]
└─<span class="nv">$ </span><span class="nb">rm</span> <span class="nt">-i</span> <span class="k">*</span>                                                      
<span class="nb">rm</span>: remove regular empty file <span class="s1">'bulbeni'</span>? n
<span class="nb">rm</span>: remove regular file <span class="s1">'dosya'</span>? y
<span class="nb">rm</span>: remove regular empty file <span class="s1">'dosya1'</span>? y
<span class="nb">rm</span>: remove regular empty file <span class="s1">'dosya2'</span>? y
<span class="nb">rm</span>: remove regular file <span class="s1">'kopya'</span>? y
<span class="nb">rm</span>: remove regular file <span class="s1">'orijinal'</span>? n

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/yeni]
└─<span class="nv">$ </span><span class="nb">ls                                                           
</span>bulbeni  orijinal
</code></pre></div></div>

<p>Gördüğünüz gibi “<strong>y</strong>” ile onay verdiklerim silinirken, “<strong>n</strong>” ile reddettiklerim silinmedi.</p>

<p>Neticede <code class="language-plaintext highlighter-rouge">i</code> seçeneği sayesinde tüm silme işleminin adım adım bizden onay alınarak gerçekleştirilmesini sağlamış olduk.</p>

<p>Tamamdır bence dosyaları silmekle ilgili tüm temel bilgilerden bahsettik. Şimdi klasörleri nasıl silebileceğimizi örnekler üzerinden ele alalım.</p>

<h2 id="klasörlerin-silinmesi">Klasörlerin Silinmesi</h2>

<p>Normalde <code class="language-plaintext highlighter-rouge">rm</code> komutunu ekstra bir seçenek belirtmeden kullandığımızda <code class="language-plaintext highlighter-rouge">rm</code> aracı yalnızca kendisine argüman olarak verilmiş olan dosyaları siliyor. Yani aynı isimle eşleşen klasörleri silmiyor. Klasörleri silmesi için silinmek istenilenin klasör olduğunu İngilizce “<strong>d</strong>irectory” yani “klasör” ifadesinin kısaltmasından gelen <code class="language-plaintext highlighter-rouge">-d</code> seçeneği ile özellikle belirtmemiz gerekiyor.</p>

<p>Hemen deneyelim. Ben test etmek için <code class="language-plaintext highlighter-rouge">mkdir sil-beni</code> komutu ile yeni klasör oluşturup, <code class="language-plaintext highlighter-rouge">rm</code> komutu ile oluşturduğum klasörü silmeyi deniyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/yeni]
└─<span class="nv">$ </span><span class="nb">mkdir </span>sil-beni                                               

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/yeni]
└─<span class="nv">$ </span><span class="nb">rm </span>sil-beni/                                                 
<span class="nb">rm</span>: cannot remove <span class="s1">'sil-beni/'</span>: Is a directory
</code></pre></div></div>

<p>Bakın aldığımız çıktıda, klasör olduğu için silinemediği konusunda uyarıldık. Eğer “directory” yani “klasör” ifadesinin kısaltması olan <code class="language-plaintext highlighter-rouge">d</code> seçeneğini kullanırsak silebileceğiz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/yeni]
└─<span class="nv">$ </span><span class="nb">rm</span> <span class="nt">-d</span> sil-beni/                                              

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/yeni]
└─<span class="nv">$ </span><span class="nb">ls                                                           
</span>bulbeni  orijinal
</code></pre></div></div>

<p>Gördüğünüz gibi <code class="language-plaintext highlighter-rouge">d</code> seçeneği sayesinde klasörüm sorunsuzca silinmiş oldu.</p>

<p>Dosyalara benzer şekilde klasörleri de çoklu şekilde silebiliriz. Ben denemek için <code class="language-plaintext highlighter-rouge">mkdir x y z</code> komutu ile birden fazla klasör oluşturacağım. Ve bunları da <code class="language-plaintext highlighter-rouge">rm -di x y z</code> komutu ile kontrollü şekilde sileceğim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">mkdir </span>x y z

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/yeni]
└─<span class="nv">$ </span><span class="nb">rm</span> <span class="nt">-di</span> x y z
<span class="nb">rm</span>: remove directory <span class="s1">'x'</span>? y
<span class="nb">rm</span>: remove directory <span class="s1">'y'</span>? n
<span class="nb">rm</span>: remove directory <span class="s1">'z'</span>? y

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/yeni]
└─<span class="nv">$ </span><span class="nb">ls                                                           
</span>bulbeni  orijinal  y
</code></pre></div></div>

<p>Gördüğünüz gibi <code class="language-plaintext highlighter-rouge">i</code> seçeneği sayesinde benden onay alınan klasörler silinmiş oldu.</p>

<h2 id="i̇çerisi-dolu-olan-klasörlerin-silinmesi">İçerisi Dolu Olan Klasörlerin Silinmesi</h2>

<p>Şu ana kadar klasörleri silerken hiç bir problem yaşamadık, çünkü klasör içerikleri boştu. Eğer klasörlerin içinde başka dosyalar ve klasörler bulunuyorsa, <code class="language-plaintext highlighter-rouge">rm -d</code> komutu ile silmemiz mümkün değil.</p>

<p>Mesela teyit etmek için daha önceden oluşturduğum <strong><em>Documents</em></strong> dizini altındaki klasörümü silmeyi deneyebilirim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-R</span> ~/Documents/                                           
/home/taylan/Documents/:
a  b  belgeler  c  d  metinler  metin.txt

/home/taylan/Documents/belgeler:

/home/taylan/Documents/metinler:
1.gz  2.gz  3.gz  4.gz  5.gz

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/yeni]
└─<span class="nv">$ </span><span class="nb">rm</span> <span class="nt">-d</span> ~/Documents/metinler                                   
<span class="nb">rm</span>: cannot remove <span class="s1">'/home/taylan/Documents/metinler'</span>: Directory not empty
</code></pre></div></div>

<p>Gördüğünüz gibi “<strong><em>metinler</em></strong>” klasörünün içerisi dolu olduğu için silme işlemi reddedildi.</p>

<p>İçerisi dolu dizinleri silmek için <code class="language-plaintext highlighter-rouge">-r</code> seçeneğini kullanmamız gerekiyor. Buradaki <code class="language-plaintext highlighter-rouge">r</code> seçeneği İngilizce “<strong>r</strong>ecursive” yani “özyinelemeli” ifadesinin kısaltmasından geliyor. Bu seçenek sayesinde klasörün içinde iç içe birden fazla klasör ve dosya olsa da tüm dosyaların ve klasörlerin silinebilmesi mümkün oluyor. Hatırlıyorsanız klasör içeriklerini kopyalarken de bu şekilde “recursive” seçeneğini eklemiştik. En alt dizine kadar bakılıp silmesi de özyineleme özelliğini temsil ediyor yani. Hatta “recurisve” yani “özyineleme” seçeneğini yalnızca klasörler üzerinde kullandığımız için bu seçenek varken aslında <code class="language-plaintext highlighter-rouge">rm</code> aracına ek olarak <code class="language-plaintext highlighter-rouge">-d</code> seçeneğini de girmemiz gerekmiyor. Yani <code class="language-plaintext highlighter-rouge">rm -r silinecek-klasör</code> şeklinde komutumuzu girdiğimizde, belirttiğimiz dizin tüm içeriğiyle birlikte silinecektir.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">rm</span> <span class="nt">-r</span> ~/Documents/metinler/

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/yeni]
└─<span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-R</span> ~/Documents/                                           
/home/taylan/Documents/:
a  b  belgeler  c  d  metin.txt

/home/taylan/Documents/belgeler:
</code></pre></div></div>

<p>Bakın yalnızca <code class="language-plaintext highlighter-rouge">-r</code> seçeneğini kullanarak içi dolu klasörü silmeyi başardım.</p>

<p>Ben kullanmadım ancak özellikle iç içe klasörler ve dosyalar barındıran klasörleri silerken, <code class="language-plaintext highlighter-rouge">i</code> seçeneğini ekleyerek yanlış bir dosyayı veya klasörü silmediğinizden emin olmanızı da önerebilirim. Yine de klasörden tek seferde kurtulmak istediğinize eminseniz elbette <code class="language-plaintext highlighter-rouge">i</code> seçeneğini kullanmak zorunda değilsiniz.</p>

<p>Ayrıca hatırlıyorsanız, boş dizinleri silmek için daha önce <code class="language-plaintext highlighter-rouge">rmdir</code> aracını kullanmıştık. İşte <code class="language-plaintext highlighter-rouge">rm -d</code> komutu <code class="language-plaintext highlighter-rouge">rmdir</code> aracı ile aynı işlevi görüyor. İçerisi dolu olan dizinleri silmek için de <code class="language-plaintext highlighter-rouge">rm -r</code> komutunu kullanıyoruz. Dolayısıyla emin olmadığınız sürece <code class="language-plaintext highlighter-rouge">rm -r</code> komutunu kullanmanız önermem. Yine de elbette klasörü içeriğiyle birlikte silmek istediğinizden eminseniz kullanabilirsiniz.</p>

<p>Son olarak eğer, tüm silme adımlarının ayrıntılarını da takip etmek isterseniz “verbose” yani “ayrıntılı” ifadesinin kısaltması olan <code class="language-plaintext highlighter-rouge">v</code> seçeneğini de kullanabilirsiniz. Toplu şekilde klasör silerek kullanımı teyit edebiliriz. Çabucak test etmek için <code class="language-plaintext highlighter-rouge">mkdir {1..9}</code> komutuyla yeni klasörler oluşturup, toplu şekilde silmek ve silme işlemiyle ilgili ayrıntıları da öğrenmek için <code class="language-plaintext highlighter-rouge">rm -dv {1..9}</code> şeklinde komutumuzu girebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">ls                                                           
</span>1  2  3  4  5  6  7  8  9  bulbeni  orijinal  y

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/yeni]
└─<span class="nv">$ </span><span class="nb">rm</span> <span class="nt">-dv</span> <span class="o">{</span>1..9<span class="o">}</span>                                                
removed directory <span class="s1">'1'</span>
removed directory <span class="s1">'2'</span>
removed directory <span class="s1">'3'</span>
removed directory <span class="s1">'4'</span>
removed directory <span class="s1">'5'</span>
removed directory <span class="s1">'6'</span>
removed directory <span class="s1">'7'</span>
removed directory <span class="s1">'8'</span>
removed directory <span class="s1">'9'</span>
</code></pre></div></div>

<p>Bakın tüm silme işlemi adım adım bastırıldı. Bu şekilde toplu silme işlemlerini takip etmek istiyorsanız <code class="language-plaintext highlighter-rouge">v</code> seçeneğini de kullanabilirsiniz.</p>

<p>Neticede <code class="language-plaintext highlighter-rouge">rm</code> komutu hakkında bilmemiz gereken tüm temel yaklaşımlardan bahsettik. Diğer seçenekleri görmek için yardım sayfasına göz atabilirsiniz.</p>

<h1 id="shred-komutu--dosyaları-geri-döndürülemez-şekilde-silmek">shred Komutu | Dosyaları Geri Döndürülemez Şekilde Silmek</h1>

<p>Geri döndürülemez yani kalıcı silme kavramından bahsetmeden önce silme işlemlerinin temelde nasıl işlediğinden çok kısaca bahsetmek istiyorum. Bu sayede kalıcı silmeden kastın ne olduğu daha net anlaşılabilir.</p>

<p>Eğer herhangi bir dosyayı sildiğinizde o dosyanın tamamen yok olduğunu düşünüyorsanız kesinlikle yanılıyorsunuz. Kısaca özetlemek gerekirse işletim sistemleri dosya silme emri aldığında o dosyayı gerçekten diskten silmek yerine, dosyaya ulaşmanızı sağlayan yolun bilgisini silerler.</p>

<p><img src="http://localhost:4000/egitim/metin/shred-1.png" alt="shred-1.png" class="responsive img-zoomable" /></p>

<p>Yani aslında dosya hala disk üzerinde mevcut olmasına rağmen, sadece dosyaya giden bağlantı siliniyor. Bu yöntemin kullanılma nedeni dosyayı gerçekten silmeye oranla çok daha hızlı sonuç vermesidir. Peki ama gerçek silme işleminden kastımız tam olarak ne ?</p>

<p>Gerçek silme işlemi dediğimiz kavram; disk üzerinde yer kaplayan her türlü verinin ancak üzerine yeni veriler yazılması ile ortadan kaldırılabilecek olmasını ifade ediyor.</p>

<p><img src="http://localhost:4000/egitim/metin/shred-2.png" alt="shred-2.png" class="responsive img-zoomable" /></p>

<p>Çünkü üstüne yeni veri yazılarak tahrip edilmeyen her türlü verinin tekrar kurtarılma ihtimali var. Adli bilişim alanında bu iş için kullanılan pek çok yazılımsal ve harici olarak fiziksel kurtarma yöntemi bulunuyor.</p>

<p>İşin özü eğer bir dosyadan geri döndürülemez şekilde kurtulmak istiyorsak o dosyayı silerken üzerine birden fazla kez rastgele veri yazılmasını sağlamamız gerekiyor. Pek çok işletim sisteminde bu üzerine yazma işlemi için harici yazılımlar yükleyip kullanmamız gerekebiliyor. Ancak söz konusu Linux olduğunda pek çok dağıtımda varsayılan olarak yüklü gelen <code class="language-plaintext highlighter-rouge">shred</code> isimli aracı kullanabilme kolaylığa sahibiz.</p>

<p>Zaten <code class="language-plaintext highlighter-rouge">shred</code> ifadesi Türkçe olarak “parçalamak” anlamına geliyor. Eğer herhangi bir arama motoruna yazarsanız, karşınıza parçalanmış kağıt görselleri çıkacaktır. Bu aracı kullanarak, dosyaların üzerine veriler yazılarak tahrip edilmesini sağlayabiliyoruz. Dosya içeriği tahrip olduktan sonra da dosyayı güvenle sıradan şekilde silebiliyoruz çünkü dosya geri getirilse bile orijinali tahrip edildiği için gerçek içeriğine ulaşılamıyor.</p>

<p>Silme mekanizmalarından bence yeterince bahsettik. Şimdi lafı daha fazla uzatmadan <code class="language-plaintext highlighter-rouge">shred</code> komutunun kullanımından bahsederek devam edelim.</p>

<h2 id="shred-komutu"><code class="language-plaintext highlighter-rouge">shred</code> Komutu</h2>

<p><code class="language-plaintext highlighter-rouge">shred</code> komutunu herhangi bir ek seçenek belirtmeden kullandığımızda varsayılan olarak kendisine argüman olarak verilmiş olan dosyanın üzerine 3 kez rastgele bitler yazılmasını sağlıyor. Eğer daha fazla kez yazılmasını istersek, <code class="language-plaintext highlighter-rouge">-n</code> seçeneğini kullanıp kaç kez yazılması gerektiğini özellikle de belirtebiliyoruz.. Ayrıca <code class="language-plaintext highlighter-rouge">-v</code> seçeneğini ekleyerek “<strong>v</strong>erbose” yani “ayrıntılı” çıktı vermesini de sağlayabiliriz. Bu sayede tüm adımları konsoldan takip edebiliriz.</p>

<p>Ben denemek için <code class="language-plaintext highlighter-rouge">echo “bu bir dosyadır” &gt; okubeni</code> komutu ile içerisi dolu yeni bir dosya oluşturuyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/yeni]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"bu bir dosyadır"</span> <span class="o">&gt;</span> okubeni                             

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/yeni]
└─<span class="nv">$ </span><span class="nb">cat </span>okubeni                                                  
bu bir dosyadır
</code></pre></div></div>

<p>Şimdi <code class="language-plaintext highlighter-rouge">shred</code> aracını kullanarak dosya içeriğine rastgele bitler yazılmasını sağlayabiliriz. Ben varsayılan şekilde yani 3 kez rastgele bitler yazılması için <code class="language-plaintext highlighter-rouge">shred</code> aracına özellikle bir sayı vermek istemiyorum ama işlem adımlarını takip etmek için “verbose” yani ayrıntılı çıktı seçeneğini ekleyeceğim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/yeni]
└─<span class="nv">$ </span><span class="nb">shred</span> <span class="nt">-v</span> okubeni                                             
<span class="nb">shred</span>: okubeni: pass 1/3 <span class="o">(</span>random<span class="o">)</span>...
<span class="nb">shred</span>: okubeni: pass 2/3 <span class="o">(</span>random<span class="o">)</span>...
<span class="nb">shred</span>: okubeni: pass 3/3 <span class="o">(</span>random<span class="o">)</span>...

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/yeni]
└─<span class="nv">$ </span><span class="nb">cat </span>okubeni                                                  
�r��WwQ%���uuD��J󶤈�����X����m�M���h�E<span class="s2">"E�-�F:����ǀi�7▒.&gt;�        d��zO���R�e)a�������F�Z� 䵙x�Z;</span><span class="nv">$s</span><span class="s2">��/��}C���F����u}��o(�K��h���W軄R��XP�KLB�d&gt;�4�7r���c�C�#BD��v�O�I忧�ٱ�-O�/��)%m��
</span></code></pre></div></div>

<p>Gördüğünüz gibi dosyanın içeriği tamamen okunamaz halde. Artık bu dosyayı <code class="language-plaintext highlighter-rouge">rm</code> komutu ile gönül rahatlığıyla silebiliriz çünkü dosya geri getirilse bile içeriğindeki verilere ulaşılması pek olası değil. Çünkü içerisine 3 kez rastgele veriler yazıldı. İşte <code class="language-plaintext highlighter-rouge">shred</code> aracının kullanımı bu kadar kolay.</p>

<p>Ayrıca daha önce de bahsettiğim şekilde istersek kaç kez rastgele veri yazılacağını da <code class="language-plaintext highlighter-rouge">-n</code> seçeneğinin ardından özellikle belirtebiliyoruz. Örneğin ben 5 kez rastgele veri yazılmasını istersem <code class="language-plaintext highlighter-rouge">shred -n 5 dosya-adı</code> şeklinde komutumu girebilirim. Hatta sayıyı belirtmeye ek olarak rastgele yazma işleminden hemen sonra bu dosyanın silinmesini de sağlayabiliriz. Dosyanın silinmesi için de <code class="language-plaintext highlighter-rouge">-u</code> seçeneğini eklememiz yeterli oluyor.</p>

<p>Ben denemek için bu “<strong><em>okubeni</em></strong>” dosyasının üzerine 5 kez rastgele veri yazılıp daha sonra silinmesini için komutumu girmek istiyorum. Tabii tüm işlem adımlarını takip edebilmek için bir de <code class="language-plaintext highlighter-rouge">-v</code> seçeneği ile ayrıntıların da bastırılmasını istiyorum. Bunun için <code class="language-plaintext highlighter-rouge">shred -uvn 5 okubeni</code> şeklinde komutumu giriyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">shred</span> <span class="nt">-uvn</span> 5 okubeni 
<span class="nb">shred</span>: okubeni: pass 1/5 <span class="o">(</span>random<span class="o">)</span>...
<span class="nb">shred</span>: okubeni: pass 2/5 <span class="o">(</span>ffffff<span class="o">)</span>...
<span class="nb">shred</span>: okubeni: pass 3/5 <span class="o">(</span>random<span class="o">)</span>...
<span class="nb">shred</span>: okubeni: pass 4/5 <span class="o">(</span>000000<span class="o">)</span>...
<span class="nb">shred</span>: okubeni: pass 5/5 <span class="o">(</span>random<span class="o">)</span>...
<span class="nb">shred</span>: okubeni: removing
<span class="nb">shred</span>: okubeni: renamed to 0000000
<span class="nb">shred</span>: 0000000: renamed to 000000
<span class="nb">shred</span>: 000000: renamed to 00000
<span class="nb">shred</span>: 00000: renamed to 0000
<span class="nb">shred</span>: 0000: renamed to 000
<span class="nb">shred</span>: 000: renamed to 00
<span class="nb">shred</span>: 00: renamed to 0
<span class="nb">shred</span>: okubeni: removed
</code></pre></div></div>

<p>Bakın öncelikle dosya içeriğine rastgele 5 kez veriler yazılmış, daha sonra dosya silinmiş ve son olarak dosyanın isminin de silinmesi için dosya ismi de adım adım sıfırlar ile doldurularak yok edilmiş. Bu yaklaşım sayesinde dosyanın isminin dahi disk üzerinden kurtarılması pek olası değil.</p>

<p>Hatta teyit etmek için <code class="language-plaintext highlighter-rouge">ls</code> komutu ile mevcut dizinimizi listeleyebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/yeni]
└─<span class="nv">$ </span><span class="nb">ls                                                           
</span>bulbeni  orijinal  y
</code></pre></div></div>

<p>Bakın gördüğünüz gibi dosyamız işlem sonunda otomatik olarak silinmiş.</p>

<p>Ayrıca benim örnekler üzerinde kullandığım dosyanın içeriği çok küçük olduğu için tüm işlem çok kısa sürede tamamlandı ancak bu durum her zaman böyle olmayabilir. Yani üzerine yazma işlemi, üzerine yazılacak olan dosyanın boyutuna göre değişken uzunlukta sürebilir, sabırla işlem tamamlanana kadar beklemelisiniz. Benim dosya boyutum çok küçük olduğu için işlem çok kısa sürede tamamlandı.</p>

<p>Kalıcı olarak istediğiniz dosyalarınızı bu yaklaşım sayesinde güvenli şekilde silebilirsiniz.</p>

<h1 id="linux-geri-dönüşüm-kutusu">Linux Geri Dönüşüm Kutusu</h1>

<p>Komut satırı üzerinden bir dosyayı sildiğimizde, normalde grafiksel arayüzde olduğu gibi sildiğimiz dosya çöp kutusuna gönderilmiyor. Yani çöp kutusu olarak geçen dizin yalnızca grafiksel arayüzdeki dosya silme işlemlerinde kullanılan sembolik bir dosya yolu.</p>

<p>Denemek için grafiksel arayüzdeyken bir dosyanın üzerine tıklayıp silebilir daha sonra geri dönüşüm klasörüne bakabiliriz.</p>

<p><img src="http://localhost:4000/egitim/metin/trash.gif" alt="trash.gif" class="responsive img-zoomable" /></p>

<p>Bakın silmiş olduğumuz dosya burada bulunuyor. Şimdi denemek için <code class="language-plaintext highlighter-rouge">touch deneme</code> komutu ile yeni bir dosya oluşturup bu dosyayı da <code class="language-plaintext highlighter-rouge">rm</code> komutu ile silelim.</p>

<p><img src="http://localhost:4000/egitim/metin/trash-on-commanline.gif" alt="trash-on-commanline.gif" class="responsive img-zoomable" /></p>

<p>Bakın komut satırı üzerinden silme işlemi gerçekleştirdiğimiz için çöp kutusuna herhangi bir dosya eklenmedi. Zaten komut satırı üzerinden sildiğimizde buradaki çöp kutusuna geliyor olsaydı önceki silme işlemlerinin kalıntılarını burada görüyor olmamız gerekiyordu.</p>

<p>Komut satırından silinen dosyaların burada gözükmüyor olmasına ek olarak Windows sisteminden de aşina olduğumuz gibi grafiksel arayüzdeyken, <kbd>Shift</kbd> + <kbd>Delete</kbd> tuşlaması ile bir dosya veya klasörü sildiğimizde bu dosya veya klasör bu çöp dizinine gelmeden komut satırında olduğu şekilde siliniyor.</p>

<p><img src="http://localhost:4000/egitim/metin/shift-delete.gif" alt="shift-delete.gif" class="responsive img-zoomable" /></p>

<p>Tabii ki <kbd>Shift</kbd> + <kbd>Delete</kbd> tuşlaması bizim <code class="language-plaintext highlighter-rouge">shred</code> komutu ile sildiğimiz gibi silmiyor ancak en azından sadece çöp dizinine de taşımış olmuyor.</p>

<p>Komut satırından veya <kbd>Shift</kbd> + <kbd>Delete</kbd> ile grafiksel arayüzden sildiğiniz dosyaları geri getirmek isterseniz de <code class="language-plaintext highlighter-rouge">testdisk</code> gibi harici veri kurtarma yazılımları ile ilgili dosyalarınızı kurtarabilirsiniz. Tabii ki daha önce de belirttiğim şekilde eğer <code class="language-plaintext highlighter-rouge">shred</code> aracı ile dosya içeriklerini tahrip ettiyseniz yani kalıcı olarak sildiyseniz kurtarma yazılımları ile, ilgili dosyaları kurtarmanız pek olası değil.</p>

<p>Artık böylelikle silme ve kurtarma planlarınızı, şimdiye kadar bahsettiğimiz bilgiler aşığında gerçekleştirebilirsiniz.</p>

<h1 id="sembolik-ve-katı-link--soft-link--hard-link">Sembolik ve Katı Link | Soft Link &amp; Hard Link</h1>

<p>Bu derste çok kısaca sembolik ve katı linklerden de bahsetmek istiyorum.</p>

<p>Fakat sembolik ve katı linklerden bahsetmeden önce, link yapısını yani aslında buradaki link ifadesinden kastımızı anlamak için öncelikle “inode” kavramı üzerinde durmamız gerekiyor. Merak etmeyin çok ayrıntıya girmeyeceğiz.</p>

<h2 id="inode">inode</h2>

<p>Dosya sistemindeki veriler depolama birimlerimizde yani diskte bloklar halinde tutuluyorlar. Dosyalarla ilişkili olan verilerin hangi bloklarda olduğunun bilgisini de bizlere “<strong>i</strong>ndex <strong>node</strong>” yani kısaca “<strong>inode</strong>” olarak isimlendirilen yapı haber veriyor.</p>

<p>Örneğin ben <strong><em>metin.txt</em></strong> isimli bir dosyanın içerisine “merhabalar” yazıp kaydettiğimde, “merhabalar“ ifadesi diskte belirli bir bloğa kaydediliyor. Ve bu verinin disk üzerinde tam olarak bulunduğu bloğun veya blokların bilgisi de <strong>inode</strong> olarak isimlendirilen benzersiz sayısal bir değere atanıyor. <strong><em>metin.txt</em></strong> dosyası ise bu <strong>inode</strong> değerine link olarak bağlanıyor. Bu sayede biz <strong><em>metin.txt</em></strong> dosyasının içeriğini okumak istediğimizde aslında arkaplanda <strong><em>metin.txt</em></strong> dosyasının bağlı olduğu <strong>inode</strong> değerine bakılıyor. <strong>inode</strong> değerinin disk üzerinde işaret ettiği bloklardan da bu veriler getiriliyor. Neticede biz metin.txt ismiyle ilişkili olan “merhabalar” verisine disk üzerinde kaydedildiği yerden tekrar ulaşmış oluyoruz.</p>

<p><img src="http://localhost:4000/egitim/metin/inode.png" alt="inode.png" class="responsive img-zoomable" /></p>

<p>Yani aslında buradaki <strong><em>metin.txt</em></strong> dosyası yalnızca benzersiz bir <strong>inode</strong> değerine bağlı olan <strong>linktir</strong>. <strong>inode</strong> değeri de ilgili verinin diskteki yerini bildiği için <strong><em>metin.txt</em></strong> linki üzerinden bu veriye ulaşabiliyoruz.</p>

<p>İşte tıpkı bu örneğimizde olduğu gibi dosya sistemindeki benzersiz olan her bir dosya ve klasörün de benzersiz bir inode değeri bulunuyor. Bizim gördüğümüz dosya ve klasör isimleri de yalnızca bu inode değerlerine yönlendirme yapan linkler aslında. Dosya veya klasör isminden inode değerine, inode değerleri üzerinden de disk üzerinde depolanmış olan verilere kolayca erişebiliyoruz. Buradaki linkler yalnızca biz insanların disk üzerindeki verilere kolay erişebilmesi için okunaklı isimlerden oluşan bağlantı noktaları aslında. Yani diskteki “xx yy zz” bloklarındaki verileri okumak istiyorum demek yerine, “metin.txt” dosyasını okumak istiyorum demek bizim için çok daha kolay olduğu için dosya ve klasör isimleri yalnızca birer linktir.</p>

<p>Tamam temel seviye için inode ve link kavramı hakkında bu kadarlık bilgi yeterli.</p>

<p>Şimdi esas konumuz olan link kavramına odaklanacak olursak, Linux üzerinde <strong>sembolik</strong> ve <strong>katı</strong> olmak üzere iki link çeşidi bulunuyor. Gelin öncelikle sembolik linkten bahsederek başlayalım.</p>

<h2 id="sembolik-link--soft-link">Sembolik Link | Soft Link</h2>

<p>Ben sembolik link diyor olacağım ancak farklı kaynaklarda “<strong>soft link</strong>” olarak ifade edildiğini de görebilirsiniz. Sembolik linkleri Windows sisteminden de alışık olduğumuz sıradan kısayollara benzetebiliriz. Sembolik linklerin görevleri yalnızca orijinal dosya içeriğine yönlendirme yapmaktır.</p>

<p>Daha anlaşılır olması için gerçek bir örnek üzerinden devam edebilmek adına öncelikle nasıl sembolik link oluşturabileceğimizi öğrenelim.</p>

<p>Link oluşturmak için “<strong>l</strong>i<strong>n</strong>k” ifadesinin kısaltmasından gelen <code class="language-plaintext highlighter-rouge">ln</code> komutunu kullanıyoruz. Sembolik link oluşturmak için de “<strong>s</strong>ymbolic” ifadesinin kısalması olan <code class="language-plaintext highlighter-rouge">s</code> seçeneğini kullanmamız gerekiyor.</p>

<p>Ben test ortamı hazırlamak için öncelikle kendi ev dizinimde <code class="language-plaintext highlighter-rouge">mkdir linkler</code> komutuyla “<strong><em>linkler</em></strong>” isimli bir klasör oluşturup, <code class="language-plaintext highlighter-rouge">echo “deneme” &gt; ~/linkler/metin</code> komutuyla, bu dizin altında “<strong><em>metin</em></strong>” isimli dosyaya “deneme” ifadesini ekliyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">mkdir </span>linkler

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"deneme"</span> <span class="o">&gt;</span> ~/linkler/metin

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat</span> ~/linkler/metin                                            
deneme
</code></pre></div></div>

<p>Test ortamımız hazır. Şimdi bu dosyanın sembolik linkini oluşturmayı deneyelim.</p>

<p>Sembolik link oluştururken dosya ve klasörlerin tam dosya dizin adreslerini mutlaka belirtmemiz gerekiyor. Çünkü sembolik dosyaları sistem üzerinde herhangi bir dosya konumunda kullanabiliriz. <strong>Tam dizin adresini belirtmezsek doğru şekilde çalışmaz.</strong> Örneğin ben tam dizin adresi yerine göreceli yolu belirterek yeni bir sembolik link oluşturmak ve bu linki başka bir konuma taşımak istiyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">ln</span> <span class="nt">-s</span> linkler/metin sembolik_metin2

└─<span class="nv">$ </span><span class="nb">mv </span>sembolik_metin2 Documents/                                             

└─<span class="nv">$ </span><span class="nb">cat </span>Documents/sembolik_metin2                                             
<span class="nb">cat</span>: Documents/sembolik_metin2: No such file or directory
</code></pre></div></div>

<p>Gördüğünüz gibi orijinal dosyanın tam dizin adresini belirtmediğim için sembolik link dosyasının konumunu değiştirdiğimde bu dosya göreli yola göre orijinal dosyayı aradığı için bu dosya bulunamadı. <strong>Dolayısıyla link belirtirken tam dizin adresini girmeniz şart!</strong></p>

<p>Ben bu dizindeki dosyanın sembolik linkini mevcut bulunduğum dizinde oluşturmak için <code class="language-plaintext highlighter-rouge">ln -s ~/linkler/metin sembolik_metin</code> şeklinde komutumu giriyorum. Teyit etmek için <code class="language-plaintext highlighter-rouge">ls -l sembolik_metin</code>  komutuyla listeleyelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">ln</span> <span class="nt">-s</span> ~/linkler/metin sembolik_metin

└─<span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-l</span> sembolik_metin 
lrwxrwxrwx 1 taylan taylan 13 Jun 26 04:07 sembolik_metin -&gt; /home/taylan/linkler/metin
</code></pre></div></div>

<p>Bakın burada <strong><em>sembolik_metin</em></strong> dosyasının oluşturulduğunu görebiliyorum. Ayrıca çıktılara dikkatlice bakacak olursanız, ok işaretinin orijinal dosyaya referans verdiğini görebilirsiniz. Buradaki çıktının anlamı “<strong><em>sembolik_metin</em></strong>” isimli dosyanın “<strong><em>metin</em></strong>” dosyasının sembolik bir bağlantısı olduğu. Bunlar dışında çıktıların en solunda yani dosya türünün belirtildiği bölümde “<strong>l</strong>” karakteri bulunuyor. Buradaki “<strong>l</strong>” ifadesi “sembolik link” anlamına geliyor. Dolayısıyla her iki şekilde de başarılı şekilde sembolik linkimizi üretmeyi başardığımızı teyit etmiş olduk.</p>

<p>Hemen sembolik linkin nasıl bir işlevi olduğunu görmek için birkaç basit örnek yapalım. Öncelikle oluşturduğumuz sembolik link üzerinden orijinal dosyanın içeriğini okumayı deneyebiliriz. Ben bunun için <code class="language-plaintext highlighter-rouge">cat sembolik-metin</code> şeklinde komutumu giriyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">cat </span>sembolik_metin 
deneme
</code></pre></div></div>

<p>Bakın konsola “deneme” ifadesi bastırıldı. Yani sembolik link üzerinden orijinal dosyamızın içeriğine ulaşmış olduk.</p>

<p>Şimdi orijinal dosyaya yeni veri ekleyerek bu durumu tekrar test edelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"yeni"</span> <span class="o">&gt;&gt;</span> ~/linkler/metin 

└─<span class="nv">$ </span><span class="nb">cat </span>sembolik_metin 
deneme
yeni
</code></pre></div></div>

<p>Bakın orijinal dosyadaki değişikliğe bu dosya üzerinden de erişebiliyoruz. Neticede sembolik linkler aslında orijinal dosyaların kısayolları görevinde olduğu için tek yaptığı orijinal dosyaya yönlendirme yapmak. Dolayısıyla orijinal dosya içeriğindeki değişikliklere sembolik link dosyaları üzerinden de aynen ulaşabiliyoruz.</p>

<p>Şimdi tersini deneyelim. Yani sembolik dosyanın üzerine yeni veri ekleyip orijinal dosyaya etki edip etmeyeceğini görelim. Ben yeni veri eklemek üzere <code class="language-plaintext highlighter-rouge">echo “sembolik ekleme” &gt;&gt; sembolik-metin</code> şeklinde komutumu giriyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"sembolik ekleme"</span> <span class="o">&gt;&gt;</span> sembolik_metin 

└─<span class="nv">$ </span><span class="nb">cat </span>sembolik_metin                                           
deneme
yeni
sembolik ekleme

└─<span class="nv">$ </span><span class="nb">cat </span>linkler/metin                                            
deneme
yeni
sembolik ekleme
</code></pre></div></div>

<p>Bakın sembolik bağlantıdaki değişiklik orijinal dosyada da geçerli olmuş. Peki ama nasıl ?</p>

<p>Biz burada bu dosyaya veri eklemek üzere komutumuzu girdiğimizde, bu sembolik linke yönlendirmiş olduğumuz veriler orijinal dosyaya yönlendirilip, bu dosya üzerinden diskteki verilere ekleme yapılması sağlanıyor. Bu sayede tıpkı orijinal dosya üzerinden ekleme yapmışız gibi değişiklikler geçerli oluyor.</p>

<p><img src="http://localhost:4000/egitim/metin/soft-link.png" alt="soft-link.png" class="responsive img-zoomable" /></p>

<p>Yani bizzat teyit ettiğimiz gibi sembolik bağlantılar aslında orijinal dosyaya yönlendirme yapan kısayol dosyaları. Bu sebeple örneğin orijinal dosya silinirse, sembolik linkler üzerinden diskteki verilere ulaşmamız mümkün olmuyor. Çünkü dediğimiz gibi sembolik linkler yalnızca orijinal dosyaya yönlendirme yapıyor, bu orijinal dosya da zaten disk üzerindeki verilere ulaşmamızı sağlayan bir bağlantı. Eğer bu bağlantı kesilirse, diskteki veriler silinmemiş bile olsa o verilere ulaşmamız mümkün olmuyor.</p>

<p><img src="http://localhost:4000/egitim/metin/soft-link-hard-link-deleted.png" alt="soft-link-hard-link-deleted.png" class="responsive img-zoomable" /></p>

<p>Zaten biz standart şekilde dosya sildiğimizde arkaplanda yalnızca diskteki o verilere giden bu bağlantı adresi silinmiş oluyor. Yani diskte veriler mevcut olsa da o verilere ulaşmamızı sağlayan bağlantıyı kaybettiğimiz için ulaşamıyoruz. Bu sebeple standart şekilde silinen ve üzerine veri yazılamayan verilerin diskten kurtarılması mümkün oluyor.</p>

<p>Teorik olarak açıkladık. Şimdi bu durumu bizzat deneyimlemek için orijinal dosya olan “<strong><em>linkler</em></strong>” klasörü içerisindeki “<strong><em>metin</em></strong>” dosyasını silmek üzere <code class="language-plaintext highlighter-rouge">rm linkler/metin</code> şeklinde komutumuzu girip, <code class="language-plaintext highlighter-rouge">cat</code> komutu ile sembolik link dosyasını okumayı deneyebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">rm </span>linkler/metin                                             

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat </span>sembolik_metin                                           
<span class="nb">cat</span>: sembolik_metin: No such file or directory
</code></pre></div></div>

<p>Bakın böyle bir dosya veya dizin yok hatası alıyoruz. <code class="language-plaintext highlighter-rouge">ls -l</code> komutu ile listeleyelim.</p>

<p><img src="http://localhost:4000/egitim/metin/soft-link-deleted.png" alt="soft-link-deleted.png" class="responsive img-zoomable" /></p>

<p>Bakın sembolik link dosyası gözüküyor ama orijinal dosya silindiği için bu sembolik link kırmızı renkle listelenmiş oldu. Zaten sembolik link bizi bu dosyaya yönlendirdiği, ama bu dizinde böyle bir dosya olmadığı için bu hatayı aldık.</p>

<p>Yani benim <code class="language-plaintext highlighter-rouge">cat sembolik-metin</code> komutunu girmemle, <code class="language-plaintext highlighter-rouge">cat linkler/metin</code> komutunu girmem aynı şey.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">cat </span>sembolik_metin                                                      
<span class="nb">cat</span>: sembolik_metin: No such file or directory

└─<span class="nv">$ </span><span class="nb">cat </span>linkler/metin
<span class="nb">cat</span>: linkler/metin: No such file or directory
</code></pre></div></div>

<p>Bakın yine böyle bir dosya ve dizin yok şeklinde <code class="language-plaintext highlighter-rouge">cat</code> komutu bize hata döndürdü. İşte gördüğünüz gibi sembolik linkler yalnızca orijinal dosyalara yani aslında orijinal linklere yönlendirme yapan kısayollardır. Orijinal bağlantılar olmazsa, disk üzerindeki verilere ulaşmamız mümkün olmuyor.</p>

<h3 id="klasörler-için-sembolik-link">Klasörler için Sembolik Link</h3>

<p>Aynı şekilde klasörler için de sembolik linkeler oluşturabilirsiniz. Ben denemek için <code class="language-plaintext highlighter-rouge">ln -s linkler linkler-sembolik</code> komutu ile yeni sembolik klasörümü oluşturmak istiyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">ln</span> <span class="nt">-s</span> ~/linkler/ linkler-sembolik                                           

└─<span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-l</span> linkler-sembolik
lrwxrwxrwx 1 taylan taylan 8 Jun 26 04:38 linkler-sembolik -&gt; /home/taylan/linkler/
</code></pre></div></div>

<p>Bakın tıpkı sembolik dosyada olduğu gibi sembolik klasör de bağlı olduğu klasöre yönlendirme yapıyor. Sembolik klasörler de tıpkı dosyalar gibi yalnızca orijinal klasöre yönlendirme yaptığı için orijinal klasör silinirse sembolik link çalışmaz.</p>

<p>Denemek için <code class="language-plaintext highlighter-rouge">echo “deneme” &gt; linkler-sembolik/metin</code> şeklinde komutumuzu girebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"deneme"</span> <span class="o">&gt;</span> linkler-sembolik/metin

└─<span class="nv">$ </span><span class="nb">ls </span>linkler-sembolik                                                       
metin

└─<span class="nv">$ </span><span class="nb">ls </span>linkler
metin
</code></pre></div></div>

<p>Yukarıdaki çıktılara bakacak olursanız, sembolik klasöre yönlendirmiş olduğum dosyanın orijinal klasöre kaydolduğunu görebilirsiniz. Yani tıpkı dosyalar olduğu gibi sembolik klasörler de orijinal klasöre yönlendirme yapan kısayollar aslında.</p>

<p>Ben örnekler sırasında birer tane sembolik dosya ve klasör oluşturdum. Ancak istiyorsanız tek bir dosya veya klasör için birden fazla sembolik link de oluşturabilirsiniz. Zaten sembolik linkler kısayol görevinde olduğu için kısayol yapısına ihtiyaç duyulan her yerde kullanılabilir. Örneğin sık kullandığınız bir dizin veya dosya için masaüstünüzde bir sembolik bağlantı oluşturabilirsiniz.</p>

<h3 id="sembolik-linkleri-silmek">Sembolik Linkleri Silmek</h3>

<p>Sembolik link dosyalarını silmek için de doğrudan silmek istediğiniz sembolik link dosyasının ismini <code class="language-plaintext highlighter-rouge">rm</code> komutuna argüman olarak verebilirsiniz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">rm </span>sembolik_metin 

└─<span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-l</span> sembolik-metin
<span class="nb">ls</span>: cannot access <span class="s1">'sembolik-metin'</span>: No such file or directory

└─<span class="nv">$ </span><span class="nb">rm</span> <span class="nt">-d</span> linkler-sembolik

└─<span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-l</span> linkler-sembolik                                                    
<span class="nb">ls</span>: cannot access <span class="s1">'linkler-sembolik'</span>: No such file or directory
</code></pre></div></div>

<p>Gördüğünüz gibi sembolik dosya ve klasörleri standart şekilde silmiş olduk.</p>

<h2 id="katı-link">Katı Link</h2>

<p>Şimdi katı linklerden bahsedecek olursak. Sembolik linklere “soft link” denilmesi gibi, katı linklere de “hard link” denebiliyor. Katı link oluşturmak için doğrudan <code class="language-plaintext highlighter-rouge">ln</code> komutunu seçenek belirtmeden kullanabiliyoruz.</p>

<p>Ben denemek için yine <code class="language-plaintext highlighter-rouge">echo “orijinal dosyayım” &gt; linkler/metin</code> şeklinde komutumu giriyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"orijinal dosyayım"</span> <span class="o">&gt;</span> linkler/metin
</code></pre></div></div>

<p>Şimdi bu dosya için bir katı link oluşturmak üzere <code class="language-plaintext highlighter-rouge">ln linkler/metin kati-metin</code> şeklinde komutumuzu girebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">ln </span>linkler/metin katı-metin                                               

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-l</span> katı-metin                                                          
<span class="nt">-rw-r--r--</span> 2 taylan taylan 19 Jun 26 04:47 katı-metin
</code></pre></div></div>

<p>Bakın dosyam oluşturulmuş fakat bu dosyanın bir link dosyası olduğuna dair burada herhangi bir emare yok. Halbuki sembolik linkte açıkça link dosyası olduğu ve hangi dosyaya bağlı olduğu buradaki çıktılarda belirtiliyordu.</p>

<p>Burada katı linke dair özel bir çıktı almadık çünkü aslında katı link dediğimiz kavram sistemimiz üzerindeki tüm standart dosya ve dizinleri temsil ediyor. Yani benim oluşturduğum orijinal metin dosyası da disk üzerindeki verilere yönlendirme yapan bir katı link.</p>

<p><img src="http://localhost:4000/egitim/metin/hard-link.png" alt="hard-link.png" class="responsive img-zoomable" /></p>

<p>Ben burada “<strong><em>kati-metin</em></strong>” isimli yeni bir katı link oluşturduğumda, tıpkı orijinal dosya gibi doğrudan beni diskteki verilere yönlendiren inode değerine bir bağlantı oluşturmuş oldum.</p>

<p><img src="http://localhost:4000/egitim/metin/hard-link2.png" alt="hard-link2.png" class="responsive img-zoomable" /></p>

<p>Sembolik linkte nasıl oluyordu. Sembolik linkler, orijinal linklere yani aslında katı linkli dosyalara yönlendirme yapıyordu, oradan da disk üzerindeki verilere ulaşabiliyorduk.,</p>

<p><img src="http://localhost:4000/egitim/metin/soft-link2.png" alt="soft-link2.png" class="responsive img-zoomable" /></p>

<p>Katı linkte ise hem orijinal dosya hem de yeni oluşturduğumuz katı link dosyası inode değerine bağlı olduğu için aynı disk verisinin yerini biliyor ve bizi oraya yönlendirebiliyor.</p>

<p>Dolayısıyla ben orijinal veya bu yeni oluşturduğum katı link dosyasında değişiklik yaptığımda diskteki bu veri değiştiği için bu değişikliğe her iki dosya üzerinden de ulaşabiliyorum. Hatta orijinal dosya silinse bile yeni oluşturduğum katı link dosyası inode sayesinde verilerin disk üzerinde tam olarak hangi bloklarda olduğunu bildiği için benim o verilere ulaşmam mümkün oluyor.</p>

<p><img src="http://localhost:4000/egitim/metin/hard-link3.png" alt="hard-link3.png" class="responsive img-zoomable" /></p>

<p>Hemen bu durumu bizzat teyit etmek için öncelikle basit bir test olarak yeni oluşturduğumuz katı link dosyası üzerinden yeni veri eklemeyi deneyebiliriz.</p>

<p>Ben denemek için <code class="language-plaintext highlighter-rouge">echo “yeni veri” &gt;&gt; katı-metin</code> şeklinde komutumu giriyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"yeni veri"</span> <span class="o">&gt;&gt;</span> katı-metin 

└─<span class="nv">$ </span><span class="nb">cat </span>katı-metin                                                            
orijinal dosyayım
yeni veri

└─<span class="nv">$ </span><span class="nb">cat </span>linkler/metin                                                         
orijinal dosyayım
yeni veri
</code></pre></div></div>

<p>Eklediğim değişikliğe her iki dosya üzerinden de aynı şekilde ulaşabildim. Benzer şekilde <code class="language-plaintext highlighter-rouge">echo “orijinal ekleme” &gt;&gt; linkler/metin</code> şeklinde tekrar orijinal dosya üzerinden veri eklemeyi de deneyebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"orijinal ekleme"</span> <span class="o">&gt;&gt;</span> linkler/metin 

└─<span class="nv">$ </span><span class="nb">cat </span>linkler/metin                                   
orijinal dosyayım
yeni veri
orijinal ekleme

└─<span class="nv">$ </span><span class="nb">cat </span>katı-metin                                   
orijinal dosyayım
yeni veri
orijinal ekleme
</code></pre></div></div>

<p>Bakın orijinal dosya üzerindeki değişiklik bu dosyayı da aynen etkiliyor. Çünkü zaten tüm değişiklikler inode değeri üzerinden gerçekleştirildiği için iki dosya aynı veriye erişebilen iki ayrı dosya gibi.</p>

<p>Şimdi ben son olarak orijinal dosyayı sildiğimde bu diskteki bu verilere ulaşıp ulaşamayacağımı test etmek için <code class="language-plaintext highlighter-rouge">rm linkler/metin</code> komutunu girip orijinal dosyamı siliyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">rm </span>linkler/metin                                                          

└─<span class="nv">$ </span><span class="nb">cat </span>katı-metin                                                            
orijinal dosyayım
yeni veri
orijinal ekleme
</code></pre></div></div>

<p>Gördüğünüz gibi orijinal dosya silinmiş olmasına rağmen hala disk üzerindeki aynı verilere erişmeye devam edebiliyorum. Çünkü işleyiş aslında aşağıdaki şemadaki gibi.</p>

<p><img src="http://localhost:4000/egitim/metin/hard-link3.png" alt="hard-link3.png" class="responsive img-zoomable" /></p>

<p>En nihayetinde gördüğünüz gibi aslında sistemiz üzerindeki standart dosya ve klasörler disk üzerindeki veri bloklarına inode üzerinden yönlendirme yapan bağlantı adresleri. Biz bu bağlantı adresleri yani linkler sayesinde kolay okunabilir isimlerle diskteki verilerimizi düzenle tutup tekrar tekrar erişebiliyoruz.</p>

<p>Yeni katı link oluşturma yaklaşımı sayesinde disk üzerinde tekrar aynı veriler için fazladan depolama alanı harcanmasına gerek kalmadan, dosyaların yedeklerinin alınması mümkün oluyor. Daha önce de silme işleminin aslında verilere ulaşmamızı sağlayan bağlantıların silinmesinden ibaret olduğunu söylemiştik. Eğer verilere ulaşmamızı sağlayan birden fazla katı link olursa, bir katı link silinse bile diskimiz üzerindeki verilere ulaşmaya devam edebiliyoruz. Katı link yaklaşımı tam olarak bu amaçla kullanılıyor. Ve disk üzerinde fazladan depolama alını işgal etmeden yedeklemek için harika bir çözüm.</p>

<p>Tabii ki katı linkler örneklerimiz üzerinden bizzat teyit ettiğimiz gibi mevcut verilerin üzerine yazılmasına engel olmuyor. Yalnızca ilişkili verilere giden yolun silinmesi ihtimali için yedekleme imkanı tanıyor. Yani eğer üzerine veri yazılması konusunda endişe duyduğunuz verileriniz varsa tabii ki bunları başka bir dizine kopyalayıp tekrar aynı verilerin diskte farklı bloklarda yedeklenmesini sağlamanız gerekiyor.</p>

<p><img src="http://localhost:4000/egitim/metin/backup.png" alt="backup.png" class="responsive img-zoomable" /></p>

<p>Bakın dosyayı kopyaladığımızda, dosya içindeki veriler disk üzerinde başka bir bloğa yazılıp, bu bloğun adresi de yeni inode numarası üzerinden ulaşılabilir oluyor. Bu sayede orijinal dosyanın üzerine veri yazılsa bile bu bloktaki verilere müdahele edilmemiş oluyor.</p>

<p>Katı link ile standart kopyalanmış dosyaların farkı işte tam olarak bu.</p>

<h3 id="klasörler-için-katı-link">Klasörler için Katı Link</h3>

<p>Standart dosya sistemi yani hiyerarşik dizin yapısı gereği, klasörler için katı link oluşturmayacağımızı da belirtmek istiyorum. İnanmıyorsanız <code class="language-plaintext highlighter-rouge">ln linkler/ linkler-katı</code> komutuyla yeni bir tane oluşturmayı deneyebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">ln </span>linkler/ linkler-katı                                                  
<span class="nb">ln</span>: linkler/: hard <span class="nb">link </span>not allowed <span class="k">for </span>directory
</code></pre></div></div>

<p>Bakın dizinler için hard link yani katı linkler kabul edilmiyormuş.</p>

<p>Umarım sembolik ve katı linklerin farkları ve kullanım biçimleri net bir biçimde anlaşılmıştır. Biraz pratik yaparsanız ve gerekiyorsa bu dersi baştan dikkatlice tekrar dinlerseniz aslında ne kadar kolay olduğunu zaten göreceksiniz.</p>

<p>Ve artık böylelikle dosya işlemleri için bilmemiz gereken temel araçları tanıdığımıza göre bu bölümü sonlandırabiliriz.</p>

<p></p>
          <div align="center" class="custom-control custom-switch">
                
            <input type="checkbox" class="custom-control-input" id="readCheckbox"  onchange="markAsRead()">
            <label class="custom-control-label" for="readCheckbox">Okundu Olarak İşaretle  </label>
          </div>
          <p></p>
          <div align="center">
            <button id="linkedinShareButton" class="mavi btn btn-outline-primary">
              <svg width="24px" height="24px" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" fill="none"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"><path fill="#0A66C2" d="M12.225 12.225h-1.778V9.44c0-.664-.012-1.519-.925-1.519-.926 0-1.068.724-1.068 1.47v2.834H6.676V6.498h1.707v.783h.024c.348-.594.996-.95 1.684-.925 1.802 0 2.135 1.185 2.135 2.728l-.001 3.14zM4.67 5.715a1.037 1.037 0 01-1.032-1.031c0-.566.466-1.032 1.032-1.032.566 0 1.031.466 1.032 1.032 0 .566-.466 1.032-1.032 1.032zm.889 6.51h-1.78V6.498h1.78v5.727zM13.11 2H2.885A.88.88 0 002 2.866v10.268a.88.88 0 00.885.866h10.226a.882.882 0 00.889-.866V2.865a.88.88 0 00-.889-.864z"></path></g></svg>
              Paylaş
            </button>
            <button id="twitterShareButton" class="mavi btn btn-outline-primary">
              <svg width="24px" height="24px" viewBox="0 -4 48 48" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000000"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <title>Twitter-color</title> <desc>Created with Sketch.</desc> <defs> </defs> <g id="Icons" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"> <g id="Color-" transform="translate(-300.000000, -164.000000)" fill="#00AAEC"> <path d="M348,168.735283 C346.236309,169.538462 344.337383,170.081618 342.345483,170.324305 C344.379644,169.076201 345.940482,167.097147 346.675823,164.739617 C344.771263,165.895269 342.666667,166.736006 340.418384,167.18671 C338.626519,165.224991 336.065504,164 333.231203,164 C327.796443,164 323.387216,168.521488 323.387216,174.097508 C323.387216,174.88913 323.471738,175.657638 323.640782,176.397255 C315.456242,175.975442 308.201444,171.959552 303.341433,165.843265 C302.493397,167.339834 302.008804,169.076201 302.008804,170.925244 C302.008804,174.426869 303.747139,177.518238 306.389857,179.329722 C304.778306,179.280607 303.256911,178.821235 301.9271,178.070061 L301.9271,178.194294 C301.9271,183.08848 305.322064,187.17082 309.8299,188.095341 C309.004402,188.33225 308.133826,188.450704 307.235077,188.450704 C306.601162,188.450704 305.981335,188.390033 305.381229,188.271578 C306.634971,192.28169 310.269414,195.2026 314.580032,195.280607 C311.210424,197.99061 306.961789,199.605634 302.349709,199.605634 C301.555203,199.605634 300.769149,199.559408 300,199.466956 C304.358514,202.327194 309.53689,204 315.095615,204 C333.211481,204 343.114633,188.615385 343.114633,175.270495 C343.114633,174.831347 343.106181,174.392199 343.089276,173.961719 C345.013559,172.537378 346.684275,170.760563 348,168.735283" id="Twitter"> </path> </g> </g> </g></svg>
              Paylaş
            </button>
            <p></p>
            <h5>📮 Hata, eksik ve öneri bildirimlerinizi <a href="http://localhost:4000/bildirim.html">buradan</a> iletebilirsiniz. </h5>
          </div>

        <p></p>



  

  

  

  

  

  

  

  

  

  

  

  
    
    
    
    


<div data-pagefind-ignore="all" class="row mb-2">
  
      
    <div class="col-md-6">
      <div class="no-gutters border rounded overflow-hidden flex-md-row mb-4 shadow-sm h-md-250 position-relative">
        <div class="col p-4 d-flex flex-column position-static">
          <div class="row">
            <div align="left" class="align-self-center col-2">
              <svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 320 512">
                <!--! Font Awesome icon code -->
                <path d="M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l192 192c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L77.3 256 246.6 86.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-192 192z" fill="currentColor"/>
              </svg>
            </div>
            <div align="right" class="col-10">
              <div class="mb-1 text-muted"><strong>Önceki</strong></div>
              <p class="card-text">Metinleri Filtrelemek</p>
            </div>
          </div>
          <a href="http://localhost:4000/egitim/metinleri-filtrelemek/" title="Metinleri Filtrelemek" class="stretched-link"></a>
        </div>
      </div>
    </div>
  

  
      
    <div class="col-md-6">
      <div class="no-gutters border rounded overflow-hidden flex-md-row mb-4 shadow-sm h-md-250 position-relative">
        <div class="col p-4 d-flex flex-column position-static">
          <div class="row">
            <div align="left" class="col-10">
              <div class="mb-1 text-muted"><strong>Sonraki</strong></div>
              <p class="card-text">Metin Editörü Kullanımı</p>
            </div>
            <div align="right" class="align-self-center col-2">
              <svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 320 512">
                <!--! Font Awesome icon code -->
                <path d="M310.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-192 192c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L242.7 256 73.4 86.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l192 192z" fill="currentColor"/>
              </svg>
            </div>
          </div>
          <a href="http://localhost:4000/egitim/metin-editoru/" title="Metin Editörü Kullanımı" class="stretched-link"></a>
        </div>
      </div>
    </div>
  
</div>


      </div>

      <div class="col-md-3">
        <p></p>
        <div class="no-gutters border rounded overflow-hidden flex-md-row mb-4 shadow-sm h-md-250 position-relative">
          <h3 align="center" class="mavi">Sayfa İçeriği</h3>
          <div data-pagefind-subpage>
            <ul id="toc" class="section-nav">
<li class="toc-entry <hh1"><a href="#cp-komutu">cp Komutu</a>
<ul>
<li class="toc-entry <hh2"><a href="#dosya-i̇smini-değiştirmek">Dosya İsmini Değiştirmek</a></li>
<li class="toc-entry <hh2"><a href="#klasörleri-kopyalamak">Klasörleri Kopyalamak</a></li>
</ul>
</li>
<li class="toc-entry <hh1"><a href="#mv-komutu">mv Komutu</a></li>
<li class="toc-entry <hh1"><a href="#rm-komutu">rm Komutu</a>
<ul>
<li class="toc-entry <hh2"><a href="#klasörlerin-silinmesi">Klasörlerin Silinmesi</a></li>
<li class="toc-entry <hh2"><a href="#i̇çerisi-dolu-olan-klasörlerin-silinmesi">İçerisi Dolu Olan Klasörlerin Silinmesi</a></li>
</ul>
</li>
<li class="toc-entry <hh1"><a href="#shred-komutu--dosyaları-geri-döndürülemez-şekilde-silmek">shred Komutu | Dosyaları Geri Döndürülemez Şekilde Silmek</a>
<ul>
<li class="toc-entry <hh2"><a href="#shred-komutu">shred Komutu</a></li>
</ul>
</li>
<li class="toc-entry <hh1"><a href="#linux-geri-dönüşüm-kutusu">Linux Geri Dönüşüm Kutusu</a></li>
<li class="toc-entry <hh1"><a href="#sembolik-ve-katı-link--soft-link--hard-link">Sembolik ve Katı Link | Soft Link &amp; Hard Link</a>
<ul>
<li class="toc-entry <hh2"><a href="#inode">inode</a></li>
<li class="toc-entry <hh2"><a href="#sembolik-link--soft-link">Sembolik Link | Soft Link</a>
<ul>
<li class="toc-entry <hh3"><a href="#klasörler-için-sembolik-link">Klasörler için Sembolik Link</a></li>
<li class="toc-entry <hh3"><a href="#sembolik-linkleri-silmek">Sembolik Linkleri Silmek</a></li>
</ul>
</li>
<li class="toc-entry <hh2"><a href="#katı-link">Katı Link</a>
<ul>
<li class="toc-entry <hh3"><a href="#klasörler-için-katı-link">Klasörler için Katı Link</a></li>
</ul>
</li>
</ul>
</li>
</ul>
          </div>
        </div>
        <p></p>

	  
	  
      <div class="no-gutters border rounded overflow-hidden flex-md-row mb-4 shadow-sm h-md-250 position-relative">
        <div class="col p-4 d-flex flex-column position-static">
			<p align="center" class="mavi text-primary">Video Eğitim</p>
		<img src="http://localhost:4000/video-egitim.png"/>
          <p class="card-text mb-auto">Buradaki anlatımları, video eğitim üzerinden takip etmek ve gerektiğinde soru sorabilmek isterseniz kursa gözatın.</p>
         <a href="https://www.udemy.com/course/kali-linux-ile-sifirdan-temel-linux-egitimi/?referralCode=04ABD09E6ED5DA93F7A2" class=" stretched-link"></a>
        </div>
        </div>
  
        <p></p>

	  
	  
      <div class="no-gutters border rounded overflow-hidden flex-md-row mb-4 shadow-sm h-md-250 position-relative">
        <div class="col p-4 d-flex flex-column position-static">
			<p align="center" class="kirmizi text-danger">Kitap</p>
		<img src="http://localhost:4000/kitap.png"/>
          <p class="card-text mb-auto">Linux sistem yönetimine giriş için kitap arıyorsnız gözatın.</p>
         <a href="https://www.udemy.com/course/kali-linux-ile-sifirdan-temel-linux-egitimi/?referralCode=04ABD09E6ED5DA93F7A2" class=" stretched-link"></a>
        </div>
        </div>
  
      </div>
	  
    </div>
</div>
  
  <hr>

<footer class="container py-5">
  <div class="row">
    <div class="col-6 col-md">
 <h5><a href="/">Linux Dersleri</a> | <a target="_blank" href="https://github.com/Linux-Dersleri/linux-dersleri.github.io"><i class="fa fa-github fa-lg"></i></a></h5>
 <p class="small">GNU/Linux için Türkçe içerik sağlamak üzere kurulmuş bir platformdur.</p>
	 
	  
    </div>
    <div class="col-6 col-md">
      <h5>Eğitim Serileri</h5>
      <ul class="list-unstyled text-small">
        <li><a class="text-muted" href="#">Sıralı Doküman</a></li>
        <li><a class="text-muted" href="#">Video Eğitim</a></li>
      </ul>
    </div>
    
  
    <div class="col-6 col-md">
      <h5>Hakkında</h5>
      <ul class="list-unstyled text-small">
        <li><a class="text-muted" href="http://localhost:4000/sıkca-sorulan-sorular.html">S.S.S.</a></li>
        <li><a class="text-muted" href="http://localhost:4000/gizlilik.html">Veri Politikası</a></li>
        <li><a class="text-muted" href="http://localhost:4000/bildirim.html">Geri Bildirim</a></li>
		<li><a class="text-muted" href="mailto: info@linuxdersleri.net">İletişim</a></li>
      </ul>
    </div>
	<div class="col-6 col-md">
      <h5>Android Uygulaması</h5>
      <ul class="list-unstyled text-small">
        <a href='https://play.google.com/store/apps/details?id=com.bildik.linuxdersleri&pcampaignid=pcampaignidMKT-Other-global-all-co-prtnr-py-PartBadge-Mar2515-1'><img style="width: 75%;" alt='Google Play'den alın' src='https://play.google.com/intl/en_us/badges/static/images/badges/tr_badge_web_generic.png'/></a>
	  </ul>
	  
    </div>
  </div>
</footer>


<script src="http://localhost:4000/assets/js/jquery-3.3.1.slim.min.js"></script>
<script src="http://localhost:4000/assets/js/script.js"></script>		
<script src="http://localhost:4000/assets/js/bootstrap.min.js"></script>

<script>
    // Twitter share button functionality
    var twitterShareButton = document.getElementById("twitterShareButton");
        twitterShareButton.addEventListener("click", function() {
          var tweetText = " #Linux Dersleri platformundaki \"Kopyalama Taşıma Silme\" içeriğini faydalı bulduğum için paylaşmak istedim. http://localhost:4000/egitim/kopyalama-ta%C5%9F%C4%B1ma-silme-i%C5%9Flemleri/";
          var tweetUrl = "https://twitter.com/intent/tweet?text=" + encodeURIComponent(tweetText);
          window.open(tweetUrl, "_blank");
        });
  
        // LinkedIn share button functionality
        var linkedinShareButton = document.getElementById("linkedinShareButton");
        linkedinShareButton.addEventListener("click", function() {
          var postUrl = "https://www.linkedin.com/sharing/share-offsite/?mini=true&url=http://localhost:4000/egitim/kopyalama-ta%C5%9F%C4%B1ma-silme-i%C5%9Flemleri/&title=Kopyalama Taşıma Silme&summary=\"Kopyalama Taşıma Silme\" içeriğini faydalı bulduğum için paylaşmak istedim.";
          window.open(postUrl, "_blank");
        });
        </script>
<script src="http://localhost:4000/assets/js/read.js"></script>
<script src="http://localhost:4000/assets/js/zooming.min.js"></script>
<script>
   // Listen to images after DOM content is fully loaded
   document.addEventListener('DOMContentLoaded', function () {
        new Zooming({
          // options...
        }).listen('.img-zoomable')
      })
</script>
</body>

</html>
