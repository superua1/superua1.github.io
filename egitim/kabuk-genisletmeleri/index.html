<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="utf-8">
<link rel="icon" href="/logo.svg" type="image/svg+xml" />
<title>Linux Dersleri | Kabuk Genişletmeleri &#8211; Linux Eğitimi</title>
<meta name="description" content="Bash kabuğunun genişletmelerinden ve regex kavramından bahsediyoruz.">
<meta name="keywords" content="kabuk genişletmeleri, yıldız, soru işareti, köşeli parantez, regex, alıntı karakterleri, komut ikamesi">








<link rel="canonical" href="https://superua1.github.io//egitim/kabuk-genisletmeleri/">
<link href="https://superua1.github.io//feed.xml" type="application/atom+xml" rel="alternate" title="Linux Eğitimi Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="https://superua1.github.io//assets/css/font-awesome.min.css">
<link rel="stylesheet" href="https://superua1.github.io//assets/css/bootstrap.min.css">
<link rel="stylesheet" href="https://superua1.github.io//assets/css/style.css">


<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="https://superua1.github.io//favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="https://superua1.github.io//favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="https://superua1.github.io//images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="https://superua1.github.io//images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="https://superua1.github.io//images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://superua1.github.io//images/apple-touch-icon-144x144-precomposed.png">

<link rel="stylesheet" href="https://superua1.github.io//assets/css/read.css">
<style>
 .grid {
        column-count: 2;
        column-gap: 1rem;
      }

  </style>
</head>
<body>

<div class="bs-canvas-overlay bs-canvas-anim bg-dark position-fixed w-100 h-100"></div>
<nav class="navbar x-navbar sticky-top navbar-expand-lg navbar-light bg-light border-bottom">
	
  <div class="collapse navbar-collapse">
    <a class="navbar-brand active" href="https://superua1.github.io//">
      <img src="https://superua1.github.io//logo.svg" width="30" height="30" class="align-top" alt="">
      Linux Dersleri
    </a>
    <ul class="navbar-nav">
      <li class="nav-item active">
        <a class="nav-link" href="https://superua1.github.io//egitim.html">Eğitimler</a>
      </li>
      <li class="nav-item active">
        <a class="nav-link" href="https://superua1.github.io//blog/">Blog</a>
      </li>
	  <li class="nav-item active">
        <a class="nav-link" href="https://superua1.github.io//komutlar">Komut Listesi</a>
      </li>
	  <li class="nav-item active">
        <a class="nav-link" href="https://superua1.github.io//test">Test</a>
      </li>
      <li class="nav-item active">
        <a class="nav-link" href="https://superua1.github.io//etiketler">Etiketler</a>
      </li>
	 <li class="nav-item active">
        <a class="nav-link" href="https://superua1.github.io//hakkında.html">Hakkında</a>
      </li>
    </ul>
	
  </div>
 
<a class="btn" data-toggle="modal" data-target="#searchModal"><i class="fa fa-search" style="width:16px;height:16px"></i></a>
	<a onclick="tema()" class="btn" ><i class="fa fa-adjust fa-lg"></i></a> 
	<a href="https://superua1.github.io//bildirim.html" class="btn" ><i class="fa fa-paper-plane"></i></a> 
</nav>	
<nav class="navbar y-navbar sticky-top navbar-expand-lg navbar-light bg-light border-bottom">
<button class="btn"  data-toggle="canvas" data-target="#bs-canvas-left" aria-expanded="false" aria-controls="bs-canvas-left"><i class="fa fa-align-justify fa-lg"></i></button>
		<a href="https://superua1.github.io//" class="btn"  ><i class="fa fa-home fa-lg"></i></a>     
	<a class="btn" data-toggle="modal" data-target="#searchModal"><i class="fa fa-search" style="width:16px;height:16px"></i></a>
		
		<a onclick="tema()" class="btn" ><i class="fa fa-adjust fa-lg"></i></a> 
		<a href="https://superua1.github.io//bildirim.html" class="btn" ><i class="fa fa-paper-plane"></i></a> 
		
</nav>

<div style="background-color: var(--background);" id="bs-canvas-left" class="bs-canvas bs-canvas-anim bs-canvas-left position-fixed h-100" >
   <div class="container">
    
      <a class="btn bs-canvas-close close" aria-label="Close">
        <span aria-hidden="true">&times;</span>
      </a>
      <a class="navbar-brand" href="https://superua1.github.io//">
        <img src="https://superua1.github.io//logo.svg" width="30" height="30" class="align-top" alt="">
        Linux Dersleri
      </a>
  
    
    
   <hr>
 <a data-toggle="modal" data-target="#searchModal" class="btn">🕵️ Arama</a>
  <a href="https://superua1.github.io//egitim" class="btn">🎓 Eğitimler</a>
  <a href="https://superua1.github.io//blog" class="btn">🗃️ Blog</a>
  <a href="https://superua1.github.io//komutlar" class="btn">📜 Komut Listesi</a>
  <a href="https://superua1.github.io//test" class="btn">🎯 Test</a>
  <a href="https://superua1.github.io//etiketler" class="btn">🏷️ Etiketler</a>
  <a href="https://superua1.github.io//hakkında.html" class="btn">🐧 Hakkında</a>
 
  <a href="https://superua1.github.io//bildirim.html" class="btn">📮 Geri Bildirim</a>
  <hr>
  
  <div align="center">
  <h5>Android Uygulaması</h5>
      <ul class="list-unstyled text-small">
        <a href="https://play.google.com/store/apps/details?id=com.bildik.linuxdersleri&amp;pcampaignid=pcampaignidMKT-Other-global-all-co-prtnr-py-PartBadge-Mar2515-1"><img style="width: 75%;" alt="Google Play" den="" alın'="" src="https://play.google.com/intl/en_us/badges/static/images/badges/tr_badge_web_generic.png"></a>
	  </ul>
	  <hr>
 <h5><a href="/">Linux Dersleri</a> | <a target="_blank" href="https://github.com/Linux-Dersleri/linux-dersleri.github.io"><i class="fa fa-github fa-lg"></i></a></h5>
 <p class="small">GNU/Linux için Türkçe içerik sağlamak üzere kurulmuş bir platformdur.</p>

	  </div>
    
</div>

</div>



<!-- Modal -->
<div class="modal fade" id="searchModal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
  <div class="modal-dialog" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="searchModalLabel">🕵️ Site Geneli Arama:</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <link href="https://superua1.github.io//pagefind/pagefind-ui.css" rel="stylesheet">
<script src="https://superua1.github.io//pagefind/pagefind-ui.js" type="text/javascript"></script>

<div id="search"></div>
<script>

    window.addEventListener('DOMContentLoaded', (event) => {
        new PagefindUI({ element: "#search", showImages: false });
		
    });
	
</script>
      </div>

    </div>
  </div>
</div>

<script src="https://superua1.github.io//assets/js/jquery-3.3.1.slim.min.js" type="text/javascript"></script>
<div id="progress-bar-container">
  <div id="progress-bar"></div>
</div>
      <div class="container-fluid">
  <div class="row mb-2">
      <div style="font-size: 18px;" class="col-md-9" data-pagefind-filter="Bölüm:Eğitim Serisi:">
        	<h1 align="center">8. Ders: Kabuk Genişletmeleri</h1> 
<div align="center"><i class="fa fa-tags" aria-hidden="true"></i>
          <a href="https://superua1.github.io//etiketler.html#kabuk genişletmeleri" class="btn btn-outline-primary btn-sm" title="Pages tagged kabuk genişletmeleri">kabuk genişletmeleri</a> <a href="https://superua1.github.io//etiketler.html#yıldız" class="btn btn-outline-primary btn-sm" title="Pages tagged yıldız">yıldız</a> <a href="https://superua1.github.io//etiketler.html#soru işareti" class="btn btn-outline-primary btn-sm" title="Pages tagged soru işareti">soru işareti</a> <a href="https://superua1.github.io//etiketler.html#köşeli parantez" class="btn btn-outline-primary btn-sm" title="Pages tagged köşeli parantez">köşeli parantez</a> <a href="https://superua1.github.io//etiketler.html#regex" class="btn btn-outline-primary btn-sm" title="Pages tagged regex">regex</a> <a href="https://superua1.github.io//etiketler.html#alıntı karakterleri" class="btn btn-outline-primary btn-sm" title="Pages tagged alıntı karakterleri">alıntı karakterleri</a> <a href="https://superua1.github.io//etiketler.html#komut ikamesi" class="btn btn-outline-primary btn-sm" title="Pages tagged komut ikamesi">komut ikamesi</a>   
		 <p></p> 
		  <div align="center" class="col-sm-3">
		<img class="responsive" src="https://superua1.github.io//egitim/genisletmecover.png" alt="">
		  </div>	</div>	  

		  <hr>	
		  <h6 align="right" id="meta-da">
			<i class="fa fa-clock-o" aria-hidden="true"></i>

67 dk.


		   

  <i class="fa fa-user" aria-hidden="true"></i><a href="https://superua1.github.io//hakkında.html"> Taylan Özgür Bildik</a>


		  
		  </h6>  
		  
		  
        <h1 id="kabuk-üzerinde-genişletme">Kabuk Üzerinde Genişletme</h1>
<p>Bash kabuğunun nasıl çalıştığından bahsettiğimiz bölümde, kabuğa girdiğimiz komutların öncelikle kabuk tarafından anlamlandırılmak üzere metinsel olarak işlendiğinden bahsetmiştik. Kabuk, girilen komutları inceleyip kendi üzerine düşen bir görev varsa bunları yapmak istiyor. Bu işleme de <strong>genişletme</strong> deniyor.</p>

<p>Aslında kabuğun teknik olarak nasıl çalıştığının detaylarına girip kafamızın karışmasını istemiyorum ancak bu bölümde anlatacaklarımızın daha net olması için çok çok basit düzeyde haberdar olmamız gereken bir işleyiş var.</p>

<p>Kabuğa bir komut girdiğimizde girdiğimiz komut “<strong>lexical analysis &amp; parsing”</strong> yani sözcük “analizi ve ayrıştırma” olarak geçen ilk aşamadan geçiriliyor. Daha sonra anlamlandırılan ve ayrıştırılan komuttaki genişletilmesi gereken bölümler buradaki genişletme kuralları dahilinde sıraya uygun şekilde genişletilme adımlarından geçiriliyor. Son olarak ayrıştırıp genişletilmiş olan yani son halini almış olan bu komut da çalıştırılıp, işlem sonlandıktan sonra durum hakkında olumlu olumsuz bilgi sunan çıkış kodu üretiliyor.</p>

<p><img src="https://superua1.github.io//egitim/genisletme/diagram.png" alt="diagram.png" class="responsive img-zoomable" /></p>

<p>Yani sırasıyla burada görselleştirmeye çalıştığım şemaya benzer bir işleyiş söz konusu. Fakat tabii ki temel düzey için buradaki tüm kavramlar fazla gelebilir. Bu sebeple biz bu eğitimde yalnızca en yaygın kullanıma sahip birkaç genişletmeyi ele alacağız. Yine de daha fazla detay almak isterseniz, GNU dokümanları içinde yer alan bu <a href="https://www.gnu.org/software/bash/manual/bash.html">bash dokümantasyonu</a> ihtiyacınız olan tüm bilgileri size sağlayacaktır.</p>

<p>Ben burada bahsi geçen “genişletme” özelliğini basit bir örnek üzerinden açıklayarak devam etmek istiyorum.</p>

<p>Örneğin konsolumuzu açıp, daha önce de yaptığımız gibi <code class="language-plaintext highlighter-rouge">echo merhaba</code> yazarsak ne olur ?</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo </span>merhaba
merhaba
</code></pre></div></div>

<p>Bakın <code class="language-plaintext highlighter-rouge">echo</code> aracı kendisine argüman olarak verilmiş olan “<strong>merhaba</strong>” ifadesini konsola bastırdı. Bu sayede bu çıktıyı almış olduk. Şimdi bir de <code class="language-plaintext highlighter-rouge">echo</code> komutunun ardından yalnızca <code class="language-plaintext highlighter-rouge">*</code> yıldız karakterini girmeyi deneyelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="k">*</span>
bu bir deneme metnidir Desktop Documents DOSYA_ADI dosya_adı Dosya_adı Downloads klasor Music Pictures Public Templates test-dosyası Videos yeni yeni klasor yeni-klasor
</code></pre></div></div>

<p>Bakın yıldız karakteri yerine, konsolun çalışmakta olduğu mevcut dizindeki dosya ve klasörlerin isimleri bastırıldı. Peki ama niye böyle oldu ?</p>

<p>Bu durumun nedeni ikinci örneğimizde kullanmış olduğumuz <code class="language-plaintext highlighter-rouge">*</code> yıldız(asterix) işaretinin bash üzerinde özel bir anlam taşıyor olması. Yıldız işareti bash kabuğuna göre özel anlam taşıdığı için bash kabuğu burada yıldız karakterini doğrudan <code class="language-plaintext highlighter-rouge">echo</code> aracına argüman olarak iletip konsola bastırtmak yerine, <code class="language-plaintext highlighter-rouge">echo</code> aracını çalıştırmadan önce yıldız karakterini genişletip, genişletme sonucu ortaya çıkan argümanları <code class="language-plaintext highlighter-rouge">echo</code> aracına iletiyor. Normalde buradaki yıldız joker karakteri mevcut dosya ve klasör isimlerindeki olası tüm karakterleri kapsama işlevinde. Bizim örneğimizde kabuk <code class="language-plaintext highlighter-rouge">echo</code> komutundan sonra yıldız karakterini gördüğünde, bu özel karakterin mevcut bulunduğumuz dizindeki tüm dosya ve klasörlerin isimlerini temsil etmek için konulduğunu düşünüyor ve bu doğrultuda yıldız karakterini dosya ve dizin isimleri olarak genişletiyor. Neticede bizim <code class="language-plaintext highlighter-rouge">echo *</code> olarak girdiğimiz komut kabuk tarafından <code class="language-plaintext highlighter-rouge">echo dosya ve dizin isimleri</code> olarak genişletilmiş oluyor. <code class="language-plaintext highlighter-rouge">echo</code> aracı da kendisine argüman olarak verilmiş olan dosya ve dizin isimlerini konsola bastırıyor.</p>

<p><img src="https://superua1.github.io//egitim/genisletme/2.png" alt="2.png" class="responsive img-zoomable" /></p>

<p>İşte tıpkı bu örneğimizde de deneyimlediğimiz gibi kabuk, bizim yazılı şekilde verdiğimiz emirleri doğru şekilde algılayabilmek için komutları çalıştırmadan önce komut metni içerisindeki özel anlam taşıyan ifadeleri bulup gerçekte neyin kast edildiğini anlayabilmek için çeşitli bağlamlara göre değerlendiriyor. Bu değerlendirme işini de tıpkı şemada açıkladığımız gibi adım adım gerçekleştiriyor. Yani kabuk kendisinde tanımlı olan görevler dahilinde, girdiğimiz komutta kendisinin yapması gereken işlemler varsa ilk olarak bunları yapıyor. Girilen komutlar yani argümanlar kabuk tarafından işlenip uygun şekilde genişletildikten sonra da zaten ilgili araca bu argümanlar aktarılıyor.</p>

<p>İşte “<strong>genişletme</strong>” olarak bahsettiğimiz durum, kabuğa girilen yazılı ifadelerin bağlamına göre değerlendirilip uygun değerlere dönüştürülmesi yani genişletilmesidir.</p>

<p>Anlatım devamında kabuk üzerinde geçerli olan genişletme kurallarının detaylarına ve gerektiğinde bu genişletmeden nasıl kaçınabileceğimize uygulamalı olarak değiniyor olacağız. Eğer kabuğun genişletmeleri nasıl ele aldığını bilirsek, çok daha az eforla kabuğa çok daha fazla iş yaptırabiliriz.</p>

<h1 id="süslükıvırcık-parantez-küme-ayracı-genişletmesi">Süslü(Kıvırcık) Parantez-Küme Ayracı Genişletmesi</h1>

<p>Kıvırcık parantez genişletmesi sayesinde sayılar ve karakterlerle istediğimiz aralıklarda verilerin oluşturulmasını sağlayabiliriz. Yani kendi ihtiyaçlarımıza göre örüntüler oluşturabiliriz. Hatırlıyorsanız komut satırının ne kadar işlevsel olabileceğinden bahsederken 1’den 100’e kadar isimlendirilmiş klasör oluşturmak için de kıvırcık parantez genişletmesini kullanmıştık.</p>

<p>Yine benzer örneği ele alabiliriz. Normalde 1’den 5’e kadar isimlendirilmiş klasörler oluşturmak için <code class="language-plaintext highlighter-rouge">mkdir 1 2 3 4 5</code> şeklinde tek tek elimizle klasör isimlerini belirtmemiz gerek. Bunun yerine aralığı kıvırcık parantez içinde <code class="language-plaintext highlighter-rouge">mkdir {1..5}</code> şeklinde yazabiliriz. Yani benim <code class="language-plaintext highlighter-rouge">mkdir 1 2 3 4 5</code> şeklinde yazmamla aslında <code class="language-plaintext highlighter-rouge">mkdir {1..5}</code> yazmam en nihayetinde <code class="language-plaintext highlighter-rouge">mkdir</code> aracı için aynı oluyor çünkü kıvırcık parantez içindeki <strong>1..5</strong> ifadesi 1’den 5’e kadar olan sayılara genişletiliyor.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/yeni klasor]
└─<span class="nv">$ </span><span class="nb">mkdir</span> <span class="o">{</span>1..5<span class="o">}</span>

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/yeni klasor]
└─<span class="nv">$ </span><span class="nb">ls
</span>1  2  3  4  5
</code></pre></div></div>

<p>Neticede işte bu yaklaşım sayesinde argüman alarak çalışan tüm araçlarda genişletme özelliklerinin nimetlerinden faydalanmamız mümkün. Örneklerimizi pek çok farklı araç üzerinde uygulayabiliriz ancak, kolayca takip edilebilir olması için konsola çıktı bastıran <code class="language-plaintext highlighter-rouge">echo</code> aracını kullanacağız. Bu sayede genişletme sonucunda üretilen tüm argümanları doğrudan konsol üzerinden çıktı olarak görebiliyor olacağız.</p>

<p>Basit bir örnekle başlayacak olursak <code class="language-plaintext highlighter-rouge">echo a{d,l,t}a</code> komutunu girebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">echo </span>a<span class="o">{</span>d,l,t<span class="o">}</span>a
ada  ala  ata
</code></pre></div></div>

<p>İşte buradaki kıvırcık parantezin içindeki virgülle ayrılmış olan karakterler, kabuk tarafından sırasıyla genişletilerek baştaki ve sonraki <strong>a</strong> karakterleri ile birleştirilip <strong>ada ala</strong> ve <strong>ata</strong> argümanlarına dönüştürüldü. <code class="language-plaintext highlighter-rouge">echo</code> aracı da bu argümanları konsolumuza bastırdı. İşte en basit hali ile genişletme dediğimiz kavram bu. Kıvırcık parantez içine virgüller ayırarak yazdığımız tüm karakterler soldan sağa doğru sırasıyla parantezin dışındaki karakterlerle birleştirilerek her biri için birer argüman üretiliyor. Yani belirttiğimiz şablona göre istediğimiz çeşitlilikte argüman üretebiliyoruz.</p>

<p>Ben yalnızca birer karakter ekledim ancak kıvırcık parantez içerisine istediğimiz uzunlukta istediğimiz kadar karakteri ekleyebiliyoruz.  Ben bu kez <code class="language-plaintext highlighter-rouge">echo a{bbb,dd,l,tttt}a</code> şeklinde komutumuzu girelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">echo </span>a<span class="o">{</span>bbb,dd,l,tttt<span class="o">}</span>a
abbba adda ala atttta
</code></pre></div></div>

<p>Bakın her koşulda parantez içinde virgülle ayırarak verdiğimiz tüm karakterler, peşi sıra kaç karakter kullanıldığına bakılmaksızın kabuk tarafından genişletiliyor. Çıktıyı incelediğimizde virgülle ayırmış olduğumuz karakterlerin tıpkı tanımlandıkları sıralamaya yani soldan sağa doğru genişletildiğini teyit edebiliyoruz. Siz de elde etmek istediğiniz argümanlar için bu sıraya dikkat ederek şablonunuzu tanımayabilirsiniz. Yalnız, bu şekilde şablon tanımı üzerinden örüntüler oluştururken boşluk karakterini kaçış karakteriyle birlikte kullanmanız gerektiğine de dikkat edin lütfen. Aksi halde kabuk genişletme uygulanamaz.</p>

<p>Boşluk karakterinin genişletmeye engel olduğunu kanıtlamak için aynı komutumuzu bu kez içinde boşluk karakteri ile tekrar girebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">echo </span>a<span class="o">{</span>b b,d,l,t<span class="o">}</span>a
a<span class="o">{</span>b b,d,l,t<span class="o">}</span>a
</code></pre></div></div>

<p>Bakın boşluk karakteri olduğu için genişletme gerçekleştirilmedi dolayısıyla köşeli parantez ve içindeki tüm karakterler olduğu gibi konsola bastırıldı. Çünkü kabuk burada bir karakter boşluk olduğunu gördüğünde burada bu boşluk karakterinin kelimeleri bölümlemek için bulunduğunu düşünüyor. Dolayısıyla genişletme yerine kelime bölümlemesi yapılıp, genişletme yapısı kabuk tarafından görmezden geliniyor. Bizim bu boşluğun bu amaçla eklenmediğini yani sıradan bir karakter olduğunu kabuğa belirtmek için özellikle kaçış karakterini kullanmanız gerekiyor. Denemek için boşluk karakterinden hemen önce kaçış karakterini ekleyelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">echo </span>a<span class="o">{</span>b<span class="se">\ </span>b,d,l,t<span class="o">}</span>a                                          
ab ba ada ala ata
</code></pre></div></div>

<p>Böylece, ne zaman bir karakterin kabuk tarafından standart olarak algılanmasını istersek kaçış karakterini tıpkı bu örneğimizde olduğu şekilde kullanabileceğimizi bir kez daha teyit etmiş olduk.</p>

<p>Tekrar kıvırcık parantez genişletmesine dönecek olursak burada biz doğrudan genişletilecek tüm karakterleri belirttik. Eğer genişletilecek karakterlerin hepsini yazmak yerine bir aralık belirtmek istersek; iki nokta yan yana olacak şekilde <code class="language-plaintext highlighter-rouge">{başlangıç..bitiş..artış_oranı}</code> yapısını da kullanabiliyoruz.</p>

<p>Ben a’dan z ye kadar olan tüm karakterleri bastırmak için <code class="language-plaintext highlighter-rouge">{a..z}</code> şeklinde komutumu giriyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">echo</span> <span class="o">{</span>a..z<span class="o">}</span>
a b c d e f g h i j k l m n o p q r s t u v w x y z
</code></pre></div></div>

<p>Bakın a’dan z’ye kadar olan tüm alfabetik karakterler sırasıyla tek tek bastırıldı. Linux üzerinde küçük büyük harf duyarlılığı olduğundan daha önce bahsetmiştik. Küçük büyük harf duyarlılığı sebebiyle eğer büyük karakterler bastırılsın istersem <code class="language-plaintext highlighter-rouge">A..Z</code> şeklinde özellikle büyük harfleri kullanmam gerekiyor.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">echo</span> <span class="o">{</span>A..Z<span class="o">}</span>                                                
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
</code></pre></div></div>

<p>Bakın A’dan Z’ye hepsi büyük harfli şekilde bastırıldı. İstersem aynı şekilde sayı aralığı da belirtebilirim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">echo</span> <span class="o">{</span>1..10<span class="o">}</span>                                                 
1 2 3 4 5 6 7 8 9 10
</code></pre></div></div>

<p>Gördüğünüz gibi tüm sayılar sırasıyla bastırıldı. Ayrıca genişletmeler sırasında üretilen örüntünün sıralı şekilde teker teker ilerlemesi de şart değil. İstersek kaçar kaçar ilerlemesi gerektiğini örüntünün sonuna iki nokta koyduktan sonra belirtebiliriz. Örneğin 1’den 20’ye kadar olan sayıların 2 şer 2 şer genişletilmesini istersek <code class="language-plaintext highlighter-rouge">{1..20..2}</code> şeklinde belirtebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">echo</span> <span class="o">{</span>1..20..2<span class="o">}</span>                                            
1 3 5 7 9 11 13 15 17 19
</code></pre></div></div>

<p>Bakın tüm sayılar birden başlayıp ikişer ikişer arttırılarak yani 1 3 5 7.. şeklinde iki sayı aralıkla genişletildi. Sayılar dışında bu aralığı harfler üzerinde de benzer şekilde kullanabiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">echo</span> <span class="o">{</span>a..z..2<span class="o">}</span>                                            
a c e g i k m o q s u w y
</code></pre></div></div>

<p>Bakın tüm harfler alfabetik olarak a’dan başlayıp ikişer sıra kaymış şekilde tek tek bastırıldı.</p>

<p>İşte sizler de bu şekilde ihtiyaçlarınıza uygun olan örüntüleri oluşturmak için kıvırcık parantez kullanabilirsiniz. Şimdiye kadar verdiğim basit örneklerden belki anlaşılamamış olabilir ancak buradaki genişletmelerin her biri ayrı ayrı birer argüman olarak genişletiliyorlar. Eğer genişletilecek argüman bir önceki argümandan ayrılmadıysa yani bitişik yazıldıysa, genişletme bu argüman da dikkate alınarak gerçekleştiriliyor.</p>

<p>Ne demek istediğimi daha net anlayabilmek için <code class="language-plaintext highlighter-rouge">echo deneme{1..5}</code> şeklinde komutumuzu girelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">echo </span>deneme<span class="o">{</span>1..5<span class="o">}</span>                                           
deneme1 deneme2 deneme3 deneme4 deneme5
</code></pre></div></div>

<p>Bakın aldığımız çıktıda deneme ifadesinin sonuna 1’den 5’a kadar rakamlar eklendi ve neticede 5 farklı argüman üretilmiş oldu. Bu çıktıyı elde ettik çünkü <strong>deneme</strong> argümanından sonra boşluk bırakmadan kıvırcık parantez içinde genişletme karakterlerini belirttik. Kabuk, girdiğimiz komutu anlamlandırmak için öncelikle boşluklarından parçalara ayırdığı için bizim <strong>girdiğimiz genişletme karakterleri</strong> ve “<strong>deneme</strong>” argümanı aynı bütünün parçaları olarak değerlendirildi. Ve genişletme karakteri de olduğu için kabuk, <code class="language-plaintext highlighter-rouge">deneme{1..5}</code> komutunun aslında <strong>deneme1 deneme2.. deneme5</strong> olarak genişletilmesi için eklendiğini anlayıp buna göre muamele etti.</p>

<p>Aynı örneği bu kez genişletme karakteri ile önceki argüman arasında bir boşluk olacak şekilde yani <code class="language-plaintext highlighter-rouge">echo deneme {1..5}</code> şeklinde girelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">echo </span>deneme <span class="o">{</span>1..5<span class="o">}</span>                                           
deneme 1 2 3 4 5
</code></pre></div></div>

<p>Bakın gördüğünüz gibi <strong>deneme</strong> ve 1’den 5’e kadar olan sayılar argüman olarak üretildi. Çünkü kabuk girmiş olduğumuz komutu boşluklarından parçalara ayırdı dolayısıyla <strong>deneme</strong> argümanını ve genişletilecek karakterleri ayrı ayrı ele aldı.</p>

<p>Bizim kabuğa verdiğimiz komutların kabuk tarafından nasıl ele alındığını aşağı yukarı bildiğimizde işte tıpkı burada olduğu gibi girdiğimiz komutların kabuk tarafında ne anlam ifade ettiğini de çok daha iyi anlayabiliyoruz. Yani daha önce açıklamış olduğumuz kabuk nasıl çalışır bölümünü gereksiz yere ele almadık. Kabuğun komutları algılayışını bildiğimizde çok daha etkili şekilde emirler verebiliyoruz.</p>

<p>Tekrar örüntü oluşturmaya dönecek olursak, farklı türde örüntüler elde etmek isterseniz birden fazla genişletme karakterini peş peşe de kullanabilirsiniz. Denemek için <code class="language-plaintext highlighter-rouge">echo {1..3}{a..c}</code> şeklinde komutumuzu girelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">echo</span> <span class="o">{</span>1..3<span class="o">}{</span>a..c<span class="o">}</span>                                            
1a 1b 1c 2a 2b 2c 3a 3b 3c
</code></pre></div></div>

<p>Bakın, iki genişletme karakteri bitişik şekilde kullanıldığı için 1’den 3’e kadar olan tüm rakamlar ve a’dan c’ye kadar olan karakterleri de içeren argümanlar üretmiş oldu. Bu örnek kabuğun genişletmeleri nasıl yaptığını gayet iyi özetliyor bence. Kabuk sırasıyla genişletme yaptığı için soldan sağa doğru genişletilecek karakterleri arıyor. En soldaki karakteri genişlettikten sonra ileride genişletilecek karakter var mı diye bakıyor. Eğer varsa bunları da genişletiyor. İşte buradaki örnekte kabuk ilk olarak 1 rakamına genişletti ve devamında ikinci genişletmeye geçip a’dan c’ye kadar olan genişletmeyi uyguladı. Daha sonra 2 rakamına genişletti ve aynı şekilde a’dan c’ye kadar olan genişletmeleri sırasıyla tek tek uyguladı. Yani genişletmenin uygulanış biçim ve sırası oldukça düzenli. Hatta bu düzeni daha net görebilmek adına bir adet daha genişletme ekleyebiliriz. Bunun için <code class="language-plaintext highlighter-rouge">echo {1..3}{a..c}{A..C}</code> komutunu girelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">echo</span> <span class="o">{</span>1..3<span class="o">}{</span>a..c<span class="o">}{</span>A..C<span class="o">}</span>
1aA 1aB 1aC 1bA 1bB 1bC 1cA 1cB 1cC 2aA 2aB 2aC 2bA 2bB 2bC 2cA 2cB 2cC 3aA 3aB 3aC 3bA 3bB 3bC 3cA 3cB 3cC
</code></pre></div></div>

<p>Çıktıları inceleyecek olursak, sırasıyla ilk genişletmenin uygulanıp sonraki genişletmenin ilk basamağının da uygulandıktan sonra bir sonraki genişletmenin uygulandığını görebiliyoruz. İlk genişletme basamağı 1 ve a olduğu için 1aA 1aB 1aC şeklinde genişletmeler uygulanmış. Geri kalan genişletmeler de benzer şekilde soldan sağa doğru adım adım uygulanmış. Aslında burada aldığımız çıktılar <code class="language-plaintext highlighter-rouge">deneme{1..5}</code> örneğini ile birebir benzer. Tek fark, biz burada birden fazla genişletme karakterini bitişik olarak kullandığımız için üretilen örüntüler de bu doğrultuda çok çeşitli oldu. Yoksa tüm işleyiş aynı.</p>

<p>Belki bu noktada aldığımız çıktılar sizlere biraz karmaşık gelmiş olabilir, ancak merak etmeyin aslında son derece kolay. Tek yapmanız gereken çıktıları biraz dikkatlice izleyip, genişletmelerin soldan sağa doğru adım adım gerçekleştirildiğini fark etmektir. <strong>Ayrıca zaten genelde bu örneklerdeki gibi karmaşık veya anlamsız örüntüler oluşturmanız da gerekmeyecek.</strong> Ben sadece örüntü oluşturmanın temel yapısından bahsetmek için bu şekilde örnekler veriyorum. Kendiniz de farklı örnekler üzerinden farklı desenler üreterek genişletmenin tam olarak nasıl çalıştığını rahatlıkla kavrayabilirsiniz. Örneğin bu son girdiğim komutta genişletme karakteri arasında boşluk bırakırsam, genişletmeler birbirinden bağımsız olacağı için ayrı ayrı sıralı çıktıları alacağız.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">echo</span> <span class="o">{</span>1..3<span class="o">}</span> <span class="o">{</span>a..c<span class="o">}</span> <span class="o">{</span>A..C<span class="o">}</span>                                    
1 2 3 a b c A B C
</code></pre></div></div>

<p>Bakın boşluk bırakınca, genişletmeler birbirinden bağımsız olduğu için argümanlarda birbirinden bağımsız oldu.</p>

<p>Neticede kıvırcık parantez genişletmeleri sayesinde çok çeşitli argüman örüntüleri oluşturabileceğimizi <code class="language-plaintext highlighter-rouge">echo</code> komutu üzerinden ele aldık. <code class="language-plaintext highlighter-rouge">echo</code> komutu üretilen argümanları gözlemleyebilmemiz için harika olsa da ben basit bir gerçek dünya örneği de vermek istiyorum.</p>

<p>Örneğin diyelim ki kendi ev dizininiz içindeki <strong><em>Desktop</em></strong> klasörü altında birbirinden farklı isimlerde yeni 5 tane klasör oluşturmak istiyorsunuz. Bunun için ne yapabilirsiniz ? Örneğin komutunuzu <code class="language-plaintext highlighter-rouge">mkdir ~/Desktop/bir ~/Desktop/iki ~/Desktop/uc</code> ve benzeri şeklinde uzun uzadıya girebilirsiniz. Ama buna gerek yok çünkü artık siz genişletmeden yararlanıp örüntü oluşturmayı biliyorsunuz. Yani tüm komutu tekrar tekrar yazmak yerine isterseniz kıvırcık parantez genişletmesi ile <code class="language-plaintext highlighter-rouge">mkdir ~/Desktop/{bir,iki,uc,dort,bes}</code> şeklinde tek seferde istediğiniz isimlerde klasörlerin oluşturmasın da sağlayabilirsiniz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">mkdir</span> ~/Desktop/<span class="o">{</span>bir,iki,uc,dort,bes<span class="o">}</span>                    

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/yeni klasor]
└─<span class="nv">$ </span><span class="nb">ls</span> ~/Desktop/                        
bes  bir  dort  iki  test.txt  uc  yeni-dizin
</code></pre></div></div>

<p>Bakın tek bir komutla istediğim örüntüye uyulması sayesinde birden fazla klasörü kolayca oluşturabildim. İşte bu ve bunun gibi sizlere pratiklik sağlayacak durumlarda kıvırcık parantez genişletmesini kullanabilirsiniz.</p>

<h1 id="dosya-i̇smi-genişletme">Dosya İsmi Genişletme</h1>

<p>Bash kabuğu girmiş olduğumuz her bir argümana bakıp ‘*’, ‘<strong>?</strong>’ ve ‘<strong>[</strong>’ karakterleri var mı diye kontrol ediyor. Bu karakterlerden biri görünüyorsa, bu argüman bir <strong>dosya ismi genişletmesi</strong> kalıbı olarak kabul ediliyor ve kalıpla eşleşen dosya ve klasör isimleri alfabetik olarak genişletiliyor. Yani dosya ismi genişletmesi aslında <strong>var olan dosya ve klasör isimleri ile eşleşecek kalıplar</strong> oluşturmamızı sağlıyor. Örneğin a ile başlayan veya .txt ile biten tüm dosya ve klasörler gibi özel karakter kalıpları belirtip var olan dosya ve dizinlerin bu kalıba göre filtrelenmesini sağlayabiliyoruz.</p>

<p>Bash kabuğuna dosya ismi genişletmesini belirtmek için başta da söylediğim gibi “yıldız”, “soru işareti” ve “köşeli parantez” joker karakterinden uygun olan bir karakteri kullanmamız gerekiyor. Fark ettiyseniz kabuk için özel anlam ifade eden bu karakterlere “<strong>joker karakterler</strong>” dedim. Buradaki <strong>joker karakter</strong> ifadesi önemli çünkü isminden de anlaşılabileceği gibi bu karakterler herhangi bir karakter ile eşleşebildikleri için bu isme sahipler. Türkçe “joker karakterler” olarak ifade ettiğim bu karakterlere İngilizce “wildcards” olarak geçiyor.</p>

<p>“wildcards” ifadesine, komut satırı üzerindeki çeşitli araçları kullanırken veya harici olarak İngilizce yardım sayfalarında sıklıkla rast geliyor olacağımız için joker karakterin wildcards olarak geçtiğini bilmeniz önemli. Örneğin kullanacağınız bir araç, bu “yıldız” “soru işareti” ve “köşeli parantez” karakterlerini özel anlamları ile ele almak için sizden wildcards seçeneğiyle bunu özellikle belirtmenizi bekleyebilir. Özellikle belirtmediğiniz durumda size hata çıktısında “wildcards kullanmalısınız” diye uyarı verebilir. Şimdi kısaca bu joker karakterlerin kabuk için ifade ettiği anlamalara değinecek olursak;</p>

<p><strong>Yıldız karakteri:</strong> sıfır veya sıfırdan daha fazla sayıda herhangi bir karakter ile eşleşebiliyor.</p>

<p><strong>Soru işareti:</strong> tam olarak yalnızca herhangi bir tek karakterle eşleşiyor.</p>

<p><strong>Köşeli parantez:</strong> ise köşeli parantez içinde belirten herhangi bir karakter ile eşleşebiliyor.</p>

<p>Bu joker karakterlerin kullanımlarına tek tek değineceğiz ancak ilk olarak dikkatinizi çekmek istediğim nokta bu karakterlerin <strong>yalnızca var olan dosya ve klasör isimlerine genişletilmek için</strong> kullanılabildikleridir. <strong>Yeni dosya veya klasör oluşturmak gibi işlerde kullanamayız.</strong> Çünkü var olan dosya ve klasörler içerisinden bizim belirttiğimiz kalıba uyan isimleri argüman olarak genişletmek için varlar. Zaten bu karakterler “pattern matching” yani “desen eşleştirme” karakteri olarak da geçiyor. Yani var olan dosya dizin isimleri ile eşleşecek karakter desenleri oluşturmamızı sağlıyorlar.</p>

<p>Teorik açıklamanın anlamalı hale gelmesi için tabii ki örnekler yapmamız gerekiyor. Örnekler yapmak için öncelikle <strong><em>/etc</em></strong> dizinine geçiş yapalım. <strong><em>etc</em></strong> dizini altında pek çok farklı dosya ve klasör bulunduğu için örnekler sırasında alıştırmalar yapabileceğimiz çeşitlilikte dosya ve klasör ismi mevcut.</p>

<p>Daha önce süslü parantez genişletmesinde olduğu gibi bu genişletmelerin sonuçlarını rahat gözlemleyebilmek adına yine <code class="language-plaintext highlighter-rouge">echo</code> komutunu kullanabiliriz.</p>

<h3 id="yıldız-karakteri">Yıldız Karakteri</h3>

<p>Eğer <code class="language-plaintext highlighter-rouge">echo</code> komutumun ardından <strong>yıldız joker karakterini</strong> eklersem, bu var olan tüm dosya ve klasörlerin bastırılması demek oluyor.</p>

<p>Hemen denemek için echo * komutunu girelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[/etc]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="k">*</span>
adduser.conf adjtime alsa alternatives apache2 apparmor apparmor.d apt avahi bash.bashrc bash.bashrc.save bash.bashrc.save.1 bash_completion bash_completion.d bindresvport.blacklist binfmt.d bluetooth ca-certificates ca-certificates.conf chatscripts cifs-utils cloud console-setup cron.d cron.daily cron.hourly cron.monthly crontab cron.weekly cryptsetup-initramfs cryptsetup-nuke-password crypttab dbus-1 dconf debconf.conf debian_version debtags default deluser.conf dhcp dictionaries-common dns2tcpd.conf dpkg e2scrub.conf emacs environment environment.d ethertypes ettercap firebird firefox-esr fonts freetds fstab fuse.conf gai.conf geoclue ghostscript glvnd gprofng.rc groff group group- grub.d gshadow gshadow- gss gtk-2.0 gtk-3.0 guymager hdparm.conf host.conf <span class="nb">hostname </span>hosts hosts.allow hosts.deny idmapd.conf ifplugd ImageMagick-6 inetsim init.d initramfs-tools inputrc insserv.conf.d ipp-usb iproute2 ipsec.conf ipsec.d ipsec.secrets issue issue.net java-11-openjdk john kernel kernel-img.conf king-phisher kismet ld.so.cache ld.so.conf ld.so.conf.d libao.conf libaudit.conf libblockdev libnl-3 libpaper.d lightdm lighttpd locale.alias locale.gen localtime logcheck login.defs logrotate.conf logrotate.d macchanger machine-id magic magic.mime mailcap mailcap.order manpath.config matplotlibrc mime.types minicom miredo miredo.conf mke2fs.conf ModemManager modprobe.d modules modules-load.d motd mtab mysql nanorc netconfig netsniff-ng network NetworkManager networks nftables.conf nginx nikto.conf nsswitch.conf ODBCDataSources odbc.ini odbcinst.ini openal OpenCL openfortivpn openni2 openvpn opt os-release pam.conf pam.d papersize passwd passwd- perl php plymouth polkit-1 postgresql postgresql-common powershell-empire ppp profile profile.d protocols proxychains4.conf pulse python2.7 python3 python3.10 python3.9 rarfiles.lst rc0.d rc1.d rc2.d rc3.d rc4.d rc5.d rc6.d rcS.d rearj.cfg redsocks.conf request-key.conf request-key.d resolv.conf responder rmt rpc rsyslog.conf rsyslog.d runit samba sane.d scalpel screenrc sddm.conf.d searchsploit_rc security selinux sensors3.conf sensors.d services shadow shadow- shells skel smartd.conf smartmontools smi.conf snmp speech-dispatcher sqlmap ssh ssl sslsplit strongswan.conf strongswan.d stunnel subgid subgid- subuid subuid- subversion sudo.conf sudoers sudoers.d sudoers.save sudo_logsrvd.conf sv sysctl.conf sysctl.d sysstat systemd terminfo theHarvester tightvncserver.conf timezone timidity tmpfiles.d ucf.conf udev udisks2 ufw updatedb.conf update-motd.d UPower vdpau_wrapper.cfg vim vpnc vulkan wgetrc wireshark wpa_supplicant X11 xattr.conf xdg xfce4 xl2tpd zsh zsh_command_not_found
</code></pre></div></div>

<p>Bakın tıpkı <code class="language-plaintext highlighter-rouge">ls</code> çıktısında olduğu gibi mevcut dizindeki tüm dosya ve klasörlerin isimleri konsola bastırıldı. Tabii ki <code class="language-plaintext highlighter-rouge">ls</code> komutunda olduğu gibi renkli ve düzenli bir çıktı olmadı ancak gizli dosya ve dizinler hariç tüm içerikler <code class="language-plaintext highlighter-rouge">echo</code> komutuna argüman olarak iletildiği için <code class="language-plaintext highlighter-rouge">echo</code> komutu tarafından konsola batırıldı.</p>

<p>Belirttiğim gibi yıldız işareti tüm dosyaları ve klasörleri kapsıyor olsa da gizli dosya ve klasörleri kapsamıyor. Yani başında nokta işareti ile gizlenmiş olan dosya ve klasörlerin isimlerini yıldız genişletme karakterini kapsamıyor. Gizli olanları özellikle kapsaması için yıldız işaretinden önce nokta karakterini de ekleyip gizli isimleri özellikle kapsayabiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[/etc]
└─<span class="nv">$ </span><span class="nb">echo</span> .<span class="k">*</span>                                                      
<span class="nb">.</span> .. .java .pwd.lock
</code></pre></div></div>

<p>Ben bu girmiş olduğum komutta; yıldız karakterinden önce nokta işaretini koyduğum için başlangıcı nokta olan ve devamında herhangi bir karakter olan tüm dosya ve dizinlerin kapsanması sağlanıyor. Benim çalıştığım <strong><em>etc</em></strong> dizini altında da bu biçimde olan yani gizli olan içerikler bunlarmış.</p>

<p>Ayrıca bu aldığımız çıktılarda yer alan tek nokta <code class="language-plaintext highlighter-rouge">.</code> mevcut dizini temsil ediyorken, iki nokta <code class="language-plaintext highlighter-rouge">..</code> da bir üst dizini temsil eden klasörler. Örneğin biz <code class="language-plaintext highlighter-rouge">cd ..</code> şeklinde komut girip bir üst dizine dönerken, aslında üst dizini temsil eden bu iki nokta klasörüne geçiş yaptığımız için bir üst dizine dönebiliyorduk. Veya daha önce betik dosyalarımızı çalıştırırken de gördüğümüz gibi bir dosyaya çalıştırırken <code class="language-plaintext highlighter-rouge">./dosya-ismi</code> şeklinde komut girdiğimizde de mevcut dizini temsil eden bu dizin sayesinde bu dosya kabuk tarafından çalıştırılabiliyordu. Nokta işareti kabuğa bu dizinin tam adresini verdiği için mevcut dizin içinde olan dosyanın tam konumunu kolayca belirtebiliyorduk.</p>

<p>Her neyse bakın başında nokta bulunan dosya ve klasör isimlerini kapsayabilmek için nokta ve yıldız karakterlerini bir arada kullandık. Bu kullandığımız karakterler de mevcut bulunduğumuz dizinde yer alan bu dosya ve klasörlerin isimlerine genişletilip <code class="language-plaintext highlighter-rouge">echo</code> aracına argüman olarak verildi, dolayısıyla konsolumuza bu çıktıları bastırabildik.</p>

<p>Normalde yıldız işaretinin gizli içerikleri kapsamıyor olmasının nedeni farkında olmadan önemli dosyalar üzerinde yanlış işlem yapmamızı önlemektir. Zaten klasör veya dosyaların gizli olmasının amacı göz önünden uzak tutularak korunmalarını sağlamak. Bash kabuğunun joker karakteri olan yıldız işareti her şeyi kapsamasına rağmen gizli dosya ve klasörleri bilerek dışarıda tutuyor.</p>

<p>Tamamdır, temel olgulardan da bahsettiğimize göre şimdi yıldız joker karakterini ihtiyacımıza göre nasıl kullanabileceğimize dair birkaç farklı örnek uygulama yapabiliriz.</p>

<p>Gizli içerikleri görmek için başı nokta ile başlayanları listeledik. Nokra yerine dilediğimiz herhangi bir karakteri de belirtebilirdik. Hatta dilersek tersi şekilde sonu belirli bir karakter veya karakterler ile bitenleri de listeleyebiliriz. Örneğin ben sonu “<strong>i”</strong> ile biten her şeyi bastırmak istersem <code class="language-plaintext highlighter-rouge">echo *i</code> şeklinde komutumu kullanabilirim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[/etc]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="k">*</span>i
avahi odbc.ini odbcinst.ini
</code></pre></div></div>

<p>Bakın buradaki tüm dosya ve dizin isimlerinin sonunda “i” harfi var.</p>

<p>Benzer şekilde birden fazla karakteri de spesifik olarak belirtebiliriz. Örneğin sonu “<strong>.d”</strong> ile biten içerikleri bastırmak için de benzer şekilde <code class="language-plaintext highlighter-rouge">echo *.d</code> komutunu girebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">echo</span> <span class="k">*</span>.d
apparmor.d bash_completion.d binfmt.d cron.d environment.d grub.d init.d insserv.conf.d ipsec.d ld.so.conf.d libpaper.d logrotate.d modprobe.d modules-load.d pam.d profile.d rc0.d rc1.d rc2.d rc3.d rc4.d rc5.d rc6.d rcS.d request-key.d rsyslog.d sane.d sddm.conf.d sensors.d strongswan.d sudoers.d sysctl.d tmpfiles.d update-motd.d
</code></pre></div></div>

<p>Bakın yalnızca sonu “<strong>.d”</strong> ile bitenler listelenmiş oldu.</p>

<p>Görebildiğiniz gibi kullanımı son derece kolay. Spesifik olarak eşleşmesini istediğim bir veya birden fazla karakter varsa onları komutumda uygun şekilde belirttiğim sürece dosya ve dizin isimleri içinden tam olarak aradığım isimlerdekilere genişletiliyor.</p>

<p>Ben yine örnek olması için başlangıcı “<strong>in</strong>” ile başlayan tüm dosya ve dizin isimlerinin genişletilerek <code class="language-plaintext highlighter-rouge">echo</code> aracına iletilmesini istiyorum. Bunun için <code class="language-plaintext highlighter-rouge">echo in*</code> komutunu girebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[/etc]
└─<span class="nv">$ </span><span class="nb">echo </span><span class="k">in*</span>
inetsim init.d initramfs-tools inputrc insserv.conf.d
</code></pre></div></div>

<p>Bakın başlangıcı “<strong>in</strong>” olan tüm dosya veya klasör isimleri karakter uzunlukları fark etmeksizin bastırılmış oldu.</p>

<p>Başlangıç veya son yerine eğer herhangi bir yerinde “<strong>in</strong>” karakteri geçen tüm içerikleri bastırmak istersem <code class="language-plaintext highlighter-rouge">echo *in*</code> komutunu kullanabilirim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[/etc]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="k">*in*</span>                                                    
bindresvport.blacklist binfmt.d cryptsetup-initramfs inetsim init.d initramfs-tools inputrc insserv.conf.d king-phisher login.defs machine-id minicom nginx odbc.ini odbcinst.ini proxychains4.conf selinux terminfo
</code></pre></div></div>

<p>Bakın bu girdiğimiz genişletme tanımı sayesinde dosya veya klasör isimlerinin herhangi bir yerinde “in” geçen tüm içerikler bastırılmış oldu. Yıldız işareti sıfır veya herhangi bir karakter anlamın geldiği için bu kadar geniş bir eşleşeme imkanı sağlamış oldu. Yani biz bu genişletme karakteri tanımı ile, başlangıcında sıfır veya sıfırdan başka herhangi bir uzunlukta karakter olan daha sonra “in” karakterinin geçtiği ve yine sonunda sıfır veya sıfırdan başka herhangi bir uzunlukta karakter olan tüm dosya ve dizin isimlerinin genişletilmesini sağladık. Bu sayede başında sonunda veya ortasında “<strong>in</strong>” ifadesi geçen tüm içerikler de bastırıldı.</p>

<p>İşte sizler de sıfır veya daha fazla sayıda herhangi bir karakter ile eşleşecek bir düzende dosya veya dizin ismi genişletmesi yapılsın istiyorsanız yıldız joker karakterini uygun biçimde, genişletmenin başında sonunda veya her ikisinde de birden ihtiyacınıza uygun şekilde kullanabilirsiniz.</p>

<h3 id="soru-i̇şareti">Soru İşareti</h3>

<p>Daha önce soru işareti karakterinin herhangi bir tek karakter yerine geçtiğini belirtmiştik. Burada dikkat etmeniz gereken detay soru işareti joker karakterinin sıfır değil her zaman <strong>tam olarak tek bir</strong> karakteri temsil ettiği.</p>

<p>Örneğin ben başlangıcı “<strong>ss</strong>” olan ancak devamındaki karakterin herhangi bir karakter olduğu dosya ve klasörleri <code class="language-plaintext highlighter-rouge">echo</code> aracına argüman olarak vermek istiyorum. Bunun için <code class="language-plaintext highlighter-rouge">echo ss?</code> komutunu girmem yeterli.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[/etc]
└─<span class="nv">$ </span><span class="nb">echo </span>ss?                                                     
ssh ssl
</code></pre></div></div>

<p>Bakın “<strong>ss</strong>h” ve “<strong>ss</strong>l” çıktılarını aldım. Bu çıktılarda yalnızca başlangıcı “<strong>ss</strong>” olan ve sonundaki tek bir karakteri herhangi bir karakter olan dosya ve klasörler yer alıyor. Yani fark ettiyseniz soru işareti yalnızca tek bir karakteri kapsıyor.</p>

<p>Hatta bu durumu teyit etmek için bir veya birden fazla kez soru işareti kullandığımızda ne olacağına göz atabiliriz. Ben örnek için öncelikle echo s? şeklinde yazıyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[/etc]
└─<span class="nv">$ </span><span class="nb">echo </span>s?                                                     
sv
</code></pre></div></div>

<p>Bakın tek bir karakter ile eşleştirildiği için ben “<strong>s</strong>v” çıktısını aldım. Şimdi bir de komutumuzu <code class="language-plaintext highlighter-rouge">echo s??</code> şeklinde tekrar girelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[/etc]
└─<span class="nv">$ </span><span class="nb">echo </span>s??                                                     
ssh ssl
</code></pre></div></div>

<p>Bakın bu kez “sv” çıktısı yok, onun yerine “s” karakterinden sonra herhangi iki karakter bulunan “ssh” ve “ssl” çıktılarını almış olduk. Yani bakın kaç tane soru işareti varsa yalnızca o sayı adedince karakter ile eşleşme yapılıyor. Ayrıca dikkat ettiyseniz daha önce de söylediğim gibi soru işareti karakteri 0 karakter ile eşleşme yapmıyor. Eğer soru işareti sıfır karakteri de kapsıyor olsaydı “sv” çıktısını da yine almamız gerekiyordu. Çünkü ben çift soru işareti kullandığımda ilk soru işareti “sv” için “v” karakterini tamamladıktan sonra “sv” isminin devamında başka bir karakter olmadığı için yani sıfır karakter bulunduğu için ikinci soru işareti sıfır karakteri kapsayıp bize “sv” çıktısını vermeliydi. Ancak soru işareti sıfırdan farklı yalnızca tek bir karakteri kapsıyor. İşte siz de dilediğiniz <strong>tek bir karakteri</strong> kapsaması için istediğiniz gibi <strong>soru işaretini</strong> kullanabilirsiniz. Örneğin isim ortasında kullanımına dair bir örnek olması için <code class="language-plaintext highlighter-rouge">echo rc?.d</code> komutu ile farklı rakamlarla temsil edilen klasörleri konsola bastırabiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[/etc]
└─<span class="nv">$ </span><span class="nb">echo </span>rc?.d
rc0.d rc1.d rc2.d rc3.d rc4.d rc5.d rc6.d rcS.d
</code></pre></div></div>

<p>Bakın buradaki soru işareti rakamların ve “S” karakterinin yerini alıp bize bu klasörlerin isimlerini verdi. Bir diğer örnek olarak üç karakterden oluşan tüm içerikleri listelemek için <code class="language-plaintext highlighter-rouge">echo ???</code> komutumuzu girebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[/etc]
└─<span class="nv">$ </span><span class="nb">echo</span> ???
apt gss opt php ppp rmt rpc ssh ssl ufw vim X11 xdg zsh
</code></pre></div></div>

<p>Bakın tam olarak isminde 3 karakter bulunan içerikler konsolumuza bastırılmış oldu.</p>

<p>Yani özetle tekrar tekrar teyit ettiğimiz gibi buradaki soru işareti mutlaka tek bir karakter ile eşleşecek şekilde genişletiliyor. Kaç tane soru işareti kullanıldıysa o kadar sayıda herhangi bir karakter ile eşleşme sağlanabiliyor.</p>

<h3 id="köşeli-parantez">Köşeli Parantez</h3>

<p>Köşeli parantez içerisine yazdığımız karakterler soldan sağa doğru genişletiliyor. Örneğin başlangıcında <strong>a c z</strong> ve <strong>d</strong> karakterlerinden herhangi biri olan tüm içerikleri bastırmak istersem komutumu <code class="language-plaintext highlighter-rouge">echo [aczd]*</code> şeklinde girebilirim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[/etc]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="o">[</span>aczd]<span class="k">*</span>
adduser.conf adjtime alsa alternatives apache2 apparmor apparmor.d apt avahi ca-certificates ca-certificates.conf chatscripts cifs-utils cloud console-setup cron.d cron.daily cron.hourly cron.monthly crontab cron.weekly cryptsetup-initramfs cryptsetup-nuke-password crypttab dbus-1 dconf debconf.conf debian_version debtags default deluser.conf dhcp dictionaries-common dns2tcpd.conf dpkg zsh zsh_command_not_found
</code></pre></div></div>

<p>Bu komut sayesinde köşeli parantez içindeki tüm karakterler soldan sağa doğru tek tek genişletiliyor ve yıldız karakteri sayesinde de devamında herhangi bir uzunlukta karakterler olan tüm dosya ve dizineler kapsanmış oluyor. Yani neticede köşeli parantez içinde belirttiğimiz karakterlerden biri ile başlayan tüm içerikler bastırılıyor.</p>

<p>Eğer burada olduğu şekilde tek tek spesifik olarak karakterleri girmek yerine aralık belirtmek istersek tire işaretini kullanabiliriz. Örneğin a’da d’ye tüm karakteri kapsamak için [a-d] şeklinde komut girebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[/etc]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="o">[</span>a-d]<span class="k">*</span>                                                
adduser.conf adjtime alsa alternatives apache2 apparmor apparmor.d apt avahi bash.bashrc bash.bashrc.save bash.bashrc.save.1 bash_completion bash_completion.d bindresvport.blacklist binfmt.d bluetooth ca-certificates ca-certificates.conf chatscripts cifs-utils cloud console-setup cron.d cron.daily cron.hourly cron.monthly crontab cron.weekly cryptsetup-initramfs cryptsetup-nuke-password crypttab dbus-1 dconf debconf.conf debian_version debtags default deluser.conf dhcp dictionaries-common dns2tcpd.conf dpkg
</code></pre></div></div>

<p>Bakın başlangıç harfi a’dan d’ye kadar olan yani <strong>a b c d</strong> karakterlerinden biri ile başlayan tüm dosya ve dizinler konsola bastırıldı.</p>

<p>Benzer şekilde sayılar için de aralık belirtebiliriz. Örneğin ben isminde 1’den 5’e kadar olan rakamlardan birini barındıran tüm dosya ve klasörleri listelemek istersem komutumu <code class="language-plaintext highlighter-rouge">echo *[1-5]*</code> şeklinde girebilirim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[/etc]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="k">*</span><span class="o">[</span>1-5]<span class="k">*</span>                                                 
apache2 bash.bashrc.save.1 dbus-1 dns2tcpd.conf e2scrub.conf gtk-2.0 gtk-3.0 iproute2 java-11-openjdk libnl-3 mke2fs.conf openni2 polkit-1 proxychains4.conf python2.7 python3 python3.10 python3.9 rc1.d rc2.d rc3.d rc4.d rc5.d sensors3.conf udisks2 X11 xfce4 xl2tpd
</code></pre></div></div>

<p>Bakın isminin herhangi bir yerinde 1’den 5’e kadar olan rakamlardan birini barından tüm dosya ve klasörler listelendi. Yani sayısal olarak aralık belirtebildiğimizi de bu örnekle teyit etmiş olduk.</p>

<p>Ayrıca birkaç örnektir bizzat yaptığımız gibi farkındaysanız genişletme karakterlerini bir arada kullanabiliyoruz. Yani ben burada köşeli parantez genişletmesiyle birlikte yıldız joker karakterini de kullanıp istediğim dosya ve dizin isimlerini elde ettim. Benzer şekilde tabii ki soru işaretini de dilediğiniz gibi yıldız veya köşeli parantez genişletmesiyle birlikte kullanabilirsiniz. Mesela <code class="language-plaintext highlighter-rouge">echo [a-l]??</code> şeklinde komutumuzu girersek, buradaki köşeli parantez genişletmesi a’dan l’ye kadar olan karakterlerin hepsini kapsayacak, buradaki çift soru işareti de bu a’dan l’ye kadar olan karakterlerle başlayan ve devamında <strong>tam olarak iki tane rastgele karakter</strong> bulunduran dosya ve klasör isimlerine genişletmeyi sağlayacak.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[/etc]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="o">[</span>a-l]??
apt gss
</code></pre></div></div>

<p>Bakın başlangıç harfi a’dan l’ye kadar olan karakteri kapsarken, bu karakterin devamında soru işaretleri sayesinde tam olarak 2 rastgele karakter bulunuyor. İşte tıpkı bu örneğimizde olduğu gibi joker karakterleri, ihtiyaç duyduğunuz çözüm için istediğiniz gibi düzenleyip tanımlayabilirsiniz.</p>

<p>Bölüm sonunda bu karakterlerin bir arada kullanımını daha net anlayabilmek için zaten sizlere birkaç alıştırma bırakmış olacağım. Şimdi tekrar köşeli parantez genişletmesine dönecek olursak.</p>

<p>Linux üzerinde küçük büyük harf duyarlılığı olduğundan daha önce bahsetmiştik. Bu doğrultuda eğer genişletilecek dosya veya klasör ismi olarak büyük harfleri belirtmek istiyorsak özellikle büyük harfleri yazmamız gerekiyor. Örneğin büyük N ile başlayan içerikleri listelemek için komutumu <code class="language-plaintext highlighter-rouge">echo N*</code> şeklinde girmem gerekir.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[/etc]
└─<span class="nv">$ </span><span class="nb">echo </span>N<span class="k">*</span>
NetworkManager
</code></pre></div></div>

<p>Bakın bende bir tane isim eşleşmesi var ve gördüğünüz gibi isim başlangıcındaki karakter de büyük harfli. Bu dizinde başlangıç harfi büyük olan tüm içerikleri öğrenmek istersem <code class="language-plaintext highlighter-rouge">echo [A-Z]*</code> şeklinde büyük karakterlerle aralık da belirtebilirim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[/etc]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="o">[</span>A-Z]<span class="k">*</span>                                                
ImageMagick-6 ModemManager NetworkManager ODBCDataSources OpenCL UPower X11
</code></pre></div></div>

<p>Bakın başlangıç karakteri büyük olan tüm içerikler listelendi.</p>

<p>Hatta eğer <code class="language-plaintext highlighter-rouge">echo [A-z]*</code> şeklinde belirtirsek büyük küçük harfler de dahil başlangıcında a’dan z’ye kadar olan büyük küçük herhangi bir karakter bulunan tüm içerikler listelenecektir.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[/etc]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="o">[</span>A-z]<span class="k">*</span>                                                
adduser.conf adjtime alsa alternatives apache2 apparmor apparmor.d apt avahi bash.bashrc bash.bashrc.save bash.bashrc.save.1 bash_completion bash_completion.d bindresvport.blacklist binfmt.d bluetooth ca-certificates ca-certificates.conf chatscripts cifs-utils cloud console-setup cron.d cron.daily cron.hourly cron.monthly crontab cron.weekly cryptsetup-initramfs cryptsetup-nuke-password crypttab dbus-1 dconf debconf.conf debian_version debtags default deluser.conf dhcp dictionaries-common dns2tcpd.conf dpkg e2scrub.conf emacs environment environment.d ethertypes ettercap firebird firefox-esr fonts freetds fstab fuse.conf gai.conf geoclue ghostscript glvnd groff group group- grub.d gshadow gshadow- gss gtk-2.0 gtk-3.0 guymager hdparm.conf host.conf <span class="nb">hostname </span>hosts hosts.allow hosts.deny idmapd.conf ifplugd ImageMagick-6 inetsim init.d initramfs-tools inputrc insserv.conf.d ipp-usb iproute2 ipsec.conf ipsec.d ipsec.secrets issue issue.net java-11-openjdk john kernel kernel-img.conf king-phisher kismet ld.so.cache ld.so.conf ld.so.conf.d libao.conf libaudit.conf libblockdev libnl-3 libpaper.d lightdm lighttpd locale.alias locale.gen localtime logcheck login.defs logrotate.conf logrotate.d macchanger machine-id magic magic.mime mailcap mailcap.order manpath.config matplotlibrc mime.types minicom miredo miredo.conf mke2fs.conf ModemManager modprobe.d modules modules-load.d motd mtab mysql nanorc netconfig netsniff-ng network NetworkManager networks nftables.conf nginx nikto.conf nsswitch.conf ODBCDataSources odbc.ini odbcinst.ini openal OpenCL openfortivpn openni2 openvpn opt os-release pam.conf pam.d papersize passwd passwd- perl php plymouth polkit-1 postgresql postgresql-common powershell-empire ppp profile profile.d protocols proxychains4.conf pulse python2.7 python3 python3.10 python3.9 rc0.d rc1.d rc2.d rc3.d rc4.d rc5.d rc6.d rcS.d rearj.cfg redsocks.conf request-key.conf request-key.d resolv.conf responder rmt rpc rsyslog.conf rsyslog.d runit samba sane.d scalpel screenrc sddm.conf.d searchsploit_rc security selinux sensors3.conf sensors.d services shadow shadow- shells skel smartd.conf smartmontools smi.conf snmp speech-dispatcher sqlmap ssh ssl sslsplit strongswan.conf strongswan.d stunnel subgid subgid- subuid subuid- subversion sudo.conf sudoers sudoers.d sudo_logsrvd.conf sv sysctl.conf sysctl.d sysstat systemd terminfo theHarvester tightvncserver.conf timezone timidity tmpfiles.d ucf.conf udev udisks2 ufw updatedb.conf update-motd.d UPower vdpau_wrapper.cfg vim vpnc vulkan wgetrc wireshark wpa_supplicant X11 xattr.conf xdg xfce4 xl2tpd zsh zsh_command_not_found
</code></pre></div></div>

<p>Bakın tam da söylediğim gibi, belirttiğimiz bu aralık sayesinde başlangıç karakterinde küçük büyük harf olması fark etmeksizin tüm içerikler listelendi.</p>

<p>Ben örnek olarak hep başlangıçtaki karakterler üzerinden çalıştım ancak siz yıldız işaretinin ve soru işaretinin işlevini öğrendiğiniz için istediğiniz şekilde çıktıları sınırlayabilirsiniz. Genişletme karakterlerini istediğiniz sonuçları elde etmek için özelleştirebileceğiniz kadar detay öğrendik. Zaten temel dosya ismi genişletmeleri için 3 joker karakter(<code class="language-plaintext highlighter-rouge">*</code>,<code class="language-plaintext highlighter-rouge">?</code>,<code class="language-plaintext highlighter-rouge">[]</code>) kullanıyoruz hepsi bu.</p>

<h3 id="hariç-tutmak">Hariç Tutmak</h3>

<p>Biz şu ana kadar hep belirttiğimiz karakterler ile eşleşecek şekilde komut girdik. Dilersek köşeli parantez genişletmesini kullanırken, belirttiğimiz karakterler dışındakileri kapsayacak şekilde de komut girebiliriz. Yani hariç tutulacak karakterleri özellikle belirtip, geri kalan karakteri barındıran dosya ve dizinlerin genişletilmesini sağlayabiliriz. Bunun için tek yapmamız gereken ünlem <code class="language-plaintext highlighter-rouge">!</code> işaretini kullanmak. Örneğin başlangıcında a’dan y’ye kadar olan herhangi bir karakter geçmeyen içerikleri bastırmak istersek komutumuzu <code class="language-plaintext highlighter-rouge">echo [!a-y]*</code>  şeklinde girebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[/etc]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="o">[!</span>a-y]<span class="k">*</span>                                                 
ImageMagick-6 ModemManager NetworkManager ODBCDataSources OpenCL UPower X11 zsh zsh_command_not_found
</code></pre></div></div>

<p>Bakın belirttiğim karakterler hariç tüm eşleşenler bastırıldı. <strong>z</strong> karakterinden hemen önce <strong>y</strong> geldiği için aslında ben girdiğim bu genişletme tanımı ile <strong>z</strong> karakteri ve büyük karakterlerle başlayanları bastır demiş oldum. Çünkü küçük harflerle a’dan y’ye kadar olan tüm karakterlerle başlayanları elediğimde geriye bunlar kalıyor. Emin olmak için ünlem işaretini kaldırıp komutumuzu tekrar girebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[/etc]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="o">[!</span>a-y]<span class="k">*</span>                                                 
ImageMagick-6 ModemManager NetworkManager ODBCDataSources OpenCL UPower X11 zsh zsh_command_not_found

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[/etc]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="o">[</span>a-y]<span class="k">*</span>                                                 
adduser.conf adjtime alsa alternatives apache2 apparmor apparmor.d apt avahi bash.bashrc bash.bashrc.save bash.bashrc.save.1 bash_completion bash_completion.d bindresvport.blacklist binfmt.d bluetooth ca-certificates ca-certificates.conf chatscripts cifs-utils cloud console-setup cron.d cron.daily cron.hourly cron.monthly crontab cron.weekly cryptsetup-initramfs cryptsetup-nuke-password crypttab dbus-1 dconf debconf.conf debian_version debtags default deluser.conf dhcp dictionaries-common dns2tcpd.conf dpkg e2scrub.conf emacs environment environment.d ethertypes ettercap firebird firefox-esr fonts freetds fstab fuse.conf gai.conf geoclue ghostscript glvnd gprofng.rc groff group group- grub.d gshadow gshadow- gss gtk-2.0 gtk-3.0 guymager hdparm.conf host.conf <span class="nb">hostname </span>hosts hosts.allow hosts.deny idmapd.conf ifplugd inetsim init.d initramfs-tools inputrc insserv.conf.d ipp-usb iproute2 ipsec.conf ipsec.d ipsec.secrets issue issue.net java-11-openjdk john kernel kernel-img.conf king-phisher kismet ld.so.cache ld.so.conf ld.so.conf.d libao.conf libaudit.conf libblockdev libnl-3 libpaper.d lightdm lighttpd locale.alias locale.gen localtime logcheck login.defs logrotate.conf logrotate.d macchanger machine-id magic magic.mime mailcap mailcap.order manpath.config matplotlibrc mime.types minicom miredo miredo.conf mke2fs.conf modprobe.d modules modules-load.d motd mtab mysql nanorc netconfig netsniff-ng network networks nftables.conf nginx nikto.conf nsswitch.conf odbc.ini odbcinst.ini openal openfortivpn openni2 openvpn opt os-release pam.conf pam.d papersize passwd passwd- perl php plymouth polkit-1 postgresql postgresql-common powershell-empire ppp profile profile.d protocols proxychains4.conf pulse python2.7 python3 python3.10 python3.9 rarfiles.lst rc0.d rc1.d rc2.d rc3.d rc4.d rc5.d rc6.d rcS.d rearj.cfg redsocks.conf request-key.conf request-key.d resolv.conf responder rmt rpc rsyslog.conf rsyslog.d runit samba sane.d scalpel screenrc sddm.conf.d searchsploit_rc security selinux sensors3.conf sensors.d services shadow shadow- shells skel smartd.conf smartmontools smi.conf snmp speech-dispatcher sqlmap ssh ssl sslsplit strongswan.conf strongswan.d stunnel subgid subgid- subuid subuid- subversion sudo.conf sudoers sudoers.d sudoers.save sudo_logsrvd.conf sv sysctl.conf sysctl.d sysstat systemd terminfo theHarvester tightvncserver.conf timezone timidity tmpfiles.d ucf.conf udev udisks2 ufw updatedb.conf update-motd.d vdpau_wrapper.cfg vim vpnc vulkan wgetrc wireshark wpa_supplicant xattr.conf xdg xfce4 xl2tpd
</code></pre></div></div>

<p>Bakın bu kez tersi şekilde başlangıç harfinde z karakteri bulunan veya başlangıç harfi büyük olan hiç bir içerik bastırılmadı çünkü bunları genişletme kapsamına dahil etmedik. Bu iki çıktıyı kıyaslarsanız, ünlem işaretinin hariç tutma görevinde olduğunu net biçimde görebilirsiniz.</p>

<p>Ben anlatımlar sırasında mümkün oldukça temel işleyişi anlamamıza yetecek kadar örnek verdim ama yapısı gereği joker karakterleri kullanarak sınırsız sayıda örüntü oluşturabiliriz. Yani temelde nasıl çalıştığını bildiğiniz zaman ihtiyaçlarınıza göre istediğiniz kalıbı oluşturabilirsiniz. Zaten bu karakterlerin amacı da dosya isimleri ile eşleşecek desenler oluşturabilmek. Burada ele aldıklarımız joker karakterleri etkili kullanmanın tek yolu da bolca pratik yapmanızdır. Pratik yaptıkça tam mantığını kavrayıp aslında ne kadar işlevsel ve kolay kullanılabilir olduğunu bizzat deneyimlemiş olacaksınız.</p>

<p>Ayrıca ben anlatımlar sırasında hep <code class="language-plaintext highlighter-rouge">echo</code> komutunu kullandım ancak sizler dilediğiniz bir araca argüman vermek için dosya ismi genişletmesini kullanabilirsiniz. Örneğin sonu “<strong>.txt</strong>” ile biten tüm dosyaları silmek istediğinizde <code class="language-plaintext highlighter-rouge">rm *.txt</code> komutunu kullanmanız yeterli olacaktır. Denemek için öncelikle kıvırcık parantez genişletmesinden de faydalanarak <code class="language-plaintext highlighter-rouge">sudo touch {1..9}.txt</code> komutu ile 1’den 9’a kadar isimlendirilmiş sonu “<strong>.txt</strong>” ile biten dosyalarımızı oluşturalım. <code class="language-plaintext highlighter-rouge">sudo</code> komutunu kullanıyorum çünkü <strong><em>etc</em></strong> dizini atlında çalıştığımız için dosya oluşturma ve silme gibi işlemler için yetki gerekiyor. İleride bu konuya ayıraca değineceğiz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[/etc]
└─<span class="nv">$ </span><span class="nb">sudo touch</span> <span class="o">{</span>1..9<span class="o">}</span>.txt
<span class="o">[</span><span class="nb">sudo</span><span class="o">]</span> password <span class="k">for </span>taylan: 
</code></pre></div></div>

<p>Dosyaların durumunu teyit etmek için <code class="language-plaintext highlighter-rouge">ls *.txt</code> komutu ile listeleyelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[/etc]
└─<span class="nv">$ </span><span class="nb">ls</span> <span class="k">*</span>.txt
1.txt  2.txt  3.txt  4.txt  5.txt  6.txt  7.txt  8.txt  9.txt
</code></pre></div></div>

<p>Bakın dosyalar oluşturulmuş. Şimdi sonu “<strong>.txt</strong>” ile biten tüm dosyaları silmek için <code class="language-plaintext highlighter-rouge">sudo rm *.txt</code> şeklinde komutumuzu girelim.</p>

<p class="kirmizi"><strong>!! Dikkat:</strong> Çalıştığınız dizinde, içerisinde önemli veriler bulunan ve sonu ".txt" ile biten dosyalarınız varsa bu komutu girmeyin! Benim çalıştığım dizinde sonu “.txt” ile biten önemli bir dosya olmadığı için yeni oluşturduğum dosyaları silmek üzere ben bu komutumu giriyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[/etc]
└─<span class="nv">$ </span><span class="nb">sudo rm</span> <span class="k">*</span>.txt

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[/etc]
└─<span class="nv">$ </span><span class="nb">ls</span> <span class="k">*</span>.txt
<span class="nb">ls</span>: cannot access <span class="s1">'*.txt'</span>: No such file or directory
</code></pre></div></div>

<p>Bakın sonu “<strong>.txt</strong>” ile biten tüm dosyalar buradaki dosya ismi genişletmesi sayesinde <code class="language-plaintext highlighter-rouge">rm</code> komutuna argüman olarak aktarıldı, dolayısıyla <code class="language-plaintext highlighter-rouge">rm</code> aracı da bu dosyaların hepsini sildi. Bu sebeple <code class="language-plaintext highlighter-rouge">ls *.txt</code> komutunun neticesinde herhangi bir çıktı da alamadık çünkü hepsi silinmişti.</p>

<p>Tüm bu yaklaşımları ele aldıktan sonra, anlatımın başında değinmiş olduğum “dosya ismi genişletmeleri yalnızca mevcut dosya ve dizin isimlerine genişleyebilir” açıklaması üzerinde özellikle durmak istiyorum. Bu açıklama “dosya ismi genişletmesi” kullanarak önceden var olamayan metinsel bir veri üretemeyeceğimiz anlamına geliyor. Yani örneğin ben 1’den 5’e kadar isimlendirilmiş yeni klasörler oluşturmak için mkdir [1-5] şeklinde komut giremem.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[/etc]
└─<span class="nv">$ </span><span class="nb">sudo mkdir</span> <span class="o">[</span>1-5]
<span class="o">[</span><span class="nb">sudo</span><span class="o">]</span> password <span class="k">for </span>taylan: 

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[/etc]
└─<span class="nv">$ </span><span class="nb">ls</span> <span class="o">[</span>1-5]
</code></pre></div></div>

<p>Bakın ilgili klasörler oluşturulmamış çünkü köşeli parantez karakteri dosya ismi genişletmesi olduğu için yalnızca var olan dosya ve dizin isimlerinden eşleşebilecek örüntüler oluşturuyor. Yani dosya ismi genişletmelerini yeni veriler üretmek için kullanamazsınız. Bunun yerine örneğin süslü parantez genişletmesini kullanabilirsiniz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[/etc]
└─<span class="nv">$ </span><span class="nb">sudo mkdir</span> <span class="o">{</span>1..5<span class="o">}</span>

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[/etc]
└─<span class="nv">$ </span><span class="nb">ls</span> <span class="o">[</span>1-5]                                            
1:

2:

3:

4:

5:
</code></pre></div></div>

<p>Bakın süslü parantez kullandığımızda dosya ismi genişletmesi karakteri olan köşeli parantezin aksine yeni klasör isimleri üretmeyi başardık.</p>

<p>Dosya ismi genişletmesini anlatımlarını noktalamadan önce, “dosya ismi” genişletmesi ile sıklıkla karıştırılan “regex” kavramından da bahsetmek istiyorum. Bu sayede dosya ismi genişletmelerini daha net anlamış olacağız.</p>

<h2 id="regex">Regex</h2>

<p>Eğer daha önce herhangi bir programlama dili ile ilgilendiyseniz “<strong>regex</strong>” yani “<strong>reg</strong>ular <strong>ex</strong>pression” kavramıyla mutlaka karşılaşmışsınızdır. Regex en özet haliyle, spesifik olarak belirli bir karakter kalıbı ile eşleşecek desenler oluşturmamıza izin veren özel karaktere verilen isimdir. Regex doğru şekilde kullanıldığında her türlü metinsel ifadenin aranması bulunması ve ayrıştırılması konusunda inanılmaz kolaylık sağlıyor. Biz regex ile aradığımız karakter kalıbını belirtip metinsel veri girişi sağladığımızda regex, metinsel verideki kalıba uyan tüm karakterleri sorunsuzca ayrıştırıp bize iletiyor. Yani regex kullanırken dosya ismi genişletmesinde olduğu gibi yalnızca mevcut dosya veya dizin isimleri ile sınırlı değiliz. Regex’e istediğimiz metinsel veriyi girdi olarak verip bu verilerden istediklerimizi ayrıştırabiliyoruz.</p>

<p>Ben özellikle dosya ismi genişletmesinden hemen sonra regex kavramından bahsetmek istiyorum çünkü regex için kullanılan karakterle kabuk genişletmelerinde kullanılan karakterler ile aynı görünümde olup biraz daha farklı şekilde çalıştıkları için genellikle regex ile kabuk genişletmeleri karıştırılabiliyor.</p>

<p>Regex için “<code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">*</code>, <code class="language-plaintext highlighter-rouge">?</code>, <code class="language-plaintext highlighter-rouge">^</code>, <code class="language-plaintext highlighter-rouge">$</code>, <code class="language-plaintext highlighter-rouge">(</code>, <code class="language-plaintext highlighter-rouge">)</code>, <code class="language-plaintext highlighter-rouge">[</code>, <code class="language-plaintext highlighter-rouge">]</code>, <code class="language-plaintext highlighter-rouge">{</code>, <code class="language-plaintext highlighter-rouge">}</code>, <code class="language-plaintext highlighter-rouge">|</code>, <code class="language-plaintext highlighter-rouge">\</code>” karakterleri özel anlama geliyor. Biz bu karakterleri kullanarak desenler üretip tüm metinsel verileri istediğimiz gibi filtreleyebiliyoruz. Regex inanılmaz derecede esnek ve kullanışlı olmasının yanında sizin de fark edebileceğiniz gibi bash kabuğu tarafından kullanılan bazı genişletme karakterlerini regex de kullanıyor. Üstelik regex için kullanılan bu özel karakterler bash kabuğundakilere benzer özellikler sergiliyor olsalar da aslında tam olarak bash kabuğundaki gibi çalışmıyorlar. Örneğin bash kabuğunda “?” karakteri <strong>yalnızca herhangi tek bir karakteri</strong> kapsamak için kullanıyorken, regex üzerinde soru işareti <strong>sıfır veya bir tane karakteri</strong> kapsamak için kullanılıyor. Belki size önemli bir fark gibi gelmemiş olabilir fakat bu gibi detaylar üretilecek örüntüleri tamamen değiştireceği için aslında çok önemli.</p>

<p>Genelde modern programlama dillerinin hepsinde regex kullanmak mümkün ancak bash kabuğu programlanabilir yapıda olmasına karşın doğrudan kendi içinde regex kullanmıyor. Bunun yerine bir önceki kısımda da ele aldığımız şekilde mevcut dosya ve klasörlerin isimlerine genişletilmek üzere “dosya ismi genişletmesi” ya da diğer adıyla “globbing” olarak geçen kabuğun sağladığı “yıldız” “soru işareti” ve “köşeli parantez” joker karakterlerini kullanıyor. <strong>Bash kabuğu yalnızca kendi bünyesindeki genişletmeleri kullanıyor.</strong> Çünkü bash kabuğu, kullanıcılara sistem üzerindeki araçları bulma ve çalıştırma için bir ortam sağlamak amacında. Bu amacı doğrultusunda da kendisine ait olan bu özel genişletme karakterleriyle bazı kolaylıklar sunuyor, hepsi bu. Zaten regex ile bash kabuğunun genişletmeler için kullandığı karakterler benzer olduğu için bash kabuğunun aynı karakterler ile hem genişletme sunup hem de aynı anda regex desteklemesi pek makul değil.</p>

<p>Peki bash kabuğu üzerinde regex’in imkanlarından faydalanmamız mümkün değil mi ? Elbette mümkün.</p>

<p>Bash kabuğu dahili olarak regex desteklemediği için kabuğun genişletmelerini kullanmak yerine regex kullanarak metinlerdeki örüntüleri bulmamız gerektiğinde de, <code class="language-plaintext highlighter-rouge">sed</code> <code class="language-plaintext highlighter-rouge">awk</code> veya <code class="language-plaintext highlighter-rouge">grep</code> gibi regex destekleyen araçlar ile işimizi halledebiliyoruz.</p>

<p>Yani kabuğun genişletme özellikleri kabuğun kendisine ait olan gömülü özellikler. Dolayısıyla bash kabuğu üzerinde doğrudan yalın şekilde bu özel karakterleri kullandığımızda kabuk her zaman bunları genişletme karakteri olarak yorumluyor olacak.</p>

<p>Eğer harici olarak regex kullanmamız gerekiyorsa, regex yeteneğine sahip olan <code class="language-plaintext highlighter-rouge">grep</code> <code class="language-plaintext highlighter-rouge">sed</code> <code class="language-plaintext highlighter-rouge">awk</code> gibi araçları kullanarak metinsel verileri istediğimiz biçimde işleyebiliyoruz. Zaten kabuğun amacının bize komut satırında çalışma ortamı sağlamak olduğundan daha önce tekrar tekrar bahsettik. Dolayısıyla zaten kabuğun doğrudan kendi içinde regex desteklemesi gerekmiyor çünkü kabuğun asıl görevi bizim ihtiyacımız olan araçları bulup bu araçları konsol üzerinden rahat yönetebilmemiz. Biz istediğimiz aracı kabuk sayesinde çalıştırdıktan sonra zaten o aracın tüm özelliklerini kabuktan bağımsız olarak kullanabiliyoruz.</p>

<p>Yani kabuğun regex desteklememesi bir eksiklik değil, kabuğun yapısının bir parçasıdır. Kabuk tüm bölüm boyunca bahsettiğimiz gibi bize gerekli çalışma ortamını sağlayacak genişletme özelliklerine zaten sahip. Eğer regex gibi ek özellikler gerekiyorsa, bu özellikleri destekleyen harici araçları kullanarak işlerimizi halledebiliyoruz.</p>

<p>Regex ile kabuğa ait genişletmeler arasındaki farkı iyi anlamamız, kabuğa vereceğimiz komutların sonuçları üzerinde çok etkili.</p>

<p>Ben kabuğa ait genişletme karakterleri ile regex in farkını size göstermek için çok basit bir örnek ele almak istiyorum. Ancak vereceğim örneğin net biçimde anlaşılabilmesi için de öncelikle alıntı karakteri olarak geçen tek ve çift tırnak kullanımına da çok kısaca değinmemiz gerekiyor.</p>

<h2 id="alıntı-karakterleri">Alıntı Karakterleri</h2>

<p>Kabuk için özel anlam ifade eden metakarakterlerin(<code class="language-plaintext highlighter-rouge">? { } $ ; &amp; | &lt; &gt; ( ) ' " \ # ~ ! ^ = + - _ . , : % @ / *</code>) kabuk tarafından özel anlamlarına genişletildiğini tüm bu bölüm boyunca adım adım ele aldık. Eğer kabuk için özel anlamı olan karakterlerin kabuğun genişletmesinden muaf tutulmasını istersek bu karakterleri tırnak içinde yazarak kabuk için sıradan karakterler olarak görülmelerini sağlayabiliyoruz.</p>

<p>Eğer hatırlıyorsanız, <code class="language-plaintext highlighter-rouge">mkdir yeni klasor</code> şeklinde komut girdiğimizde aradaki boşluktan dolayı “yeni” ve “klasor” isimli iki ayrı klasör oluşturulmuştu. Çünkü kabuk buradaki boşluk karakterini, komutu argümanlara ayırmak için koyduğumuzu düşünüyordu.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">ls
</span>Desktop    Downloads  Pictures  Templates
Documents  Music      Public    Videos

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">mkdir </span>yeni klasor

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">ls
</span>Desktop    Downloads  Music     Public     Videos
Documents  klasor     Pictures  Templates  yeni
</code></pre></div></div>

<p>Bakın burada yine iki ayrı klasör oluşturuldu. Bu duruma çözüm olarak da klasör ismini tırnak içinde yazmıştık. Tekrar deneyelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">mkdir</span> <span class="s1">'yeni klasor'</span>

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">ls
 </span>Desktop     klasor     Public      yeni
 Documents   Music      Templates  <span class="s1">'yeni klasor'</span>
 Downloads   Pictures   Videos
</code></pre></div></div>

<p>Bakın bu kez tırnak içinde yazdığımız için buradaki boşluk karakteri klasörün ismine dahil edildi ve bu isimde tek bir klasör oluşturuldu. İşte bizzat bu örnek üzerinden ele aldığımız durum burada bahsi geçen <strong>alıntılama</strong> kavramının ta kendisi. Tırnak içinde yazmaya alıntılama deniyor ve tırnak içindeki karakterler kabuk için ifade ettikleri özel anlamlardan muaf tutuluyorlar.</p>

<p>Söz konusu alıntılama olduğunda tek ve çift tırnak kullanabileceğimiz iki alternatif yöntem bulunuyor.</p>

<p>Bash kabuğu için tek tırnak en katı alıntılama biçimi. Bu sebeple tek tırnak içindeki hiç bir karakter kabuk tarafından özel anlamaları dahilinde ele alınmıyor.</p>

<p>Hemen denemek için şu ana kadar ele aldığımız genişletme karakterlerini tek tırnak içinde yazıp <code class="language-plaintext highlighter-rouge">echo</code> aracı ile konsola bastırmayı deneyelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[/etc]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="s1">'{1..5} [a-z]* ~ $SHELL'</span> 
<span class="o">{</span>1..5<span class="o">}</span> <span class="o">[</span>a-z]<span class="k">*</span> ~ <span class="nv">$SHELL</span>
</code></pre></div></div>

<p>Bakın tek tırnak içinde yazmış olduğum hiç bir genişletme karakteri kabuk tarafından genişletilmedi. Nasıl yazdıysam aynen <code class="language-plaintext highlighter-rouge">echo</code> aracına standart karakterler olarak iletilip konsola bastırılması sağlandı.</p>

<p>Şimdi aynı örneği çift tırnak içinde tekrar deneyebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[/etc]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"{1..5} [a-z]* ~ </span><span class="nv">$SHELL</span><span class="s2">"</span>
<span class="o">{</span>1..5<span class="o">}</span> <span class="o">[</span>a-z]<span class="k">*</span> ~ /usr/bin/bash
</code></pre></div></div>

<p>Değişken genişletmesinin uygulanıp diğerlerinin uygulanmadığı bir çıktı aldık. Çok fazla detaylarına girmeyeceğiz ancak çıktılarda görebildiğiniz gibi <strong>değişken</strong> olarak da bilinen buradaki <strong>parametre genişletmesi</strong> çift tırnak içinde geçerliliğini korumaya devam ediyor.</p>

<p><strong>Kıvırcık parantez genişletmesi, tilde genişletmesi ve dosya ismi genişletmeleri ise çift tırnak içinde geçerliliğini yitiriyor</strong>. Çünkü bash kabuğu çift tırnak içindeki dolar işaretini ve ters slash karakterleri istisna olarak görüp özel işlevlerini yerine getirmelerini sağlıyor.</p>

<p>Aslında başka genişletme kuralları ve detayları da var ancak konuyu detaylandırıp kafamızı karıştırmayalım. Burada dikkatinizi çekmek istediğim asıl nokta, kıvırcık parantez tilde ve dosya ismi genişletmesi gibi bazı özel karakterlerin kullanıldığı bu genişletmelerin çift veya tek tırnak içinde geçerli olmadığı.</p>

<p>Genişletmeler tırnaklar içinde geçerli olmadığı için bizler de regex destekleyen araçlara komut girerken regex karakterlerinin kabuk tarafından yanlış anlaşılmasını önlemek için tırnak içinde yazıyoruz. Çünkü regex karakterleri ile kabuğun kullandığı metakarakterler birbirine benziyor. Örneğin regex de kıvırcık ve köşeli parantezleri kullanıyor. Ayrıca nokta soru işareti yıldız gibi özel karakterleri de kullanıyor. İşte regex ile kabuğun kullandığı aynı karakterlerin karıştırılmaması için regex kullanmak istediğimizde tırnaklardan faydalanabiliyoruz.</p>

<p>Söylediklerim yeterince anlaşılır olmadıysa hemen basit bir örnek üzerinden somut şekilde açıklamaya çalışalım. Örnek için de ileride ayrıca ele alacağımız <code class="language-plaintext highlighter-rouge">grep</code> aracını kullanabiliriz. <code class="language-plaintext highlighter-rouge">grep</code> aracı filtreleme yapmamızı sağlayan bir araç.</p>

<p>Öncelikle test edebilmemiz için bir test ortamı oluşturalım. Ben mevcut bulunduğum dizinine <code class="language-plaintext highlighter-rouge">mkdir ada</code> komutu ile ismi “ada” olan bir klasör oluşturuyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">mkdir </span>ada
</code></pre></div></div>

<p>Şimdi bir de içerisinde “<strong>a</strong>” ile başlayıp “<strong>a</strong>” ile biten birkaç kelime bulunan birkaç dosya oluşturalım. Bunun için <code class="language-plaintext highlighter-rouge">echo a{b..e}a &gt; metin1.txt</code> şeklinde komutumuzu girip  <code class="language-plaintext highlighter-rouge">cat</code> ile dosya içeriğini teyit edebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo </span>a<span class="o">{</span>b..e<span class="o">}</span>a <span class="o">&gt;</span> metin1.txt

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat </span>metin1.txt 
aba aca ada aea
</code></pre></div></div>

<p>Bakın “aba aca ada aea” şeklinde yeni kelimeler bu dosyaya eklenmiş. Şimdi yeni bir tane dosya oluşturmak için <code class="language-plaintext highlighter-rouge">echo a{f..k}a &gt; metin2.txt</code> şeklinde komutumuzu girelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo </span>a<span class="o">{</span>f..k<span class="o">}</span>a <span class="o">&gt;</span> metin2.txt

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat </span>metin2.txt                       
afa aga aha aia aja aka
</code></pre></div></div>

<p>Bakın bu dosyada da “<strong>a</strong>” ile başlayıp “<strong>a</strong>” ile biten çeşitli ifadeler var. Tamamdır şimdi testimize geçebiliriz.</p>

<p><code class="language-plaintext highlighter-rouge">grep</code> aracı ile araştırma yaparken <code class="language-plaintext highlighter-rouge">grep</code> komutundan sonra araştırmak istediğimiz karakter kalıbını yazıp daha sonra bu kalıbın araştırılacağı metinleri de argüman olarak eklememiz gerekiyor.</p>

<p>Şimdi ben <code class="language-plaintext highlighter-rouge">grep 'a*a' metin*.txt</code> şeklinde komutumu giriyorum.</p>

<p><img src="https://superua1.github.io//egitim/genisletme/3.png" alt="3.png" class="responsive img-zoomable" /></p>

<p>Bakın içerisinde “a” ile başlayıp “a” ile biten bütün kelimelerdeki “a” karakterleri renkli şekilde bize sunuldu. Yani filtrelemiş olduk. Şimdi aynı komutu tırnak işaretleri olmadan tekrar girmeyi deneyebiliriz.</p>

<p><img src="https://superua1.github.io//egitim/genisletme/4.png" alt="4.png" class="responsive img-zoomable" /></p>

<p>Bakın bu kez yalnızca “ada” ifadesini içeren satırın filtrelendiğini ve “ada” ifadesinin renklendirildiğini görüyoruz. Şimdi neden bu iki çıktının birbirinden farklı olduğunu açıklayacak olursak.</p>

<p>Burada tırnak işareti kullanarak girdiğimiz komuttaki bu asterix yani yıldız karakteri tırnak içinde olduğu için kabuk tarafından genişletilmedi. Yani görmezden gelindi fakat sondaki <code class="language-plaintext highlighter-rouge">metin*</code> argümanı tırnak içinde olmadığı için dosya ismi genişletmesi dolayısıyla “<strong><em>metin1.txt</em></strong>” ve “<strong><em>metin2.txt</em></strong>” argümanlarına dönüştürülmüş oldu. Ve en nihayetinde genişletmeler uygulandıktan sonra en son halini alan bu argümanlar <code class="language-plaintext highlighter-rouge">grep</code> aracına iletildi. <code class="language-plaintext highlighter-rouge">grep</code> aracı da regex’i desteklediği için bu kalıbı regex kalıbı olarak dikkate alıp <strong><em>metin1.txt</em></strong> ve <strong><em>metin2.txt</em></strong> dosyaları içinden bu kalıpla eşleşenleri bize çıktı olarak sunmuş oldu.</p>

<p>Tırnak işareti kullanmadığımız komuttaysa, kabuğumuz tırnak içinde olmadığı için bu kalıbı dosya ismi genişletmesi olarak görüp, <code class="language-plaintext highlighter-rouge">grep</code> aracını çalıştırmadan önce bu genişletmeyi uyguladı. Benim bulunduğum dizinde “<strong><em>ada</em></strong>” isimli bir klasör olduğu için buradaki “<code class="language-plaintext highlighter-rouge">a*a</code>” ifadesi de kabuk tarafından dosya ismi genişletmesi dolayısıyla <code class="language-plaintext highlighter-rouge">ada</code> argümanına dönüştürüldü. Ayrıca sondaki “<code class="language-plaintext highlighter-rouge">metin*</code>” ifadesi de dosya genişletmesi ile metin ifadesiyle başlayan “<strong><em>metin1.txt</em></strong>” ve “<strong><em>metin2.txt</em></strong>” dosyalarına genişletildiği için komutumuz <code class="language-plaintext highlighter-rouge">grep ada metin1.txt metin2.txt</code> halini almış oluyor. <code class="language-plaintext highlighter-rouge">grep</code> aracına da bu argümanlar iletildi. Dolayısıyla <code class="language-plaintext highlighter-rouge">grep</code> aracı bu dosyalar içinde “<strong>ada</strong>” ifadesini arayıp filtrelmiş oldu.</p>

<p>İşte bakın bizzat örnekler üzerinden de teyit ettiğimiz gibi regex karakterlerini çift tırnak içinde yazmadığımızda kabuk bu karakteri görmezden gelmediği için kabuğun kendine ait olan genişletme karakterleri olduğunu düşünüp genişletmeyi uyguluyor.</p>

<p>Kabuğa girdimiz komutlar öncelikle kabuk tarafından anlamlandırıldığı için kabuk örneğin <code class="language-plaintext highlighter-rouge">grep</code> aracını çalıştırmadan önce kendi üzerine düşen görevi yerine getirip varsa genişletmeleri uyguluyor. Genişletmelerden sonra komutumuzdaki argümanlar son halini aldığında <code class="language-plaintext highlighter-rouge">grep</code> aracı çalıştırılıp bu argümanlar <code class="language-plaintext highlighter-rouge">grep</code> aracına iletiliyor.</p>

<p>Bu sebeple kabuğun genişletmesinden kaçıp, girdiğimiz bu argümanın <code class="language-plaintext highlighter-rouge">grep</code> aracına bu şekilde ulaşması için de tırnak içinde yazmamız gerekti. Hatta tırnak içinde yazmadan kaçış karakteri sayesinde yine bu asterix karakterinin özel anlamının kabuk tarafından görmezden gelinmesini de sağlayabiliriz. Ben denemek için komutumu <code class="language-plaintext highlighter-rouge">grep a\*a metin*</code> şeklinde giriyorum.</p>

<p><img src="https://superua1.github.io//egitim/genisletme/5.png" alt="5.png" class="responsive img-zoomable" /></p>

<p>Bakın tıpkı tırnak içinde yazdığımızdaki gibi buradaki ifade dosya ismi genişletmesi olarak sayılmadan <code class="language-plaintext highlighter-rouge">grep</code> aracına iletildiği için bu kalıp da regex dahilinde değerlendirildi. Buradaki ters slash <code class="language-plaintext highlighter-rouge">\</code> kaçış karakteri, kendisinden sonra gelen karakterin özel anlamının görmezden gelinmesini sağladığı için ben asterix karakterinden hemen önce kullanarak kabuğun dosya ismi genişletmesini önlemiş oldum.</p>

<p>Böylelikle regex ile kabuk genişletmelerinin benzer gözüküyor olmalarına karşın farklı çalışma yapıları olduğunu bu örnekle ele almış olduk. Genellikle önemsiz gözüken bu gibi detaylar girdiğimiz komutların bambaşka sonuçlar üretmesine neden olduğu için aslında çok önemli. Bu sebeple zaten tek tek tüm temel detaylardan bahsetmeye gayret ediyoruz. Regex kullanımından da eğitimin devamında yeri geldiğinde çok kısaca bahsediyor olacağız.</p>

<p>Ben şimdi son olarak çok kısaca komut ikamesi genişletmesinden de bahsedip genişletme anlatımlarını sonlandırmak istiyorum.</p>

<h1 id="komut-i̇kamesi-genişletmesi">Komut İkamesi Genişletmesi</h1>

<p>Esasen temel eğitimde bu genişletmeden bahsetmeyi düşünmüyordum fakat, sık karşılaşabileceğiniz ve gerektiğinde işinize yarayabileceği için çok kısaca ele almak istiyorum.</p>

<p>Komut ikamesi kavramı, ikame kelimesinin de yardımıyla çıkarım yapabileceğimiz gibi, komutların ürettiği sonuçların bu genişletmenin kullanıldığı tanımlamanın yeri almasından ibaret. Biliyorum ilk kez duyduğunuz bu tanımlama hiç bir şey ifade etmiyor. Hemen daha anlamlı hale getirmek için örnekler üzerinden ele almaya çalışalım.</p>

<p>Normalde komut ikamesi daha çok kabuk programlamada kullanılıyor o yüzden size şimdi çok mantıklı gelmese de birkaç örnek vermek istiyorum. Ancak merak etmeyin eğitimin devamında biraz daha fazla detay öğrendikten sonra daha makul bir kullanım örneğini ele alırız mutlaka. Siz şimdi yalnızca komut ikamesi genişletmesinin nasıl çalıştığına odaklanın lütfen.</p>

<p>Ben “mevcut dizin” ifadesinden sonra konsola bulunduğum dizinin bastırılmasını istiyorum. Bunun için <code class="language-plaintext highlighter-rouge">echo “mevcut dizin $(pwd)”</code> şeklinde komutumu girebilirim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"mevcut dizin </span><span class="si">$(</span><span class="nb">pwd</span><span class="si">)</span><span class="s2">"</span>
mevcut dizin /home/taylan
</code></pre></div></div>

<p>Bakın mevcut dizin ifadesinden sonra <code class="language-plaintext highlighter-rouge">pwd</code> komutunun çıktısı argüman olarak genişletildiği için buradaki çıktıya bastırılmış oldu. Buradaki dolar işaretinden sonra parantez içinde yazmış olduğum tanımlama aslında <strong>komut ikamesi genişletmesi</strong> olarak geçiyor. Ben parantez içinde <code class="language-plaintext highlighter-rouge">pwd</code> komutunu girdiğim için bu <code class="language-plaintext highlighter-rouge">pwd</code> komutu alt kabukta çalıştırıp bu komutun sonucu bu tanımlamanın yerine argüman olarak genişletilmiş oldu.</p>

<p>Ek bir örnek olarak bir dosya içindeki ifadeleri, yeni oluşturulacak klasör isimleri üzerinde kullanabiliriz. Öncelikle echo “birinci ikinci ucuncu” &gt; dosya.txt komutu ile içerisinde “birinci ikinci ucuncu” ifadeleri bulunan dosyamızı oluşturalım.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"birinci ikinci ucuncu"</span> <span class="o">&gt;</span> dosya.txt

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat </span>dosya.txt 
birinci ikinci ucuncu
</code></pre></div></div>

<p>Tamamdır dosyamızı oluşturduk. Şimdi bu dosyanın içeriğindeki isimlerin alınıp okunması ve bu isimlerle yeni klasörler oluşturulmasını için <code class="language-plaintext highlighter-rouge">mkdir $(cat dosya.txt)</code> şeklinde komutumuzu girelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">mkdir</span> <span class="si">$(</span><span class="nb">cat </span>dosya.txt<span class="si">)</span>

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">ls                                   
 </span>ada         ikinci       Public
 birinci     klasor       Templates
 Desktop     metin1.txt   ucuncu
 Documents   metin2.txt   Videos
 dosya.txt   Music        yeni
 Downloads   Pictures    <span class="s1">'yeni klasor'</span>
</code></pre></div></div>

<p>Bakın tam olarak dosyanın içerisine yazdığımız ifadeler klasör isimleri olarak kullanılmış. Yani dosya içeriğinin okunup bu dosya içeriği üzerinden <code class="language-plaintext highlighter-rouge">mkdir</code> aracına iş yaptırmış olduk. Normalde <code class="language-plaintext highlighter-rouge">mkdir</code> aracı kendisi bu şekilde dosyadan okuyup klasör oluşturmayı desteklemiyor ancak biz komut ikamesi sayesinde dosya içeriğini <code class="language-plaintext highlighter-rouge">cat</code> aracı ile okuyup bu çıktıları bu <code class="language-plaintext highlighter-rouge">mkdir</code> aracına argüman olarak iletmeyi başardık.</p>

<p>Tıpkı bu örneğimizde olduğu gibi siz de komut ikamesinden farklı durumlarda faydalanabilirsiniz. Mesela aynı şekilde oluşturduğumuz dizinleri silmek için de <code class="language-plaintext highlighter-rouge">rmdir $(cat dosya.txt)</code> şeklinde komutumuzu girebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">rmdir</span> <span class="si">$(</span><span class="nb">cat </span>dosya.txt<span class="si">)</span>               

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">ls                                   
 </span>ada         klasor       Public
 Desktop     metin1.txt   Templates
 Documents   metin2.txt   Videos
 dosya.txt   Music        yeni
 Downloads   Pictures    <span class="s1">'yeni klasor'</span>
</code></pre></div></div>

<p>Bakın dosyadaki isimlerden oluşturulmuş olan klasörler yine aynı şekilde dosyadaki isimler sayesinde silinmiş oldu. <code class="language-plaintext highlighter-rouge">mkdir</code> ve <code class="language-plaintext highlighter-rouge">rmdir</code> aracı normalde bu şekilde dosyadan içerik okuyarak çalışmıyorlar ama biz komut ikamesi yardımıyla gereken çözümü üretmeyi başardık.</p>

<p>Benim ele aldığım bu örnekler komut ikamesinin kullanımına dair son derece basit örnekler ama bence komut ikamesi genişletmesinin nasıl çalıştığını anlamamız için yeterli. Örneğin biz komut ikamesini <code class="language-plaintext highlighter-rouge">$(komut)</code> şeklinde tanımladık ama alternatif olarak ters tırnak <code class="language-plaintext highlighter-rouge">'</code> içinde(Türkçe klavyemizden <kbd>AltGr</kbd> + <kbd>,</kbd> tuşlaması ile ters tırnak üretebilirsiniz) yazdığımız komutlar da komut ikamesi olarak görülüyor.</p>

<p>Örneğin ben denemek için <code class="language-plaintext highlighter-rouge">echo “burası 'pwd' "</code> şeklinde ters tırnak içinde komutumu giriyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"burası </span><span class="sb">`</span><span class="nb">pwd</span><span class="sb">`</span><span class="s2">"</span>                  
burası /home/taylan

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"burası </span><span class="si">$(</span><span class="nb">pwd</span><span class="si">)</span><span class="s2">"</span>                 
burası /home/taylan
</code></pre></div></div>

<p>Bakın ters tırnak içine aldığımız komut çalıştırıldı ve çıktısı bu komutun bulunduğu yere genişletilerek <code class="language-plaintext highlighter-rouge">echo</code> aracına argüman olarak verildi. Dolayısıyla bu çıktıyı da alabildik. Yani komut ikamesi genişletmesi için ters tırnak veya dolar işaretinden sonra parantez içinde komut girebilirsiniz. Ben dolar işaretinden sonra parantez içinde yazma kuralını öneriyor olsam da siz her iki kullanımla da karşılaşıyor olacaksınız. Bu sebeple özellikle ters tırnak kullanımından da bahsetmek istedim.</p>

<p>En nihayetinde bu bölüm içerisinde kabuk üzerinde yer alan en sık kullanılan birkaç genişletme türlerinden bahsedip, gerektiğine nasıl faydalanabileceğimizi öğrenmiş olduk. Daha fazlası için bash kabuğunun <a href="https://www.gnu.org/software/bash/manual/html_node/Shell-Expansions.html">dokümantasyonlarına</a> göz atabilirsiniz fakat giriş seviyesi temel eğitim için yani bence mevcut eğitimi takip etmek için bahsettiklerimiz yeterli.</p>

<p>Genişletmeleri daha iyi anlamak için tek yapmanız gereken burada bahsetmiş olduğumuz genişletmelere dair bol bol pratik yapmak. Pratik yaptıkça aslında ne kadar basit ve kullanışlı bir yapı olduğunu fark edeceksiniz.</p>

<h1 id="alıştırmalar">Alıştırmalar</h1>

<p>Alıştırmaları gerçekleştirebilmek için dilerseniz çalışma ortamı oluşturabilirsiniz. Bunun için aşağıdaki adımları takip etmeniz yeterli.</p>

<p>Öncelikle test ortamı için yeni bir klasör oluşturup bu dizine geçiş yapalım.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir </span>test-ortami
<span class="nb">cd </span>test-oratami
</code></pre></div></div>

<p>Bu dizine, aşağıdaki betik dosyasını <code class="language-plaintext highlighter-rouge">cat &gt; betik.sh</code> komutunun ardından <kbd>Ctrl</kbd> + <kbd>D</kbd> tuşlaması ile kaydedip <code class="language-plaintext highlighter-rouge">chmod +x betik.sh</code> ile yetki verelim ve <code class="language-plaintext highlighter-rouge">./betik.sh</code> komutu ile dosyayı çalıştıralım.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/test-ortami]
└─<span class="nv">$ </span><span class="nb">cat</span> <span class="o">&gt;</span> betik.sh
<span class="c">#!/bin/bash</span>

<span class="c"># Dosya isimlerini oluşturmak için kullanılacak karakterler</span>
<span class="nv">characters</span><span class="o">=(</span><span class="s2">"a"</span> <span class="s2">"b"</span> <span class="s2">"c"</span> <span class="s2">"x"</span> <span class="s2">"y"</span> <span class="s2">"t"</span> <span class="s2">"1"</span> <span class="s2">"2"</span> <span class="s2">"3"</span> <span class="s2">"4"</span> <span class="s2">"5"</span> <span class="s2">"6"</span> <span class="s2">"7"</span> <span class="s2">"8"</span> <span class="s2">"9"</span><span class="o">)</span>

<span class="c"># Dosya isimlerinin uzantıları</span>
<span class="nv">extensions</span><span class="o">=(</span><span class="s2">"txt"</span> <span class="s2">"pdf"</span> <span class="s2">"docx"</span> <span class="s2">"jpg"</span> <span class="s2">"csv"</span><span class="o">)</span>

<span class="c"># Oluşturulacak dosya sayısı</span>
<span class="nv">count</span><span class="o">=</span>25

<span class="c"># Tur sayısı</span>
<span class="nv">rounds</span><span class="o">=</span>3

<span class="c"># Dosya isimlerini oluştur</span>
<span class="k">for</span> <span class="o">((</span><span class="nv">r</span><span class="o">=</span>0<span class="p">;</span> r&lt;<span class="nv">$rounds</span><span class="p">;</span> r++<span class="o">))</span>
<span class="k">do
    for</span> <span class="o">((</span><span class="nv">i</span><span class="o">=</span>0<span class="p">;</span> i&lt;<span class="nv">$count</span><span class="p">;</span> i++<span class="o">))</span>
    <span class="k">do</span>
        <span class="c"># Rastgele karakterleri seç</span>
        <span class="nv">random_character1</span><span class="o">=</span><span class="k">${</span><span class="nv">characters</span><span class="p">[</span><span class="k">$((</span>RANDOM <span class="o">%</span> <span class="k">${#</span><span class="nv">characters</span><span class="p">[@]</span><span class="k">}))</span><span class="p">]</span><span class="k">}</span>
        <span class="nv">random_character2</span><span class="o">=</span><span class="k">${</span><span class="nv">characters</span><span class="p">[</span><span class="k">$((</span>RANDOM <span class="o">%</span> <span class="k">${#</span><span class="nv">characters</span><span class="p">[@]</span><span class="k">}))</span><span class="p">]</span><span class="k">}</span>
        <span class="nv">random_character3</span><span class="o">=</span><span class="k">${</span><span class="nv">characters</span><span class="p">[</span><span class="k">$((</span>RANDOM <span class="o">%</span> <span class="k">${#</span><span class="nv">characters</span><span class="p">[@]</span><span class="k">}))</span><span class="p">]</span><span class="k">}</span>

        <span class="c"># Rastgele uzantıyı seç</span>
        <span class="nv">random_extension</span><span class="o">=</span><span class="k">${</span><span class="nv">extensions</span><span class="p">[</span><span class="k">$((</span>RANDOM <span class="o">%</span> <span class="k">${#</span><span class="nv">extensions</span><span class="p">[@]</span><span class="k">}))</span><span class="p">]</span><span class="k">}</span>

        <span class="c"># Dosya ismini oluştur</span>
        <span class="nv">filename</span><span class="o">=</span><span class="s2">"</span><span class="nv">$random_character1$random_character2$random_character3</span><span class="s2">.</span><span class="nv">$random_extension</span><span class="s2">"</span>

        <span class="c"># Dosya oluştur</span>
        <span class="nb">touch</span> <span class="s2">"</span><span class="nv">$filename</span><span class="s2">"</span>
    <span class="k">done
done

</span><span class="nb">ls</span> <span class="c"># Üretilen mevcut dizindeki dosyaları yazdırmak için</span>

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/test-oratami]
└─<span class="nv">$ </span><span class="nb">chmod</span> +x betik.sh
</code></pre></div></div>

<p>Bu betik mevcut bulunduğunuz dizine 75 rastgele dosya oluşturacaktır. Bu sayede bu dizinde her türlü genişletme alıştırması yapmak için yeterli örneğe sahip olabilirsiniz. Gerekli çalışma ortamını kurduktan sonra aşağıdaki alıştırmaları pratiğe dökmeyi deneyebilirsiniz.</p>

<p class="mavi"><strong>Not:</strong> Buradaki betik dosyası her seferinde rastgele veriler ürettiği için aşağıdaki alıştırmalarada yer alan örüntülere tamamen uyacak dosya isimleri oluşturulmamış olabilir. Bu durumda soruya uygun olan dosya veya klasör isimlerini kendiniz oluşturup genişletme kurallarını test edebilirsiniz.</p>

<h2 id="sorular">Sorular</h2>

<ol>
  <li>
    <p>Başlangıcında herhangi tek bir karakter olan ve devamındaki karakterler “<strong>x</strong>”, “<strong>y</strong>” veya “<strong>t</strong>” olup sonraki karakterleri de herhangi türden karakter olan dosya ismi genişletmesini nasıl tanımlarsınız?</p>
  </li>
  <li>
    <p>Başlangıcında “<strong>a</strong>” olan ve sonu “<strong>.txt</strong>” veya “<strong>.pdf</strong>” veya “<strong>.jpg</strong>” ile biten dosya ve dizinleri nasıl filtreleyebilirsiniz?</p>
  </li>
  <li>
    <p>“<strong>a</strong>” ile başlayıp “<strong>g</strong>” ile biten tüm dosya ve klasörleri kapsamak için genişletmeyi nasıl tanımlarsınız?</p>
  </li>
  <li>
    <p>İlk harfi herhangi tek bir karakter olan ve devamında “<strong>x</strong>” karakteri bulunan ve sonrasındaki karakter sayısı ve biçimi fark etmeyen bir dosya ismi genişletmesini nasıl tanımlarsınız?</p>
  </li>
  <li>
    <p>Sonunda “<strong>.txt</strong>” uzantısı bulunanlar hariç tüm dosyaları nasıl filtrelersiniz ?</p>
  </li>
  <li>
    <p>Başlangıcında 1’den 13’e kadar sayılardan biri olan ve devamında tam olarak herhangi 7 karakteri barındıranları nasıl filtrelersiniz ?</p>
  </li>
  <li>
    <p>İsminin başında “<strong>1</strong>”, “<strong>4</strong>”, veya “<strong>5</strong>” rakmlarından bırını barındıran ama sonunda “<strong>a</strong>”, “<strong>b</strong>”, “<strong>t</strong>” veya “<strong>g</strong>” karakterlerini barındırmayan dosya ismi genişletmesini nasıl tanımlarsınız?</p>
  </li>
  <li>
    <p>İlk karakteri “<strong>x</strong>”, “<strong>y</strong>” veya “<strong>t</strong>” olan ancak son karakteri “<strong>x</strong>”, “<strong>y</strong>” veya “<strong>t</strong>” olmayan dosya ismi genişletmelerini nasıl tanımlarsınız?</p>
  </li>
  <li>
    <p>İlk karakteri “<strong>m</strong>”, “<strong>n</strong>” veya “<strong>o</strong>” olan ve son karakteri “<strong>a</strong>”, “<strong>b</strong>” veya “<strong>t</strong>” olan dosya ismi genişletmelerini nasıl tanımlarsınız?</p>
  </li>
  <li>
    <p>İlk karakteri “<strong>a</strong>” veya “<strong>b</strong>” olan ve içinde “<strong>x</strong>” veya “<strong>y</strong>” karakteri bulunan dosya ismi genişletmelerini nasıl tanımlarsınız?</p>
  </li>
  <li>
    <p>İlk karakteri “<strong>5</strong>” rakamından küçük, son karakteri ise küçük bir harf olan dosya ismi genişletmelerini nasıl tanımlarsınız?</p>
  </li>
  <li>
    <p>İlk karakteri “<strong>p</strong>” veya “<strong>q</strong>” olan ve içinde “<strong>xyz</strong>” karakter dizisi geçen dosya ismi genişletmelerini nasıl tanımlarsınız?</p>
  </li>
  <li>
    <p>İsminin içinde “<strong>linux</strong>” geçen dosya ismi genişletmelerini nasıl tanımlarsınız?</p>
  </li>
  <li>
    <p>İlk iki karakteri “<strong>ab</strong>” olan ve içinde “<strong>123</strong>” sayı dizisi geçen dosya ismi genişletmelerini nasıl tanımlarsınız?</p>
  </li>
  <li>
    <p>İlk karakteri “<strong>a</strong>” olan ve en az beş karakter içeren dosya ismi genişletmelerini nasıl tanımlarsınız?</p>
  </li>
  <li>
    <p>İlk karakteri “<strong>x</strong>” veya “<strong>y</strong>” olan ve son karakteri “<strong>x</strong>” olan dosya ismi genişletmelerini nasıl tanımlarsınız?</p>
  </li>
  <li>
    <p>İsminin içinde “<strong>abc</strong>” geçmeyen dosya ismi genişletmelerini nasıl tanımlarsınız?</p>
  </li>
  <li>
    <p>İlk karakteri bir büyük harf olan ve içinde en az iki sayı geçen dosya ismi genişletmelerini nasıl tanımlarsınız?</p>
  </li>
  <li>
    <p>İlk iki karakteri bir harf olan ve son karakteri “<strong>.txt</strong>” olan dosya ismi genişletmelerini nasıl tanımlarsınız?</p>
  </li>
  <li>
    <p>İlk karakteri bir sayı olan ve içinde en az üç harf bulunan dosya ismi genişletmelerini nasıl tanımlarsınız?</p>
  </li>
</ol>

<h2 id="yanıtlar">Yanıtlar</h2>

<ol>
  <li><code class="language-plaintext highlighter-rouge">echo ?[xyt]*</code></li>
  <li><code class="language-plaintext highlighter-rouge">echo a*.{txt,pdf,jpg}</code></li>
  <li><code class="language-plaintext highlighter-rouge">echo a*g</code></li>
  <li><code class="language-plaintext highlighter-rouge">echo ?x*</code></li>
  <li><code class="language-plaintext highlighter-rouge">echo *[!.txt]</code></li>
  <li><code class="language-plaintext highlighter-rouge">echo [1-13]???????</code></li>
  <li><code class="language-plaintext highlighter-rouge">echo [145]*[!abtg]</code></li>
  <li><code class="language-plaintext highlighter-rouge">echo [xyt]*[^xyt]</code> veya <code class="language-plaintext highlighter-rouge">echo [xyt]*[!xyt]</code></li>
  <li><code class="language-plaintext highlighter-rouge">echo [mno]*[abt]</code></li>
  <li><code class="language-plaintext highlighter-rouge">echo [ab]*[xy]*</code></li>
  <li><code class="language-plaintext highlighter-rouge">echo [0-5]*[a-z]</code></li>
  <li><code class="language-plaintext highlighter-rouge">echo [pq]*xyz*</code></li>
  <li><code class="language-plaintext highlighter-rouge">echo *linux*</code></li>
  <li><code class="language-plaintext highlighter-rouge">echo ab*123*</code></li>
  <li><code class="language-plaintext highlighter-rouge">echo a????*</code></li>
  <li><code class="language-plaintext highlighter-rouge">echo [xy]*x</code></li>
  <li><code class="language-plaintext highlighter-rouge">echo *[!abc]*</code></li>
  <li><code class="language-plaintext highlighter-rouge">echo [A-Z]*[0-9]*[0-9]*</code></li>
  <li><code class="language-plaintext highlighter-rouge">echo [a-z][a-z]*.txt</code></li>
  <li><code class="language-plaintext highlighter-rouge">echo [0-9][a-z][a-z][a-z]*</code></li>
</ol>

<p>Örnek alıştırmalar burada son buldu fakat elbette benzer şekilde daha fazlası için kendi kendinize olası filtreleme problemleri tasarlayabilirsiniz.</p>

<p></p>
          <div align="center" class="custom-control custom-switch">
                
            <input type="checkbox" class="custom-control-input" id="readCheckbox"  onchange="markAsRead()">
            <label class="custom-control-label" for="readCheckbox">Okundu Olarak İşaretle  </label>
          </div>
          <p></p>
          <div align="center">
            <button id="linkedinShareButton" class="mavi btn btn-outline-primary">
              <svg width="24px" height="24px" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" fill="none"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"><path fill="#0A66C2" d="M12.225 12.225h-1.778V9.44c0-.664-.012-1.519-.925-1.519-.926 0-1.068.724-1.068 1.47v2.834H6.676V6.498h1.707v.783h.024c.348-.594.996-.95 1.684-.925 1.802 0 2.135 1.185 2.135 2.728l-.001 3.14zM4.67 5.715a1.037 1.037 0 01-1.032-1.031c0-.566.466-1.032 1.032-1.032.566 0 1.031.466 1.032 1.032 0 .566-.466 1.032-1.032 1.032zm.889 6.51h-1.78V6.498h1.78v5.727zM13.11 2H2.885A.88.88 0 002 2.866v10.268a.88.88 0 00.885.866h10.226a.882.882 0 00.889-.866V2.865a.88.88 0 00-.889-.864z"></path></g></svg>
              Paylaş
            </button>
            <button id="twitterShareButton" class="mavi btn btn-outline-primary">
              <svg width="24px" height="24px" viewBox="0 -4 48 48" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000000"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <title>Twitter-color</title> <desc>Created with Sketch.</desc> <defs> </defs> <g id="Icons" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"> <g id="Color-" transform="translate(-300.000000, -164.000000)" fill="#00AAEC"> <path d="M348,168.735283 C346.236309,169.538462 344.337383,170.081618 342.345483,170.324305 C344.379644,169.076201 345.940482,167.097147 346.675823,164.739617 C344.771263,165.895269 342.666667,166.736006 340.418384,167.18671 C338.626519,165.224991 336.065504,164 333.231203,164 C327.796443,164 323.387216,168.521488 323.387216,174.097508 C323.387216,174.88913 323.471738,175.657638 323.640782,176.397255 C315.456242,175.975442 308.201444,171.959552 303.341433,165.843265 C302.493397,167.339834 302.008804,169.076201 302.008804,170.925244 C302.008804,174.426869 303.747139,177.518238 306.389857,179.329722 C304.778306,179.280607 303.256911,178.821235 301.9271,178.070061 L301.9271,178.194294 C301.9271,183.08848 305.322064,187.17082 309.8299,188.095341 C309.004402,188.33225 308.133826,188.450704 307.235077,188.450704 C306.601162,188.450704 305.981335,188.390033 305.381229,188.271578 C306.634971,192.28169 310.269414,195.2026 314.580032,195.280607 C311.210424,197.99061 306.961789,199.605634 302.349709,199.605634 C301.555203,199.605634 300.769149,199.559408 300,199.466956 C304.358514,202.327194 309.53689,204 315.095615,204 C333.211481,204 343.114633,188.615385 343.114633,175.270495 C343.114633,174.831347 343.106181,174.392199 343.089276,173.961719 C345.013559,172.537378 346.684275,170.760563 348,168.735283" id="Twitter"> </path> </g> </g> </g></svg>
              Paylaş
            </button>
            <p></p>
            <h5>📮 Hata, eksik ve öneri bildirimlerinizi <a href="https://superua1.github.io//bildirim.html">buradan</a> iletebilirsiniz. </h5>
          </div>

        <p></p>



  

  

  

  

  

  

  

  

  
    
    
    
    


<div data-pagefind-ignore="all" class="row mb-2">
  
      
    <div class="col-md-6">
      <div class="no-gutters border rounded overflow-hidden flex-md-row mb-4 shadow-sm h-md-250 position-relative">
        <div class="col p-4 d-flex flex-column position-static">
          <div class="row">
            <div align="left" class="align-self-center col-2">
              <svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 320 512">
                <!--! Font Awesome icon code -->
                <path d="M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l192 192c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L77.3 256 246.6 86.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-192 192z" fill="currentColor"/>
              </svg>
            </div>
            <div align="right" class="col-10">
              <div class="mb-1 text-muted"><strong>Önceki</strong></div>
              <p class="card-text">Dizinlerde Gezinmek</p>
            </div>
          </div>
          <a href="https://superua1.github.io//egitim/dizinlerde-gezinmek/" title="Dizinlerde Gezinmek" class="stretched-link"></a>
        </div>
      </div>
    </div>
  

  
      
    <div class="col-md-6">
      <div class="no-gutters border rounded overflow-hidden flex-md-row mb-4 shadow-sm h-md-250 position-relative">
        <div class="col p-4 d-flex flex-column position-static">
          <div class="row">
            <div align="left" class="col-10">
              <div class="mb-1 text-muted"><strong>Sonraki</strong></div>
              <p class="card-text">Metinsel Verileri İşlemek</p>
            </div>
            <div align="right" class="align-self-center col-2">
              <svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 320 512">
                <!--! Font Awesome icon code -->
                <path d="M310.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-192 192c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L242.7 256 73.4 86.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l192 192z" fill="currentColor"/>
              </svg>
            </div>
          </div>
          <a href="https://superua1.github.io//egitim/metinsel-verileri-islemek/" title="Metinsel Verileri İşlemek" class="stretched-link"></a>
        </div>
      </div>
    </div>
  
</div>


      </div>

      <div class="col-md-3">
        <p></p>
        <div class="no-gutters border rounded overflow-hidden flex-md-row mb-4 shadow-sm h-md-250 position-relative">
          <h3 align="center" class="mavi">Sayfa İçeriği</h3>
          <div data-pagefind-subpage>
            <ul id="toc" class="section-nav">
<li class="toc-entry <hh1"><a href="#kabuk-üzerinde-genişletme">Kabuk Üzerinde Genişletme</a></li>
<li class="toc-entry <hh1"><a href="#süslükıvırcık-parantez-küme-ayracı-genişletmesi">Süslü(Kıvırcık) Parantez-Küme Ayracı Genişletmesi</a></li>
<li class="toc-entry <hh1"><a href="#dosya-i̇smi-genişletme">Dosya İsmi Genişletme</a>
<ul>
<li class="toc-entry <hh3"><a href="#yıldız-karakteri">Yıldız Karakteri</a></li>
<li class="toc-entry <hh3"><a href="#soru-i̇şareti">Soru İşareti</a></li>
<li class="toc-entry <hh3"><a href="#köşeli-parantez">Köşeli Parantez</a></li>
<li class="toc-entry <hh3"><a href="#hariç-tutmak">Hariç Tutmak</a></li>
<li class="toc-entry <hh2"><a href="#regex">Regex</a></li>
<li class="toc-entry <hh2"><a href="#alıntı-karakterleri">Alıntı Karakterleri</a></li>
</ul>
</li>
<li class="toc-entry <hh1"><a href="#komut-i̇kamesi-genişletmesi">Komut İkamesi Genişletmesi</a></li>
<li class="toc-entry <hh1"><a href="#alıştırmalar">Alıştırmalar</a>
<ul>
<li class="toc-entry <hh2"><a href="#sorular">Sorular</a></li>
<li class="toc-entry <hh2"><a href="#yanıtlar">Yanıtlar</a></li>
</ul>
</li>
</ul>
          </div>
        </div>
        <p></p>

	  
	  
      <div class="no-gutters border rounded overflow-hidden flex-md-row mb-4 shadow-sm h-md-250 position-relative">
        <div class="col p-4 d-flex flex-column position-static">
			<p align="center" class="mavi text-primary">Video Eğitim</p>
		<img src="https://superua1.github.io//video-egitim.png"/>
          <p class="card-text mb-auto">Buradaki anlatımları, video eğitim üzerinden takip etmek ve gerektiğinde soru sorabilmek isterseniz kursa gözatın.</p>
         <a href="https://www.udemy.com/course/kali-linux-ile-sifirdan-temel-linux-egitimi/?referralCode=04ABD09E6ED5DA93F7A2" class=" stretched-link"></a>
        </div>
        </div>
  
        <p></p>

	  
	  
      <div class="no-gutters border rounded overflow-hidden flex-md-row mb-4 shadow-sm h-md-250 position-relative">
        <div class="col p-4 d-flex flex-column position-static">
			<p align="center" class="kirmizi text-danger">Kitap</p>
		<img src="https://superua1.github.io//kitap.png"/>
          <p class="card-text mb-auto">Linux sistem yönetimine giriş için kitap arıyorsnız gözatın.</p>
         <a href="https://www.udemy.com/course/kali-linux-ile-sifirdan-temel-linux-egitimi/?referralCode=04ABD09E6ED5DA93F7A2" class=" stretched-link"></a>
        </div>
        </div>
  
      </div>
	  
    </div>
</div>
  
  <hr>

<footer class="container py-5">
  <div class="row">
    <div class="col-6 col-md">
 <h5><a href="/">Linux Dersleri</a> | <a target="_blank" href="https://github.com/Linux-Dersleri/linux-dersleri.github.io"><i class="fa fa-github fa-lg"></i></a></h5>
 <p class="small">GNU/Linux için Türkçe içerik sağlamak üzere kurulmuş bir platformdur.</p>
	 
	  
    </div>
    <div class="col-6 col-md">
      <h5>Eğitim Serileri</h5>
      <ul class="list-unstyled text-small">
        <li><a class="text-muted" href="#">Sıralı Doküman</a></li>
        <li><a class="text-muted" href="#">Video Eğitim</a></li>
      </ul>
    </div>
    
  
    <div class="col-6 col-md">
      <h5>Hakkında</h5>
      <ul class="list-unstyled text-small">
        <li><a class="text-muted" href="https://superua1.github.io//sıkca-sorulan-sorular.html">S.S.S.</a></li>
        <li><a class="text-muted" href="https://superua1.github.io//gizlilik.html">Veri Politikası</a></li>
        <li><a class="text-muted" href="https://superua1.github.io//bildirim.html">Geri Bildirim</a></li>
		<li><a class="text-muted" href="mailto: info@linuxdersleri.net">İletişim</a></li>
      </ul>
    </div>
	<div class="col-6 col-md">
      <h5>Android Uygulaması</h5>
      <ul class="list-unstyled text-small">
        <a href='https://play.google.com/store/apps/details?id=com.bildik.linuxdersleri&pcampaignid=pcampaignidMKT-Other-global-all-co-prtnr-py-PartBadge-Mar2515-1'><img style="width: 75%;" alt='Google Play'den alın' src='https://play.google.com/intl/en_us/badges/static/images/badges/tr_badge_web_generic.png'/></a>
	  </ul>
	  
    </div>
  </div>
</footer>


<script src="https://superua1.github.io//assets/js/jquery-3.3.1.slim.min.js"></script>
<script src="https://superua1.github.io//assets/js/script.js"></script>		
<script src="https://superua1.github.io//assets/js/bootstrap.min.js"></script>

<script>
    // Twitter share button functionality
    var twitterShareButton = document.getElementById("twitterShareButton");
        twitterShareButton.addEventListener("click", function() {
          var tweetText = " #Linux Dersleri platformundaki \"Kabuk Genişletmeleri\" içeriğini faydalı bulduğum için paylaşmak istedim. https://superua1.github.io//egitim/kabuk-genisletmeleri/";
          var tweetUrl = "https://twitter.com/intent/tweet?text=" + encodeURIComponent(tweetText);
          window.open(tweetUrl, "_blank");
        });
  
        // LinkedIn share button functionality
        var linkedinShareButton = document.getElementById("linkedinShareButton");
        linkedinShareButton.addEventListener("click", function() {
          var postUrl = "https://www.linkedin.com/sharing/share-offsite/?mini=true&url=https://superua1.github.io//egitim/kabuk-genisletmeleri/&title=Kabuk Genişletmeleri&summary=\"Kabuk Genişletmeleri\" içeriğini faydalı bulduğum için paylaşmak istedim.";
          window.open(postUrl, "_blank");
        });
        </script>
<script src="https://superua1.github.io//assets/js/read.js"></script>
<script src="https://superua1.github.io//assets/js/zooming.min.js"></script>
<script>
   // Listen to images after DOM content is fully loaded
   document.addEventListener('DOMContentLoaded', function () {
        new Zooming({
          // options...
        }).listen('.img-zoomable')
      })
</script>
</body>

</html>
