<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="utf-8">
<link rel="icon" href="/logo.svg" type="image/svg+xml" />
<title>Linux Dersleri | Metinsel Verileri İşlemek &#8211; Linux Eğitimi</title>
<meta name="description" content="Metinsel verileri işlemek adına Linux'un dosyalara yaklaşımını ele alıyoruz.">
<meta name="keywords" content="yönlendirmeler, cat, tac, rev, touch, echo, paste, sort, shuf, nl, wc">








<link rel="canonical" href="https://superua1.github.io//egitim/metinsel-verileri-islemek/">
<link href="https://superua1.github.io//feed.xml" type="application/atom+xml" rel="alternate" title="Linux Eğitimi Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="https://superua1.github.io//assets/css/font-awesome.min.css">
<link rel="stylesheet" href="https://superua1.github.io//assets/css/bootstrap.min.css">
<link rel="stylesheet" href="https://superua1.github.io//assets/css/style.css">


<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="https://superua1.github.io//favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="https://superua1.github.io//favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="https://superua1.github.io//images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="https://superua1.github.io//images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="https://superua1.github.io//images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://superua1.github.io//images/apple-touch-icon-144x144-precomposed.png">

<link rel="stylesheet" href="https://superua1.github.io//assets/css/read.css">
<style>
 .grid {
        column-count: 2;
        column-gap: 1rem;
      }

  </style>
</head>
<body>

<div class="bs-canvas-overlay bs-canvas-anim bg-dark position-fixed w-100 h-100"></div>
<nav class="navbar x-navbar sticky-top navbar-expand-lg navbar-light bg-light border-bottom">
	
  <div class="collapse navbar-collapse">
    <a class="navbar-brand active" href="https://superua1.github.io//">
      <img src="https://superua1.github.io//logo.svg" width="30" height="30" class="align-top" alt="">
      Linux Dersleri
    </a>
    <ul class="navbar-nav">
      <li class="nav-item active">
        <a class="nav-link" href="https://superua1.github.io//egitim.html">Eğitimler</a>
      </li>
      <li class="nav-item active">
        <a class="nav-link" href="https://superua1.github.io//blog/">Blog</a>
      </li>
	  <li class="nav-item active">
        <a class="nav-link" href="https://superua1.github.io//komutlar">Komut Listesi</a>
      </li>
	  <li class="nav-item active">
        <a class="nav-link" href="https://superua1.github.io//test">Test</a>
      </li>
      <li class="nav-item active">
        <a class="nav-link" href="https://superua1.github.io//etiketler">Etiketler</a>
      </li>
	 <li class="nav-item active">
        <a class="nav-link" href="https://superua1.github.io//hakkında.html">Hakkında</a>
      </li>
    </ul>
	
  </div>
 
<a class="btn" data-toggle="modal" data-target="#searchModal"><i class="fa fa-search" style="width:16px;height:16px"></i></a>
	<a onclick="tema()" class="btn" ><i class="fa fa-adjust fa-lg"></i></a> 
	<a href="https://superua1.github.io//bildirim.html" class="btn" ><i class="fa fa-paper-plane"></i></a> 
</nav>	
<nav class="navbar y-navbar sticky-top navbar-expand-lg navbar-light bg-light border-bottom">
<button class="btn"  data-toggle="canvas" data-target="#bs-canvas-left" aria-expanded="false" aria-controls="bs-canvas-left"><i class="fa fa-align-justify fa-lg"></i></button>
		<a href="https://superua1.github.io//" class="btn"  ><i class="fa fa-home fa-lg"></i></a>     
	<a class="btn" data-toggle="modal" data-target="#searchModal"><i class="fa fa-search" style="width:16px;height:16px"></i></a>
		
		<a onclick="tema()" class="btn" ><i class="fa fa-adjust fa-lg"></i></a> 
		<a href="https://superua1.github.io//bildirim.html" class="btn" ><i class="fa fa-paper-plane"></i></a> 
		
</nav>

<div style="background-color: var(--background);" id="bs-canvas-left" class="bs-canvas bs-canvas-anim bs-canvas-left position-fixed h-100" >
   <div class="container">
    
      <a class="btn bs-canvas-close close" aria-label="Close">
        <span aria-hidden="true">&times;</span>
      </a>
      <a class="navbar-brand" href="https://superua1.github.io//">
        <img src="https://superua1.github.io//logo.svg" width="30" height="30" class="align-top" alt="">
        Linux Dersleri
      </a>
  
    
    
   <hr>
 <a data-toggle="modal" data-target="#searchModal" class="btn">🕵️ Arama</a>
  <a href="https://superua1.github.io//egitim" class="btn">🎓 Eğitimler</a>
  <a href="https://superua1.github.io//blog" class="btn">🗃️ Blog</a>
  <a href="https://superua1.github.io//komutlar" class="btn">📜 Komut Listesi</a>
  <a href="https://superua1.github.io//test" class="btn">🎯 Test</a>
  <a href="https://superua1.github.io//etiketler" class="btn">🏷️ Etiketler</a>
  <a href="https://superua1.github.io//hakkında.html" class="btn">🐧 Hakkında</a>
 
  <a href="https://superua1.github.io//bildirim.html" class="btn">📮 Geri Bildirim</a>
  <hr>
  
  <div align="center">
  <h5>Android Uygulaması</h5>
      <ul class="list-unstyled text-small">
        <a href="https://play.google.com/store/apps/details?id=com.bildik.linuxdersleri&amp;pcampaignid=pcampaignidMKT-Other-global-all-co-prtnr-py-PartBadge-Mar2515-1"><img style="width: 75%;" alt="Google Play" den="" alın'="" src="https://play.google.com/intl/en_us/badges/static/images/badges/tr_badge_web_generic.png"></a>
	  </ul>
	  <hr>
 <h5><a href="/">Linux Dersleri</a> | <a target="_blank" href="https://github.com/Linux-Dersleri/linux-dersleri.github.io"><i class="fa fa-github fa-lg"></i></a></h5>
 <p class="small">GNU/Linux için Türkçe içerik sağlamak üzere kurulmuş bir platformdur.</p>

	  </div>
    
</div>

</div>



<!-- Modal -->
<div class="modal fade" id="searchModal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
  <div class="modal-dialog" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="searchModalLabel">🕵️ Site Geneli Arama:</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <link href="https://superua1.github.io//pagefind/pagefind-ui.css" rel="stylesheet">
<script src="https://superua1.github.io//pagefind/pagefind-ui.js" type="text/javascript"></script>

<div id="search"></div>
<script>

    window.addEventListener('DOMContentLoaded', (event) => {
        new PagefindUI({ element: "#search", showImages: false });
		
    });
	
</script>
      </div>

    </div>
  </div>
</div>

<script src="https://superua1.github.io//assets/js/jquery-3.3.1.slim.min.js" type="text/javascript"></script>
<div id="progress-bar-container">
  <div id="progress-bar"></div>
</div>
      <div class="container-fluid">
  <div class="row mb-2">
      <div style="font-size: 18px;" class="col-md-9" data-pagefind-filter="Bölüm:Eğitim Serisi:">
        	<h1 align="center">9. Ders: Metinsel Verileri İşlemek</h1> 
<div align="center"><i class="fa fa-tags" aria-hidden="true"></i>
          <a href="https://superua1.github.io//etiketler.html#yönlendirmeler" class="btn btn-outline-primary btn-sm" title="Pages tagged yönlendirmeler">yönlendirmeler</a> <a href="https://superua1.github.io//etiketler.html#cat" class="btn btn-outline-primary btn-sm" title="Pages tagged cat">cat</a> <a href="https://superua1.github.io//etiketler.html#tac" class="btn btn-outline-primary btn-sm" title="Pages tagged tac">tac</a> <a href="https://superua1.github.io//etiketler.html#rev" class="btn btn-outline-primary btn-sm" title="Pages tagged rev">rev</a> <a href="https://superua1.github.io//etiketler.html#touch" class="btn btn-outline-primary btn-sm" title="Pages tagged touch">touch</a> <a href="https://superua1.github.io//etiketler.html#echo" class="btn btn-outline-primary btn-sm" title="Pages tagged echo">echo</a> <a href="https://superua1.github.io//etiketler.html#paste" class="btn btn-outline-primary btn-sm" title="Pages tagged paste">paste</a> <a href="https://superua1.github.io//etiketler.html#sort" class="btn btn-outline-primary btn-sm" title="Pages tagged sort">sort</a> <a href="https://superua1.github.io//etiketler.html#shuf" class="btn btn-outline-primary btn-sm" title="Pages tagged shuf">shuf</a> <a href="https://superua1.github.io//etiketler.html#nl" class="btn btn-outline-primary btn-sm" title="Pages tagged nl">nl</a> <a href="https://superua1.github.io//etiketler.html#wc" class="btn btn-outline-primary btn-sm" title="Pages tagged wc">wc</a>   
		 <p></p> 
		  <div align="center" class="col-sm-3">
		<img class="responsive" src="https://superua1.github.io//egitim/metinselveriislemekcover.png" alt="">
		  </div>	</div>	  

		  <hr>	
		  <h6 align="right" id="meta-da">
			<i class="fa fa-clock-o" aria-hidden="true"></i>

87 dk.


		   

  <i class="fa fa-user" aria-hidden="true"></i><a href="https://superua1.github.io//hakkında.html"> Taylan Özgür Bildik</a>


		  
		  </h6>  
		  
		  
        <h1 id="her-şey-bir-dosyadır--her-şey-bir-bayt-akışıdır">Her Şey Bir Dosyadır | Her Şey Bir Bayt Akışıdır</h1>

<p>Artık sizin de çok iyi bildiğiniz gibi sistemimizi komut satırı arayüzünden yönetiyorken iletişim dili için yazıyı diğer bir deyişle metinsel verileri kullanıyoruz. Yani komutlarımızı yazılı şekilde girip, sonuçlarını da yine yazılı şekilde takip ediyoruz. Dolayısıyla sistemi etkili şekilde yönetebilmek için metinsel verileri rahatça görüntüleyip gerektiğinde ihtiyaçlarımıza göre düzenleyip kullanabilmemiz şart. Görüntüleme ve düzenleme işlemleri için komut satırı üzerinde kullanabileceğimiz çok çeşitli araçlar mevcut. Bu bölümde temel bazı araçlardan bahsediyor olacağız. Fakat bundan önce genel işleyişten haberdar olmak için bahsetmemiz gereken birkaç temel konu var.</p>

<p>Eğer daha önce az çok Linux ile haşır neşir olduysanız ve biraz da meraklıysanız “<strong><em>Linux üzerinde her şey bir dosyadır</em></strong>” sözünü mutlaka duymuşsunuzdur.</p>

<p>Her şey bir dosyadır tanımı, klavyenizin, dosyaların, dizinlerin, aygıtların ve benzeri tüm yapıların birer dosya olarak tanımlanıp, çekirdekteki sanal dosya sistemi katmanı üzerinde soyutlanmış olan dosya tanımlayıcılar ile temsil edildiğini belirtmek için kullanılıyor. Yani “Her şey bir dosyadır” ifadesi, işletim sisteminin genel mimari yaklaşımını özetliyor. Muhtemelen bu söylediklerim çok açık gelmedi, çünkü henüz bahsetmediğimiz kavramları kullanarak açıklamış oldum. Ancak merak etmeyin anlatımın devamında açıklamalarım sizin için de netleşmiş olacak.</p>

<p>Linux çekirdeğinin yapısı gereği, sistem üzerindeki tüm yapıların dosya gibi ele alındığından bahsettik. Bu yaklaşımın tercih edilme nedeni dosyalar üzerinde işlem yapmanın herkes için çok kolay olması. Siz standart bir kullanıcı olarak yetkiniz olan istediğiniz bir dosyayı okuyabilir veya dosyaya yeni veriler ekleyebilirsiniz. Yani dosya okumak veya dosyaya veri eklemek çok kolay. Tüm yapılar dosya gibi ele alındığında da hepsini dosya yönetir gibi esnek ve kolay şekilde yönetme imkanına sahip oluyoruz. Aslında bu yaklaşım sayesinde tüm sistemdeki yapıları ve araçları yönetebileceğimiz ortak bir iletişim yolu da ortaya çıkmış oluyor.</p>

<p>Yani özünde tüm mesele bayt akışını kontrol etmekten ibaret. Araçların ürettiği çıktıları ve alacakları girdileri ihtiyaçlarımıza göre yönettiğimizde işlerimizi komut satırı üzerinden yerine getirebiliyoruz. Örneğin ben X isimli bir aracın ürettiği çıktıları Y isimli bir araca girdi olarak kolaylıkla bağlayıp birden fazla aracı işimi yerine getirmek için kullanabilirim. Ya da bir aracın talep ettiği girdileri bir dosyadan yönlendirip, aracın bu dosyadaki verileri işlemesini sağlayabilirim. Hatta daha deneyimli bir kullanıcıysam, sistem üzerindeki çeşitli dosyaları inceleyerek sistemin mevcut durumu hakkında bilgi almam da mümkün çünkü sistem üzerinde her şey bir dosya gibi temsil ediliyor. Özetle Linux çekirdeğimiz donanımlar ile gereken alt seviyeli iletişimi kendisi sağlayıp bize sade ve okunaklı şekilde sanal dosyalar sunduğu için pek çok aracı ve yapıyı rahatlıkla denetleyip yönetebiliyoruz.</p>

<p>Söz konusu dosya içeriklerini yönetmek olduğunda da her şey en temelde bayt akışını nasıl kontrol ettiğimize kalıyor. Bir aracın çıktılarını başka bir araca girdi olarak iletebilmek için bu bayt akışını ilgili araca yönlendirebiliyor olmamız gerekiyor.</p>

<h1 id="yönlendirmeler">Yönlendirmeler</h1>

<p>Linux üzerinde baytları bir kaynaktan diğerine iletmek için yönlendirme mekanizmasından faydalanabiliyoruz.</p>

<p>Yönlendirme işlemi için Linux üzerinde standart şekilde her bir dosyanın, girdileri okuduğu ve çıktılarını ürettiği uç noktaları mevcuttur. Bu uç noktalara da “dosya tanımlayıcıları” deniyor. Ve temelde 3 tür dosya tanımlayıcı bulunuyor. Normalde biz aksini belirtmediğimiz sürece bu uçlar konsol aracına bağlı oluyor. Bu sebeple veri girişini konsoldan yapıp, hatalı ve hatasız olan çıktıları yine konsol üzerinde görüyoruz. Söylediklerim hala size anlamlı gelmiyorsa lütfen biraz daha sabırlı olun çünkü aslında son derece basit bir yapı.</p>

<p>Bir dosyaya <strong>veri girişi</strong> yapmak istiyorsak o dosyanın standart girdisi olarak temsil edilen <strong>0</strong> numaralı dosya tanımlayıcısına verileri yönlendirmemiz gerekiyor.</p>

<p>Eğer bir dosyanın <strong>hatasız standart çıktılarını</strong> başka bir yere yönlendirmek istiyorsak bu çıktıları <strong>1</strong> numaralı dosya tanımlayıcısı üzerinden okumamız gerekiyor.</p>

<p>Eğer bir dosyanın yani örneğin bir aracın ürettiği <strong>hatalı çıktılarını</strong> başka bir yere yönlendirmek istiyorsak da bunun için <strong>2</strong> numaralı dosya tanımlayıcısını kullanmamız gerekiyor.</p>

<p>Linux üzerinde her şey dosya gibi ele alındığı için konsol aracı da <strong><em>/dev/tty</em></strong> isimli dosya ile temsil ediliyor. Yani veri girişi yaparken ve hatalı-hatasız çıktıları alırken aşağıdaki gibi işleyiş mevcut.</p>

<p><img src="https://superua1.github.io//egitim/metin/1.png" alt="1.png" class="responsive img-zoomable" /></p>

<p>Hemen somut bir örnek üzerinden görelim. Ben test edebilmek için aynı anda hem hatalı hem de hatasız çıktılar üreten basit bir betik dosyası oluşturmak istiyorum.</p>

<p>Bunun için <code class="language-plaintext highlighter-rouge">cat &gt; test.sh</code> komutunu girip, sırasıyla hatasız ve hatalı çıktıları üretecek olan komutları girip <kbd>Ctrl</kbd>+<kbd>d</kbd> kısayolu ile verilen dosyaya yazılmasını sağlayalım.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat</span> <span class="o">&gt;</span> test.sh
<span class="nb">echo</span> <span class="s2">"Bu hatasız bir çıktı"</span>
asdf
┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="err">$</span>
</code></pre></div></div>

<p>Şimdi bu dosyanın çalıştırabilmesi için <code class="language-plaintext highlighter-rouge">chmod +x test.sh</code> komutu ile yetki verip, hemen <code class="language-plaintext highlighter-rouge">./test.sh</code> komutu ile betik dosyamızı çalıştırıp test edelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">chmod</span> +x test.sh 

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>./test.sh 
Bu hatasız bir çıktı
./test.sh: line 2: asdf: <span class="nb">command </span>not found

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="err">$</span>
</code></pre></div></div>

<p>Bakın hem hatasız hem de hatalı çıktılar almış olduk. Betik dosyasındaki  <code class="language-plaintext highlighter-rouge">echo "Bu hatasız bir çıktı"</code> komutu hatasız çıktı üretirken, <code class="language-plaintext highlighter-rouge">asdf</code> isimli bir komut olmadığı için bu komut da hatalı çıktı üretmiş oldu. Biz bu çıktıları özellikle herhangi bir adrese yönlendirmediğimiz için bu çıktılar konsolumuza bastırıldı. Konsola bastırmak yerine istediğimiz isimde bir dosyaya yönlendirebiliriz. Öncelikle hatasız çıktıları yönlendirmeyi deneyelim.</p>

<h2 id="hatasız-çıktıları-yönlendirmek--standart-output">Hatasız Çıktıları Yönlendirmek | Standart Output</h2>

<p>Hatasız çıktılar “<strong>standart çıktı</strong>” olarak ifade ediliyor ve <strong>1</strong> numaralı dosya tanımlayıcısı ile temsil ediliyor. Ben denemek için <code class="language-plaintext highlighter-rouge">./test.sh 1&gt; hatasız.txt</code> komutu ile hatasız çıktıları “<strong><em>hatasız.txt</em></strong>” dosyaya yönlendiriyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>./test.sh 1&gt; hatasız.txt
./test.sh: line 2: asdf: <span class="nb">command </span>not found

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>
</code></pre></div></div>

<p>Gördüğünüz gibi konsola <strong>yalnızca hatalı olan çıktılar</strong> bastırıldı çünkü ben hatasız olan çıktıları bu “<strong><em>hatasız.txt</em></strong>” dosyasına yönlendirdim. Dolayısıyla konsola bastırılacak hatasız bir çıktı kalmadı. Şimdi <code class="language-plaintext highlighter-rouge">cat</code> komutu ile hatasız dosyasını okuyup içeriğine bakalım.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat </span>hatasız.txt                                  
Bu hatasız bir çıktı
</code></pre></div></div>

<p>Bakın hatasız çıktı da bu dosyaya kaydolmuş. Şema üzerinden bakacak olursak, girdiğimiz komuttaki yönlendirme aşağıdaki gibi temsil edebilir.</p>

<p><img src="https://superua1.github.io//egitim/metin/2.png" alt="2.png" class="responsive img-zoomable" /></p>

<p>Burada hatasız olan çıktıları yönlendirmek için <code class="language-plaintext highlighter-rouge">1&gt;</code> operatörünü kullandık ama aslında standart çıktılar varsayılan olarak yalnızca tek bir büyüktür <code class="language-plaintext highlighter-rouge">&gt;</code> işareti ile de yönlendirilebiliyor. Hemen deneyelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>./test.sh <span class="o">&gt;</span> hatasız2.txt                         
./test.sh: line 2: asdf: <span class="nb">command </span>not found

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat </span>hatasız2.txt 
Bu hatasız bir çıktı
</code></pre></div></div>

<p>Bakın yine yalnızca hatalı olan çıktılar konsola bastırıldı. Yani standart çıktıları temsil eden 1 numaralı dosya tanımlayıcıyı özellikle belirtmeden yalnızca büyüktür operatörü ile de standart çıktıları istediğimiz yere yönlendirebiliyoruz.</p>

<h2 id="hatalı-çıktıları-yönlendirmek--standart-error">Hatalı Çıktıları Yönlendirmek | Standart Error</h2>

<p>Nasıl ki üretilen “hatasız çıktılar” “standart çıktı” olarak isimlendiriliyorsa, üretilen “<strong>hatalı çıktılar</strong>” da  “<strong>standart hata</strong>” çıktıları olarak ifade ediliyor ve <strong>2</strong> numaralı dosya tanımlayıcı ile temsil ediliyor.</p>

<p>Yani örneğin ben betik dosyasının ürettiği hatalı çıktıları bir dosyaya yönlendirmek istersem büyüktür yönlendirme operatörü ile <code class="language-plaintext highlighter-rouge">2&gt;</code> şeklinde özellikle belirtmem gerekiyor. Hemen denemek için <code class="language-plaintext highlighter-rouge">./test.sh 2&gt; hatalı.txt</code> şeklinde komutumuzu girelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>./test.sh 2&gt; hatalı.txt               
Bu hatasız bir çıktı

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat </span>hatalı.txt                                   
./test.sh: line 2: asdf: <span class="nb">command </span>not found
</code></pre></div></div>

<p>Bakın hatalı çıktıları bu dosyaya yönlendirdiğimiz için bu kez da konsola yalnızca hatasız olan çıktılar bastırıldı. Yönlendirme yaptığımız dosyanın içeriğini ise yalnızca hatalı çıktı bulunuyor çünkü ben betik dosyasının ürettiği hatalı çıktıları <strong>2</strong> numaralı dosya tanımlayıcı ve buradaki büyüktür yönlendirme operatörü ile bu dosyaya yönlendirdim. Şema üzerinden bakacak olursak, girdiğimiz komuttaki yönlendirme aşağıdaki gibi temsil edebilir.</p>

<p><img src="https://superua1.github.io//egitim/metin/3.png" alt="3.png" class="responsive img-zoomable" /></p>

<p>İşte bu örneklerde ele aldığımız gibi ihtiyacımıza göre hatasız ve hatalı olan çıktıları istediğimiz bir dosyaya yönlendirebiliyoruz.</p>

<p>Örneğin bir aracın ürettiği hatalı çıktıları görmek istemezseniz , yalnızca hatalı çıktıları yok etmek için bunları <strong><em>/dev/null</em></strong> dosyasına yönlendirebilirsiniz. <strong><em>/dev/</em></strong> dizini altındaki <strong><em>null</em></strong> dosyası, kendisine gönderilen tüm verileri yutmak için çekirdek tarafından sağlanan sanal bir dosya. Biz buraya çıktı yönlendirdiğimizde ilgili çıktı hiç bir yere kaydolmuyor, yani aslında çıktıları boşluğa yönlendirmiş oluyoruz. Bu sayede araçların ürettiği hatalı çıktılardan kolayca kurtulmamız da mümkün oluyor.</p>

<p>Denemek için <code class="language-plaintext highlighter-rouge">./test.sh 2&gt; /dev/null</code> şeklinde komutumuzu girebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>./test.sh 2&gt; /dev/null
Bu hatasız bir çıktı

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="err">$</span>
</code></pre></div></div>

<p>Bakın konsola yalnızca hatasız olan çıktı bastırıldı çünkü hatalı olanları <strong><em>/dev/</em></strong> dizini altındaki <strong><em>null</em></strong> dosyasına yönlendirdik. Şimdi hatalı çıktılara ne olduğunu görmek için çıktıları yönlendirdiğimiz  <strong><em>/dev/null</em></strong> dosyasının içeriğini okumayı deneyebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat</span> /dev/null

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="err">$</span>
</code></pre></div></div>

<p>Bakın herhangi bir çıktı almadık çünkü aslında bu dosya verileri boşluğa göndermek için kullanılan sanal bir dosya. Biz yönlendirsek de içerisinde hiç bir veri tutmuyor çünkü bu dosya bizim bildiğimiz standart dosyalardan değil. Daha önce Linux üzerinde her şeyin bir dosya gibi ele alından bahsetmiştik. İşte bu dosya da bu yaklaşımın bir sonucu. Siz de istemediğiniz tüm verileri <strong><em>/dev/null</em></strong> dosyasına yönlendirip onlardan kurtulabilirsiniz. Üstelik bu dosya disk üzerinde yer alan gerçek bir dosya olmadığı için disk üzerinde okuma yazma yükü oluşturmuyor. Bu ve benzeri dosyalar çekirdek tarafından sanal olarak oluşturulan ve bellek yani geçici hafıza üzerinden çalıştırılan sözde dosyalardır. Bu yaklaşım sayesinde disk üzerinde yük oluşturma durumundan da endişe etmemize gerek kalmıyor.</p>

<p>Şema üzerinden bakacak olursak, girdiğimiz komuttaki yönlendirme aşağıdaki gibi temsil edebilir.</p>

<p><img src="https://superua1.github.io//egitim/metin/4.png" alt="4.png" class="responsive img-zoomable" /></p>

<p>Tekrar asıl konumuza dönecek olursak, hatalı ve hatasız çıktıları ayrı ayrı nasıl yönlendirebileceğimizden açıkça bahsettim. Fakat kimi zaman ayrı ayrı yönlendirmek yerine tüm çıktıları tek bir adrese yönlendirmek de isteyebiliriz.  Bu işlem için yönlendirme operatöründen önce “ve” “<code class="language-plaintext highlighter-rouge">&amp;</code>” işaretini yani “<strong>ampersant</strong>” işaretini ekleyip <code class="language-plaintext highlighter-rouge">&amp;&gt;</code> operatörünü kullanabiliyoruz. Buradaki ampersant olarak da bilinen “<code class="language-plaintext highlighter-rouge">&amp;</code>” işaretini hem <strong>hatalı</strong> ve hem de <strong>hatasız</strong> çıktıları temsil ediyor gibi düşünebilirsiniz. Denemek için <code class="language-plaintext highlighter-rouge">./test.sh &amp;&gt; sonuc</code> şeklinde komutumuzu girelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>./test.sh &amp;&gt; sonuc

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="err">$</span>
</code></pre></div></div>

<p>Bakın konsolumuza herhangi bir çıktı bastırılmadı çünkü tüm çıktılar bu dosyaya yönlendirildi. Görmek için <code class="language-plaintext highlighter-rouge">cat</code> komutu ile okuyalım.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat </span>sonuc                                        
Bu hatasız bir çıktı
./test.sh: line 2: asdf: <span class="nb">command </span>not found

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="err">$</span>
</code></pre></div></div>

<p>Bakın tüm çıktılar bu “<strong><em>sonuc</em></strong>” dosyasına eklenmiş. Yani <strong>hatalı ve hatasız</strong> çıktıların <code class="language-plaintext highlighter-rouge">&amp;&gt;</code> operatörü sayesinde tek bir adrese yönlendirilebildiğini bizzat teyit etmiş olduk.</p>

<p>Şema üzerinden bakacak olursak, girdiğimiz komuttaki yönlendirme aşağıdaki gibi temsil edebilir.</p>

<p><img src="https://superua1.github.io//egitim/metin/5.png" alt="5.png" class="responsive img-zoomable" /></p>

<p>Esasen söz konusu yönlendirmeler olduğunda çok daha fazla detay ve alternatif yaklaşım söz konusu. Örneğin yukarıdaki şemaya bakacak olursanız aslında bu yönlendirmede, hatalı çıktıları hatasız olanlara yönlendirip, hatasız olanlara birlikte bunları ilgili dosyaya yönlendirmeyi sağlamış oluyoruz. Fakat temel düzey için hatalı ve hatasız çıktıları yönlendirmek için <code class="language-plaintext highlighter-rouge">&amp;&gt;</code> operatörünü kullanabileceğinizi bilmeniz yeterli. Zira bu eğitimde bu konunun detaylarına girmemiz kafa karıştırıcı olabilir. Ben yalnızca basit düzeyde temel yaklaşımları ele aldım. Daha fazlası için kısa bir araştırma yapmanız yeterli.</p>

<p>En nihayetinde hem ayrı ayrı hem de birleşik şekilde hatalı ve hatasız çıktıları nasıl yönlendirebileceğimizi örnekler üzerinden ele aldık. Anlatımın devamında girdileri nasıl yönlendirebileceğimizden de kısaca bahsedeceğim ama öncelikle çıktıların yönlendirilmesiyle ilgili konuşmak istediğim birkaç detay daha var.</p>

<h2 id="üzerine-yazma--tek-büyüktür-operatörü-">Üzerine Yazma | Tek Büyüktür Operatörü <code class="language-plaintext highlighter-rouge">&gt;</code></h2>

<p>Biz örneklerimiz sırasında hep tek büyüktür “<code class="language-plaintext highlighter-rouge">&gt;</code>” karakterini kullanarak yeni bir dosya oluşturulmasını ve içerisine ilgili verinin yönlendirilmesini sağladık. Yönlendirme yapmak için tek büyüktür işareti kullandığımızda aslında kabuğumuza, “<em>eğer bu yönlendirme işaretinden sonra gelen bu dosya ile aynı isimde bir dosya yoksa yeni dosya oluştur, eğer bu isimde bir dosya varsa da yönlendirilen verileri bu dosyanın üzerine yaz</em>” demiş oluyoruz. Yani biz tek büyüktür operatörünü kullandığımızda aynı isimli bir dosya varsa o dosyanın içeriği silinip en son yönlendirilen veriler kaydediliyor. Dolayısıyla eski dosyanın tüm içeriği yok edilmiş oluyor.</p>

<p>Denemek için içerisinde hatalı ve hatasız çıktılar olan sonuc isimli dosyamıza tekrar yalnızca hatasız çıktımızı yönlendirmek üzere <code class="language-plaintext highlighter-rouge">./test.sh &gt; sonuc</code> şeklinde komutumuzu girebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>./test.sh <span class="o">&gt;</span> sonuc                               
./test.sh: line 2: asdf: <span class="nb">command </span>not found

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat </span>sonuc                                        
Bu hatasız bir çıktı
</code></pre></div></div>

<p>Bakın önceki hatalı ve hatasız çıktılar silinmiş, bunlar yerine en son yönlendirmiş olduğum hatasız çıktılar eklenmiş. İşte tıpkı bu örnekte olduğu gibi biz tek büyüktür işaretini kullandığımızda hedefte aynı isimli bir dosya varsa bu dosya içeriğinin üzerine yönlendirilmiş olan veriler yazılıyor. Eğer amacınız tam olarak bu değilse, tek büyüktür yönlendirme operatörünü kullanarak önemli dosyaların içeriklerinin yok olmasına sebep olabilirsiniz.</p>

<h2 id="ekleme--çift-büyüktür-operatörü-">Ekleme | Çift Büyüktür Operatörü <code class="language-plaintext highlighter-rouge">&gt;&gt;</code></h2>

<p>Yönlendirilecek olan verileri, mevcut verilerin sonuna eklemek istediğimizi belirtmek için de çift büyüktür <code class="language-plaintext highlighter-rouge">&gt;&gt;</code> işaretini kullanabiliyoruz. Ben bir önceki komutumu çağırıp, bu kez çift büyüktür ile yine hatasız çıktıların bu dosyanın sonuna eklenmesini istiyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>./test.sh <span class="o">&gt;&gt;</span> sonuc                               
./test.sh: line 2: asdf: <span class="nb">command </span>not found

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat </span>sonuc                                        
Bu hatasız bir çıktı
Bu hatasız bir çıktı
</code></pre></div></div>

<p>Bakın dosyanın sonuna yani aynı hatasız çıktıların eklendiğini görebiliyoruz çünkü çift büyüktür işareti sayesinde ekleme yapılması gerektiğini belirtmiş olduk. Testi devam ettirmek içinin ben <code class="language-plaintext highlighter-rouge">./test.sh 2&gt;&gt; sonuc</code> komutu ile <strong>yalnızca hatalı</strong> olan çıktıların da dosyanın sonuna eklenmesini istiyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>./test.sh 2&gt;&gt; sonuc                              
Bu hatasız bir çıktı

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat </span>sonuc                               
Bu hatasız bir çıktı
Bu hatasız bir çıktı
./test.sh: line 2: asdf: <span class="nb">command </span>not found
┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="err">$</span>
</code></pre></div></div>

<p>Bakın hatalı çıktılar da dosyanın sonuna eklendi. Son olarak tek seferde hem hatalı hem de hatasız çıktıları dosyanın sonuna eklemek istersek <code class="language-plaintext highlighter-rouge">./test.sh &amp;&gt;&gt; sonuc</code> şeklinde komut girmeyi deneyebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>./test.sh &amp;&gt;&gt; sonuc                              

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat </span>sonuc                               
Bu hatasız bir çıktı
Bu hatasız bir çıktı
./test.sh: line 2: asdf: <span class="nb">command </span>not found
Bu hatasız bir çıktı
./test.sh: line 2: asdf: <span class="nb">command </span>not found

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="err">$</span>
</code></pre></div></div>

<p>Bakın bu çıktılar da dosyanın sonuna eklenmiş durumda.</p>

<p>Yani örneklerimizle birlikte <strong>tek büyüktür işaretinin verilerin üzerine yazdığını</strong> ve <strong>çift büyüktür işaretinin de var olanlara ekleme yaptığını</strong> bizzat teyit etmiş olduk.</p>

<p>Özelikle belirtmedim ancak istersek daha önce var olmayan bir dosyayı oluşturmak için de çift büyüktür işaretini kullanabiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>./test.sh &amp;&gt;&gt; yepyenidosya

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat </span>yepyenidosya                                 
Bu hatasız bir çıktı
./test.sh: line 2: asdf: <span class="nb">command </span>not found
┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="err">$</span>
</code></pre></div></div>

<p>Bakın çift büyüktür işareti sayesinde belirttiğimiz isimde dosya oluşturuldu ve bu çıktılar da bu dosyaya yönlendirildi. Tamamdır bence çıktıları yönlendirmeyle ilgili temelde bilmemiz gerekenlerden bahsettik.</p>

<p>Şimdi bir de girdileri yönlendirmek için kısaca standart girdiden bahsedelim.</p>

<h2 id="veri-girişi--standart-input">Veri Girişi | Standart Input</h2>

<p>Standart girdiden veri kabul eden tüm araçlara “küçüktür” <code class="language-plaintext highlighter-rouge">&lt;</code> yönlendirme operatörü ile doğrudan veri girişinde bulunabiliyoruz.  Örneğin ben “<strong><em>sonuc</em></strong>” isimli dosyayı okumak için <code class="language-plaintext highlighter-rouge">cat &lt; sonuc</code> şeklinde komutumu girebilirim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat</span> &lt; sonuc 
Bu hatasız bir çıktı
Bu hatasız bir çıktı
./test.sh: line 2: asdf: <span class="nb">command </span>not found
Bu hatasız bir çıktı
./test.sh: line 2: asdf: <span class="nb">command </span>not found
</code></pre></div></div>

<p>Buradaki “küçüktür” <code class="language-plaintext highlighter-rouge">&lt;</code> yönlendirme operatörü <code class="language-plaintext highlighter-rouge">cat</code> aracına bu dosyanın içeriğini yönlendirip bunun konsola bastırılmasını sağlıyor. İşleyişe şema üzerinden bakacak olursak aşağıdaki gibi temsil edebilir.</p>

<p class="mavi"><strong>Not:</strong> <code class="language-plaintext highlighter-rouge">cat</code> aracı sistem üzerinde <strong><em>/usr/bin/cat</em></strong> konumunda bulunduğu için temsil edilirken bu dosya ismini kullandım.</p>

<p><img src="https://superua1.github.io//egitim/metin/6.png" alt="6.png" class="responsive img-zoomable" /></p>

<p>Normalde doğrudan <code class="language-plaintext highlighter-rouge">cat sonuc</code> komutu ile de okuyabileceğimiz için belki bu örneğimiz size çok mantıklı gelmemiş olabilir ancak merak etmeyin ileride farklı araçlar üzerinde kullanırken daha anlamlı hale gelecek. Fakat biraz önce de belirttiğim gibi bir araca bu şekilde yönlendirme operatörü ile veri iletmek için <strong>o aracın standart girdiden veri kabul ediyor olması gerekiyor</strong>. Eğer o araç standart girdiye bakmıyorsa yani buradan veri kabul etmiyorsa yönlendirmiş olduğunuz hiç bir veri bu araç tarafından işlenmez.</p>

<p>Bu duruma örnek olarak <code class="language-plaintext highlighter-rouge">echo</code> aracını ele alabiliriz mesela. <code class="language-plaintext highlighter-rouge">echo</code> aracının tek görevi kendisinde sonra yazılmış olan argümanları bastırmaktır. Yani <code class="language-plaintext highlighter-rouge">echo</code> aracı standart girdiden veri kabul etmiyor, yalnızca kendisinden sonra yazılmış olan argümanları alıp konsola bastırıyor. Dolayısıyla eğer biz <code class="language-plaintext highlighter-rouge">echo</code> aracının standart girdisine veri gönderirsek <code class="language-plaintext highlighter-rouge">echo</code> aracı hiç bir tepki vermeyecek. Bizzat denemek için “<strong><em>sonuc</em></strong>” isimli dosyanın içeriğini <code class="language-plaintext highlighter-rouge">echo</code> aracına yönlendirmek üzere komutumuzu <code class="language-plaintext highlighter-rouge">echo &lt; sonuc</code> şeklinde girebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo</span> &lt; sonuc                                     

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="err">$</span>
</code></pre></div></div>

<p>Bakın herhangi bir çıktı almadık çünkü <code class="language-plaintext highlighter-rouge">echo</code> aracı standart girdiden veri okumuyor. Dolayısıyla bizim veri yönlendirmiş olmamız <code class="language-plaintext highlighter-rouge">echo</code> için hiç bir anlam ifade etmiyor. Yani aşağıdakine benzer bir işleyiş söz konusu.</p>

<p><img src="https://superua1.github.io//egitim/metin/7.png" alt="7.png" class="responsive img-zoomable" /></p>

<p>Ek bir örnek daha vermemiz gerekirse örneğin tıpkı <code class="language-plaintext highlighter-rouge">echo</code> aracı gibi, klasör oluşturmamızı sağlayan <code class="language-plaintext highlighter-rouge">mkdir</code> aracı da standart girdiden veri okuması yapmıyor. Bu sebeple eğer biz klasör oluşturmak istiyorsak, klasör ismini <code class="language-plaintext highlighter-rouge">mkdir</code> aracına argüman olarak vermemiz gerekiyor. Ben denemek için <code class="language-plaintext highlighter-rouge">mkdir</code> aracına <code class="language-plaintext highlighter-rouge">mkdir &lt; sonuc</code> komutu ile yine “<strong><em>sonuc</em></strong>” dosyasının içeriğini girdi olarak yönlendirmeyi deniyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">mkdir</span> &lt; sonuc                                    
<span class="nb">mkdir</span>: missing operand
Try <span class="s1">'mkdir --help'</span> <span class="k">for </span>more information.

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="err">$</span>
</code></pre></div></div>

<p>Bakın komutumuz hata verdi çünkü <code class="language-plaintext highlighter-rouge">mkdir</code> aracı standart girdiye bakmıyor. Yani ben <code class="language-plaintext highlighter-rouge">mkdir &lt; sonuc</code> şeklinde yazdım ama <code class="language-plaintext highlighter-rouge">mkdir</code> aracına oluşturması gereken klasör için hiç bir argüman iletilmedi.</p>

<p>İşte bizzat örnekler üzerinden de teyit ettiğimiz gibi standart girdiden veri okumayan araçların standart girdilerine veri yönlendirmesi yapmamız anlamsız çünkü standart girdilerini okumuyorlar. Örnekler sırasında ele aldığımız araçlar gibi yalnızca argümanlarla çalışabilen araçlara dosyalardan veri yönlendirmesi yapmak için alternatif çözüm var fakat bu çözümden daha sonra ayrıca bahsediyor olacağız.</p>

<p>Şimdi burada odaklanmanız gereken tek detay standart girdi yönlendirmesinin yalnızca standart girdiden veri kabul eden araçlar üzerinde etkili olduğu. Peki hangi aracın standart girdiden veri alıp hangisinin argümanlar üzerinden çalıştığını nerden bileceğiz diye soracak olursanız.</p>

<p>Hangi araçların standart girdiden veri kabul ettiğini manual sayfalarındaki açıklamalara göz atarak öğrenebileceğiniz gibi zaten zaman içinde hangi aracın ne şekilde çalıştığını da anımsıyor olacaksınız. Örneğin kullandığınız aracın yardım sayfasında bu duruma dair bir açıklama yoksa standart girdiden veri yönlendirmeyi deneyip bizzat kendiniz de test edebilirsiniz.</p>

<p>Benim yönlendirmelerle ilgili bahsetmek istediklerim şimdilik bu kadar. Bence temel eğitim için bu kadarlık detay seviyesi yeterli. Tabii ki eğer isterseniz daha fazlasını öğrenmek için araştırma yapmakta özgürsünüz.</p>

<p>Biz şimdi metinsel veriler üzerinde çalışmamıza yardımcı olan temel araçlardan bahsederek devam edelim.</p>

<h1 id="cat-komutu">cat Komutu</h1>

<p><code class="language-plaintext highlighter-rouge">cat</code> aracının ismi “bağlamak, birleştirmek veya sıralamak” anlamlarında olan İngilizce “concatenate” kelimesinden geliyor ve aracın görevini net biçimde ifade ediyor aslında.</p>

<p><code class="language-plaintext highlighter-rouge">cat</code> komutunun en temel işlevi, kendisine argüman olarak verilen dosyaların içeriklerini konsola yönlendirerek bastırmaktır. Yani aslında temelde <code class="language-plaintext highlighter-rouge">cat</code> aracı dosyaların içeriklerini konsol üzerinden okuyabilmemize olanak tanıyan basit bir araçtır. Var olan bir dosyayı okumak için tek yapmamız gereken, <code class="language-plaintext highlighter-rouge">cat</code> komutunun ardından dosyanın ismini girmek. Ben örnekler sırasında kullanmak için mevcut bulunduğum dizindeki dosya ve klasör isimlerini bir dosyaya kaydetmek istiyorum. Bunun için <code class="language-plaintext highlighter-rouge">ls &gt; liste</code> komutunu girebilirim. Buradaki büyüktür <code class="language-plaintext highlighter-rouge">&gt;</code> yönlendirme operatörü sayesinde <code class="language-plaintext highlighter-rouge">ls</code> komutunun çıktıları “<strong><em>liste</em></strong>” dosyasına yönlendirilmiş olacak. Bir de <code class="language-plaintext highlighter-rouge">ls /usr &gt; liste2</code> komutu ile “<strong><em>usr</em></strong>” dizini altındakileri de “<strong><em>liste2</em></strong>” dosyasına kaydedelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">ls</span> <span class="o">&gt;</span> liste                           

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">ls</span> /usr <span class="o">&gt;</span> liste2
</code></pre></div></div>

<p>Örneğin oluşturduğumuz ikinci dosyanın içeriğini konsola bastırmak istersek <code class="language-plaintext highlighter-rouge">cat liste2</code> şeklinde komutumuzu girebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat </span>liste2                           
bin
games
include
lib
lib32
lib64
libexec
libx32
<span class="nb">local
</span>sbin
share
src
</code></pre></div></div>

<p>Bakın dosyanın içeriği konsola bastırıldı.  Dilersek, aynı anda birden fazla dosyayı da okuyabiliriz. Denemek için diğer dosyanın ismini de girelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat </span>liste2 liste
bin
games
include
lib
lib32
lib64
libexec
libx32
<span class="nb">local
</span>sbin
share
src
ada
calısma
Desktop
Documents
dosya.txt
Downloads
hatalı.txt
hatasız2.txt
hatasız.txt
klasor
liste
metin1.txt
metin2.txt
Music
Pictures
Public
sonuc
Templates
test.sh
Videos
yeni
yeni klasor
yepyenidosya
</code></pre></div></div>

<p>Bakın komutta soldan sağa doğru verdiğim tüm dosyaların içerikleri, sırasıyla yukarıdan aşağıya doğru konsola bastırılmış oldu. Yani aslında isminde olduğu şekilde <code class="language-plaintext highlighter-rouge">cat</code> aracı birden fazla dosyanın içeriğini sırasıyla birleşik şekilde konsolumuza bastırmış oldu. Bu şekilde istediğimiz kadar dosyanın birleştirilmesini sağlayabiliyoruz.</p>

<p>Birden fazla dosya içeriğinin <code class="language-plaintext highlighter-rouge">cat</code> aracı sayesinde sıralı şekilde birleştirilebiliyor olması size bir fikir verdi mi ?</p>

<p>Eğer istersek birden fazla dosyanın içeriğini tek bir dosyaya yönlendirebiliriz. Yani birden fazla dosyayı tek bir dosyada birleştirebiliriz. Denemek için “<strong><em>liste</em></strong>” ve “<strong><em>liste2</em></strong>” dosyasını birleştirip “<strong><em>nihai-liste</em></strong>” isimli bir dosya oluşturmak üzere <code class="language-plaintext highlighter-rouge">cat liste liste2 &gt; nihai-liste</code> şeklinde komutumuzu girelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat </span>liste liste2 <span class="o">&gt;</span> nihai-liste

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat </span>nihai-liste                      
ada
calısma
Desktop
Documents
dosya.txt
Downloads
hatalı.txt
hatasız2.txt
hatasız.txt
klasor
liste
metin1.txt
metin2.txt
Music
Pictures
Public
sonuc
Templates
test.sh
Videos
yeni
yeni klasor
yepyenidosya
bin
games
include
lib
lib32
lib64
libexec
libx32
<span class="nb">local
</span>sbin
share
src
</code></pre></div></div>

<p>Bakın iki dosyanın içeriği, tam olarak komutta belirttiğim sıralama ile yani ilk olarak “<strong><em>liste</em></strong>” dosyası daha sonra “<strong><em>liste2</em></strong>” dosyası olacak şekilde birleştirilip tek bir dosya haline gelmiş oldu.</p>

<p>İşte <code class="language-plaintext highlighter-rouge">cat</code> komutunun en temel ve sık kullanılan özellikleri bunlar. Zaten daha önce yönlendirmeleri kullanarak yeni dosyalar oluşturup içerisine nasıl veri ekleyebileceğimizden defaatle uygulamalı olarak söz ettiğimiz için <code class="language-plaintext highlighter-rouge">cat</code> komutu ile söyleyeceğim ek bir detay bulunmuyor.</p>

<p>Bu bölüme gelene kadar gerçekleştirdiğimiz anlatımlar sırasında kullanma sıklığımızdan da tahmin edebileceğiniz gibi <code class="language-plaintext highlighter-rouge">cat</code> komutu en sık kullanacağımız komutların başında geliyor. <code class="language-plaintext highlighter-rouge">cat</code> aracı hatırlanması ve kullanımı basit ancak metinsel verileri okuma birleştirme ve yenilerini oluşturma gibi en temel konularda etkili bir araç. <code class="language-plaintext highlighter-rouge">cat</code> komutunu kullanarak ihtiyaçlarınıza uygun çözümler üretmek tamamen sizin yönlendirmeleri ve <code class="language-plaintext highlighter-rouge">cat</code> komutunun çalışma yapısını ne kadar iyi anladığınıza bağlı. Daha iyi anlamak adına birkaç örnek yapabiliriz.</p>

<p>Örneğin <code class="language-plaintext highlighter-rouge">cat</code> aracını bir dosyanın içeriğini kopyalamak için kullanabiliriz mesela. Bunun için <code class="language-plaintext highlighter-rouge">cat kopyalanacak_dosya &gt; dosyanın_kopyası</code> şeklinde komut girmemiz yeterli oluyor. Mesela ben “<strong><em>liste</em></strong>” dosyasını kopyalamak istersem <code class="language-plaintext highlighter-rouge">cat liste &gt; liste3</code> komutuyla bu dosya içeriğinin “<strong><em>liste3</em></strong>” isimli dosyaya kopyalanmasını sağlayabiliyoruz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat </span>liste <span class="o">&gt;</span> liste3

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat </span>liste3                           
ada
calısma
Desktop
Documents
dosya.txt
Downloads
hatalı.txt
hatasız2.txt
hatasız.txt
klasor
liste
metin1.txt
metin2.txt
Music
Pictures
Public
sonuc
Templates
test.sh
Videos
yeni
yeni klasor
yepyenidosya
</code></pre></div></div>

<p>Bakın “<strong><em>liste</em></strong>” dosyasının içeriği kopyalanarak “<strong><em>liste3</em></strong>” isimli dosya oluşturup bu dosyaya aktarılmış.</p>

<p>Burada gerçekleşen işlemi temel olarak açıklamamız gerekirse; Girmiş olduğumuz komut sayesinde <code class="language-plaintext highlighter-rouge">cat</code> aracı kopyalanacak dosyanın içeriğini okuyor ve buradaki büyüktür <code class="language-plaintext highlighter-rouge">&gt;</code> işareti sayesinde bu içeriği standart çıktıya yönlendiriyor. Normalde biz özellikle belirtmediğimiz sürece standart çıktı bizim konsolumuza bağlı olduğu için biz <code class="language-plaintext highlighter-rouge">cat</code> aracının çıktılarını konsolda görüyoruz. Ama ben burada standart çıktıyı büyüktür operatörü ile “<strong><em>liste3</em></strong>” isimli dosyaya yönlendirdiğim için çıktılar bu dosyaya aktarılıyor. Bu sayede “<strong><em>liste</em></strong>” dosyasının içeriğiyle aynı içeriğe sahip “<strong><em>liste3</em></strong>” isimli dosya oluşturuluyor. Yani bir nevi “<strong><em>liste</em></strong>” dosyasını kopyalamış oluyoruz.</p>

<p>Elbette benim ele aldığım temel kullanımı dışında <code class="language-plaintext highlighter-rouge">cat</code> komutunun daha birçok seçeneği mevcut. Bu seçeneklere göz atmak için <code class="language-plaintext highlighter-rouge">cat —help</code> komutunu kullanabilirsiniz. Buradaki <code class="language-plaintext highlighter-rouge">help</code> çıktısındaki açıklamalar yeterince açık gelmezse, internet üzerindeki rehber anlatımlara da kolaylıkla ulaşabilirsiniz. Zaten tüm eğitim boyunca tekrar ettiğim ve edeceğim gibi, bu eğitimdeki amacım temel kavramlardan bahsedip daha fazlasını nasıl öğrenebileceğimiz üzerinde durmak. Dolayısıyla tüm konulardan, tüm araçlardan veya araçların tüm seçeneklerinden bahsetmemi bekliyorsanız, üzgünüm bu gerçekleşmeyecek. Nitekim anlatıcı tarafında olmama karşın benim de henüz bilmediğim, hiç kullanmadığım için unuttuğum veya hiç karşılaşmadığım pek çok konu, kavram, araç ve seçenek bulunuyor. Ancak temel kavramların farkında olduğumuzda ve yeni bilgileri nasıl araştırıp bulabileceğimizi bildikten sonra zaten zaman içinde bilmemiz gereken tüm bilgi birikimini adım adım inşa edebiliyoruz. Yani özetle önemli olan iyi bir temel ve bu temele dayandırılan araştırma yetkinliği kazanabilmek. Anlatımlarımıza gelin <code class="language-plaintext highlighter-rouge">cat</code> komutunu tersi şekilde çıktılar sunabilen <code class="language-plaintext highlighter-rouge">tac</code> aracından bahsederek devam edelim.</p>

<h1 id="tac-komutu">tac Komutu</h1>

<p>Hatırlıyorsanız, <code class="language-plaintext highlighter-rouge">ls</code> komutunu ele alırken tüm çıktıları tersine çevirebilen “<strong>r</strong>everse” yani “<code class="language-plaintext highlighter-rouge">r</code>” seçeneğinden bahsetmiştik. <code class="language-plaintext highlighter-rouge">cat</code> komutu ile okuduğumuz dosya içerikleri için de benzer bir ihtiyacımız olabilir. Örneğin <code class="language-plaintext highlighter-rouge">cat</code> komutu ile okuduğumuz bir dosya içindeki alfabetik olarak sıralanmış satırlara, ters alfabetik olarak ihtiyaç duyabiliriz. Bu durumda, <code class="language-plaintext highlighter-rouge">cat</code> aracının ismen de tersi olan <code class="language-plaintext highlighter-rouge">tac</code> aracını kullanabiliyoruz.</p>

<p><code class="language-plaintext highlighter-rouge">tac</code> komutunu test edebilmek için öncelikle yeni bir dosya oluşturalım. Ben bulunduğum dizindeki tüm içerikleri ayrıntılarıyla birlikte büyükten küçüğe doğru okunaklı şekilde sıralayıp, çıktıları “<em><strong>liste.txt</strong>”</em> isimli bir dosyaya aktarmak istiyorum. Bunun için <code class="language-plaintext highlighter-rouge">ls -lhS &gt; liste.txt</code> şeklinde komutumu giriyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-lhS</span> <span class="o">&gt;</span> liste.txt                  

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat </span>liste.txt                        
total 104K
drwxr-xr-x 2 taylan taylan 4.0K Jun  7 07:41 ada
drwxr-xr-x 2 taylan taylan 4.0K Jun  7 08:45 calısma
drwxr-xr-x 4 taylan taylan 4.0K Jun  5 13:33 Desktop
drwxr-xr-x 5 taylan taylan 4.0K Jun  4 07:06 Documents
drwxr-xr-x 3 taylan taylan 4.0K May 26 05:36 Downloads
drwxr-xr-x 2 taylan taylan 4.0K Jun  7 06:22 klasor
drwxr-xr-x 2 taylan taylan 4.0K Feb 11  2022 Music
drwxr-xr-x 4 taylan taylan 4.0K May 30 13:21 Pictures
drwxr-xr-x 3 taylan taylan 4.0K Jun 25  2022 Public
drwxr-xr-x 2 taylan taylan 4.0K Feb 11  2022 Templates
drwxr-xr-x 2 taylan taylan 4.0K Feb 11  2022 Videos
drwxr-xr-x 2 taylan taylan 4.0K Jun  7 06:22 yeni
drwxr-xr-x 2 taylan taylan 4.0K Jun  7 06:23 yeni klasor
<span class="nt">-rw-r--r--</span> 1 taylan taylan  278 Jun 11 05:26 nihai-liste
<span class="nt">-rw-r--r--</span> 1 taylan taylan  208 Jun 11 05:22 liste
<span class="nt">-rw-r--r--</span> 1 taylan taylan  208 Jun 11 05:32 liste3
<span class="nt">-rw-r--r--</span> 1 taylan taylan  161 Jun 10 11:57 sonuc
<span class="nt">-rw-r--r--</span> 1 taylan taylan   70 Jun 11 05:23 liste2
<span class="nt">-rw-r--r--</span> 1 taylan taylan   68 Jun 10 11:59 yepyenidosya
<span class="nt">-rw-r--r--</span> 1 taylan taylan   43 Jun 10 11:37 hatalı.txt
<span class="nt">-rwxr-xr-x</span> 1 taylan taylan   37 Jun 10 11:23 test.sh
<span class="nt">-rw-r--r--</span> 1 taylan taylan   25 Jun 10 11:34 hatasız2.txt
<span class="nt">-rw-r--r--</span> 1 taylan taylan   25 Jun 10 11:31 hatasız.txt
<span class="nt">-rw-r--r--</span> 1 taylan taylan   24 Jun  7 07:45 metin2.txt
<span class="nt">-rw-r--r--</span> 1 taylan taylan   22 Jun  7 08:01 dosya.txt
<span class="nt">-rw-r--r--</span> 1 taylan taylan   16 Jun  7 07:42 metin1.txt
<span class="nt">-rw-r--r--</span> 1 taylan taylan    0 Jun 11 06:46 liste.txt

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="err">$</span>
</code></pre></div></div>

<p>Bakın dosya ve dizinlerin büyükten küçüğe doğru sıralanmış listesini görebiliyoruz. Eğer aynı dosyayı <code class="language-plaintext highlighter-rouge">tac</code> komutu ile okursak listenin tam tersi şekilde olması gerekiyor.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">tac </span>liste.txt                        
<span class="nt">-rw-r--r--</span> 1 taylan taylan    0 Jun 11 06:46 liste.txt
<span class="nt">-rw-r--r--</span> 1 taylan taylan   16 Jun  7 07:42 metin1.txt
<span class="nt">-rw-r--r--</span> 1 taylan taylan   22 Jun  7 08:01 dosya.txt
<span class="nt">-rw-r--r--</span> 1 taylan taylan   24 Jun  7 07:45 metin2.txt
<span class="nt">-rw-r--r--</span> 1 taylan taylan   25 Jun 10 11:31 hatasız.txt
<span class="nt">-rw-r--r--</span> 1 taylan taylan   25 Jun 10 11:34 hatasız2.txt
<span class="nt">-rwxr-xr-x</span> 1 taylan taylan   37 Jun 10 11:23 test.sh
<span class="nt">-rw-r--r--</span> 1 taylan taylan   43 Jun 10 11:37 hatalı.txt
<span class="nt">-rw-r--r--</span> 1 taylan taylan   68 Jun 10 11:59 yepyenidosya
<span class="nt">-rw-r--r--</span> 1 taylan taylan   70 Jun 11 05:23 liste2
<span class="nt">-rw-r--r--</span> 1 taylan taylan  161 Jun 10 11:57 sonuc
<span class="nt">-rw-r--r--</span> 1 taylan taylan  208 Jun 11 05:32 liste3
<span class="nt">-rw-r--r--</span> 1 taylan taylan  208 Jun 11 05:22 liste
<span class="nt">-rw-r--r--</span> 1 taylan taylan  278 Jun 11 05:26 nihai-liste
drwxr-xr-x 2 taylan taylan 4.0K Jun  7 06:23 yeni klasor
drwxr-xr-x 2 taylan taylan 4.0K Jun  7 06:22 yeni
drwxr-xr-x 2 taylan taylan 4.0K Feb 11  2022 Videos
drwxr-xr-x 2 taylan taylan 4.0K Feb 11  2022 Templates
drwxr-xr-x 3 taylan taylan 4.0K Jun 25  2022 Public
drwxr-xr-x 4 taylan taylan 4.0K May 30 13:21 Pictures
drwxr-xr-x 2 taylan taylan 4.0K Feb 11  2022 Music
drwxr-xr-x 2 taylan taylan 4.0K Jun  7 06:22 klasor
drwxr-xr-x 3 taylan taylan 4.0K May 26 05:36 Downloads
drwxr-xr-x 5 taylan taylan 4.0K Jun  4 07:06 Documents
drwxr-xr-x 4 taylan taylan 4.0K Jun  5 13:33 Desktop
drwxr-xr-x 2 taylan taylan 4.0K Jun  7 08:45 calısma
drwxr-xr-x 2 taylan taylan 4.0K Jun  7 07:41 ada
total 104K

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="err">$</span>
</code></pre></div></div>

<p>Bakın tam olarak beklediğimiz gibi tüm çıktılar tam tersi şekilde oldu. Yani tüm satırları ters sıralama ile küçükten büyüye olacak şekilde görüntüleyebildik. İşte <code class="language-plaintext highlighter-rouge">tac</code> komutu tam olarak bu amaçla kullanılıyor. Satırları sondan başa doğru bastırmak istediğimizde <code class="language-plaintext highlighter-rouge">tac</code> aracını kullanabiliyoruz.</p>

<p>Belki bu örnekte kullandığımız <code class="language-plaintext highlighter-rouge">ls</code> komutunun zaten kendine ait terse çevirme işlevi yani <code class="language-plaintext highlighter-rouge">-r</code> seçeneği olduğu için, <code class="language-plaintext highlighter-rouge">tac</code> komutunun kullanımı size çok gerekli gibi gelmemiş olabilir ancak lütfen buradaki <code class="language-plaintext highlighter-rouge">ls</code> komutuna takılmayın. <code class="language-plaintext highlighter-rouge">ls</code> sadece kolay gözlemlenebilir dosya içeriği oluşturmak için kullandığımız basit bir örnek. Komut satırını kullanırken, sürekli metinsel veriler üzerinde çalıştığımız için, herhangi bir dosyadaki verilerin tersten sıralamasına ihtiyaç duyacağımız durumlar ile karşılaşmamız kaçınılmaz. Komut satırında çalışırken temelde her şeyi bayt akışından ibaret olduğunu unutmayın lütfen. Dosya içeriklerinden veya çeşitli araçlardan gelen verileri yani üzerinde çalıştığımız baytları istediğimiz doğrultuda manipüle edebildiğimiz sürece komut satırının gücünden faydalanabiliriz. Verileri manipüle etmenin önemini ileride daha iyi anlayacaksınız. Çünkü eğitimin devamında, <strong>pipe</strong> mekanizmasını kullanarak bir aracın ürettiği çıktıları başka bir araca yönlendirerek kompleks sorunlara basit çözümler sağlamış olacağız. Araçların bir arada çalışabilmesi için de gerektiğine akış halindeki verilerin bir sonraki araca uygun şekilde değiştirilerek aktarılması gerekecek. Özetle, verileri istediğimiz şekilde değiştirebiliyor olmanın önemini ileride daha net anlayacaksınız.</p>

<p>Ayrıca ben tek bir dosya ile örnek yaptım ama <code class="language-plaintext highlighter-rouge">cat</code> komutunda olduğu gibi <code class="language-plaintext highlighter-rouge">tac</code> komutuyla da birden fazla dosyayı aynı anda ters sıralama ile okuyabiliriz. Ben örnek olarak sırala harfler ve sayılar içeren iki dosya oluşturmak istiyorum. Kolayca oluşturmak için daha önce öğrendiğimiz süslü parantez genişletmesini kullanabiliriz. a’dan z’ye kadar olan karakterleri <code class="language-plaintext highlighter-rouge">echo -e "\n"{a..z} &gt; harf.txt</code> komutu ile “<strong><em>harf.txt</em></strong>” dosyasına kaydedebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="o">{</span>a..z<span class="o">}</span> <span class="o">&gt;</span> harf.txt
</code></pre></div></div>

<p>Buradaki <code class="language-plaintext highlighter-rouge">echo</code> komutu ile kullandığımız <code class="language-plaintext highlighter-rouge">-e</code> seçeneği tırnak içinde yazdığımız “yeni satıra geçme” yani “<code class="language-plaintext highlighter-rouge">\n</code>” ifadesinin çalışmasını sağlıyor. Bu sayede a’dan z’ye kadar her satıra bir karakter basılıyor. Merak etmeyin <code class="language-plaintext highlighter-rouge">echo</code> komutunu kullanırken bu konudan tekrar bahsedeceğiz. Şimdilik ihtiyacımız olan dosyayı oluşturmak için kullanabiliriz. Benzer şekilde 1’den 30’a kadar olan sayıları satır satır sıralamak için de komutumuzu <code class="language-plaintext highlighter-rouge">echo -e "\n"{1..30} &gt; sayi.txt</code> şeklinde düzenleyip girebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="o">{</span>1..30<span class="o">}</span> <span class="o">&gt;</span> sayi.txt
</code></pre></div></div>

<p>Evet neticede içinde istediğimiz türde veriler bulunan iki dosyamızı kolayca oluşturabildik. İçeriklerini görüntülemek için aynı anda iki dosyayı da <code class="language-plaintext highlighter-rouge">cat</code> komutu ile açabiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="o">{</span>1..30<span class="o">}</span> <span class="o">&gt;</span> sayi.txt

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat </span>harf.txt sayi.txt 

a 
b 
c 
d 
e 
f 
g 
h 
i 
j 
k 
l 
m 
n 
o 
p 
q 
r 
s 
t 
u 
v 
w 
x 
y 
z

1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30
</code></pre></div></div>

<p>Bakın, verdiğim dosya sırlamasına uygun şekilde tek seferde dosya içerikleri sıralı şekilde bastırıldı. Aynı dosyaları <code class="language-plaintext highlighter-rouge">tac</code> komutu ile de bastırabiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">tac </span>harf.txt sayi.txt                
z
y 
x 
w 
v 
u 
t 
s 
r 
q 
p 
o 
n 
m 
l 
k 
j 
i 
h 
g 
f 
e 
d 
c 
b 
a 

30
29 
28 
27 
26 
25 
24 
23 
22 
21 
20 
19 
18 
17 
16 
15 
14 
13 
12 
11 
10 
9 
8 
7 
6 
5 
4 
3 
2 
1
</code></pre></div></div>

<p>Bakın yine verdiğim dosya sırlamasına uygun ancak bu kez dosya içerikleri tersten sıralanmış şekilde bastırıldı.</p>

<p><code class="language-plaintext highlighter-rouge">tac</code> komutu <code class="language-plaintext highlighter-rouge">cat</code> komutu kadar kolay hatırlanabilir basit bir komut. <code class="language-plaintext highlighter-rouge">cat</code> komutunun tersten yazılmış hali olması zaten işlevi hakkında unutulmaz bir hatırlatıcı.</p>

<h1 id="rev-komutu">rev Komutu</h1>

<p>Eğer mevcut satırların sırlanmasını değil de doğrudan satırdaki karakterleri tersine çevirmek istersek <code class="language-plaintext highlighter-rouge">rev</code> aracını kullanabiliyoruz. <code class="language-plaintext highlighter-rouge">rev</code> aracının ismi İngilizce “<strong>rev</strong>erse” yani “ters” ifadesinin kısaltmasından geliyor. Kullanımı son derece kolay, <code class="language-plaintext highlighter-rouge">rev</code> komutunun ardından satırlarındaki karakterlerini tersine çevirmek istediğiniz dosyayı yazmanız yeterli oluyor.</p>

<p>Nasıl bir etkisi olduğunu test etmek için hemen basit bir metin dosyası oluşturmayı deneyebiliriz. Ben bunun için <code class="language-plaintext highlighter-rouge">cat &gt; metin.txt</code> komutunu girip dosyamın içine birkaç satır veri ekliyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span> metin.txt 
bu basit

bir metin

dosyasıdır
</code></pre></div></div>

<p>Veri girişini sonlandırıp dosyaya kaydetmek için <kbd>Ctrl</kbd>+ <kbd>d&lt;/bkd&gt; tuşlamasını yapmamız yeterli.</kbd></p>

<p>Aradaki farkı net gözlemleyebilmek için oluşturduğumuz dosyayı hem <code class="language-plaintext highlighter-rouge">cat</code> hem de <code class="language-plaintext highlighter-rouge">rev</code> araçları ile okumayı deneyebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat </span>metin
bu basit

bir metin

dosyasıdır

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>rev metin                            
tisab ub

nitem rib

rıdısaysod
</code></pre></div></div>

<p>Görebildiğiniz gibi <code class="language-plaintext highlighter-rouge">rev</code> aracı tüm satırlardaki karakterler tersine çeviriyor. Yani tek tek tüm satırlarda yer alan sondaki karakter başa, baştaki de sona gidecek şekilde bir terslik elde edebildik.</p>

<h1 id="touch-komutu">touch Komutu</h1>

<p>Eğer hatırlıyorsanız, daha önce yeni boş dosyalar oluşturmak üzere <code class="language-plaintext highlighter-rouge">touch</code> aracını kullanmıştık. Bu işlevinin yanında aslında <code class="language-plaintext highlighter-rouge">touch</code> aracı var olan dosyaların tarih bilgilerini değiştirmek için kullanılan bir araç.</p>

<p>Daha önce <code class="language-plaintext highlighter-rouge">ls</code> komutunun ayrıntılı çıktılarında ve bu çıktıları tarihlere göre sıralarken zaten dosya ve klasörlerin tarih bilgisinin tutulduğunu söylemiştik.</p>

<p>Şimdi özellikle bu konu üstünde duracak olursak sistem üzerinde oluşturulan tüm dosyaların oluşturulma, değiştirilme ve güncellenme tarihleri olmak üzere temelde üç zaman etiketi bulunuyor. Biz istersek <code class="language-plaintext highlighter-rouge">touch</code> aracı sayesinde bu tarihleri değiştirebiliyoruz.</p>

<p>Fakat öncelikle bu bilgileri görmek için <code class="language-plaintext highlighter-rouge">stat</code> komutunu kullanalım. <code class="language-plaintext highlighter-rouge">stat</code> komutu sayesinde dosya ve dizinler hakkında çeşitli öznitelik bilgilerini görüntüleyebiliyoruz. Ben test edebilmek için daha önce oluşturduğum “<strong><em>liste</em></strong>” isimli dosyanın özelliklerine bakmak istiyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">stat </span>liste
  File: liste
  Size: 208             Blocks: 8          IO Block: 4096   regular file
Device: 801h/2049d      Inode: 2893400     Links: 1
Access: <span class="o">(</span>0644/-rw-r--r--<span class="o">)</span>  Uid: <span class="o">(</span> 1000/    taylan<span class="o">)</span>   Gid: <span class="o">(</span> 1000/    taylan<span class="o">)</span>
Access: 2023-06-11 05:24:30.303662486 <span class="nt">-0400</span>
Modify: 2023-06-11 05:22:23.199246609 <span class="nt">-0400</span>
Change: 2023-06-11 05:22:23.199246609 <span class="nt">-0400</span>
 Birth: 2023-06-11 05:22:23.195248608 <span class="nt">-0400</span>
</code></pre></div></div>

<p>Buradaki erişim(access) tarihi, bu dosyanın en son açıldığı, okunduğu yani erişildiği tarihi veriyor. Fakat bir dosya pek çok kullanıcı tarafından defaatle açılabileceği ve özellikle sunucularda dosya okunma sayısının yüksek olması dolayısıyla bu erişim tarihi her erişimde değişmiyor. Her erişimde değişecek şekilde konfigüre edebiliriz fakat disk üzerindeki okuma yazma yükünü yüksek oranda artıracağımız için pek de makul bir yaklaşım sayılmaz. Bu sebeple bir dosyayı açıp okuduğunuzda erişim tarihi muhtemelen hemen değişmeyecektir. Değişiyorsa, o sistem bunun için özellikle konfigüre edilmiştir.</p>

<p>Diğer tarih bilgisine bakacak olursak, düzenleme tarihi, dosya içeriğinin değiştirilmiş olduğu tarihi veriyor. Örneğin yeni bir veri eklediyseniz veya var olan verileri sildiyseniz dosyanızın düzenlenme tarihi değişiyor. Ben denemek için <code class="language-plaintext highlighter-rouge">echo “yeni veri” &gt;&gt; liste</code> komutu ile dosyama yeni bir veri ekleyip, <code class="language-plaintext highlighter-rouge">stat liste</code> komutu ile tarih bilgisine tekrar bakmak istiyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"yeni veri"</span> <span class="o">&gt;&gt;</span> liste

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">stat </span>liste                                                  
  File: liste
  Size: 218             Blocks: 8          IO Block: 4096   regular file
Device: 801h/2049d      Inode: 2893400     Links: 1
Access: <span class="o">(</span>0644/-rw-r--r--<span class="o">)</span>  Uid: <span class="o">(</span> 1000/    taylan<span class="o">)</span>   Gid: <span class="o">(</span> 1000/    taylan<span class="o">)</span>
Access: 2023-06-11 05:24:30.303662486 <span class="nt">-0400</span>
Modify: 2023-06-11 10:15:07.265088731 <span class="nt">-0400</span>
Change: 2023-06-11 10:15:07.265088731 <span class="nt">-0400</span>
 Birth: 2023-06-11 05:22:23.195248608 <span class="nt">-0400</span>
</code></pre></div></div>

<p>Bakın düzenleme(modify) tarihi düzenlemeyi yaptığımız tam tarih olarak değişmiş. Ayrıca bakın burada değişim(change) tarihinin de aynı şekilde değiştiğini görebiliyoruz.</p>

<p>Değişim tarihi de değişti çünkü buradaki değişim tarihi bilgisi, dosyanın ismi, yetkisi, boyutu gibi çeşitli öznitelikleri değiştiğinde güncelleniyor. Biz dosyanın içine yeni veri ekleyip dosyanın boyutunu değiştirdiğimiz için bu “değişim” tarihi de güncellenmiş oldu.</p>

<p>Dolayısıyla bir dosyanın içeriğini değiştirirseniz hem düzenleme hem de değişme tarihi değişiyor. Fakat yalnızca dosyanın ismi, konumu veya yetkileri gibi özniteliklerini değiştirdiğinizde sadece değişme tarihi güncelleniyor. Bu durumu teyit etmek için dosyamızı <code class="language-plaintext highlighter-rouge">mv</code> komutu ile aynı dizinde yeni bir isimle kaydedebiliriz. Yani dosyamızın ismini değiştirmeyi deneyebiliriz. Bunun için <code class="language-plaintext highlighter-rouge">mv liste yeni-liste</code> şeklinde komutumuzu girebiliriz. Burada <code class="language-plaintext highlighter-rouge">mv</code> komutundan sonra girdiğim ilk argüman taşınacak dosyayı ikincisi ise hangi dizine taşınacağını belirtiyor. Ben harici olarak ekstra bir dizin adresi belirtmediğim için göreli yol gereği mevcut dizinde burada belirttiğim isimde kaydedilecek.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">mv </span>liste yeni-liste

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">stat </span>yeni-liste 
  File: yeni-liste
  Size: 228             Blocks: 8          IO Block: 4096   regular file
Device: 801h/2049d      Inode: 2893400     Links: 1
Access: <span class="o">(</span>0644/-rw-r--r--<span class="o">)</span>  Uid: <span class="o">(</span> 1000/    taylan<span class="o">)</span>   Gid: <span class="o">(</span> 1000/    taylan<span class="o">)</span>
Access: 2023-06-11 05:24:30.303662486 <span class="nt">-0400</span>
Modify: 2023-06-11 10:29:21.455971533 <span class="nt">-0400</span>
Change: 2023-06-11 10:36:40.927598070 <span class="nt">-0400</span>
 Birth: 2023-06-11 05:22:23.195248608 <span class="nt">-0400</span>
</code></pre></div></div>

<p>Bakın dosyayı taşıyarak ismini değiştirdiğimiz için yalnızca değişme(change) tarihi güncellenmiş. Dosya içeriğinde düzenleme yapmadığımız için düzenleme tarihinde bir değişiklik yok.</p>

<p>Temel tarih bilgileri ve bunların değişme koşulları bizzat burada örnekler üzerinden teyit ettiğimiz şekilde çalışıyor. Ayrıca çıktılara dikkat edecek olursanız burada dosyanın oluşturulma tarihi de mevcut. Bu bilgi tüm dosya sistemlerinde desteklenmediği için tüm sistemlerde göremeyebilirsiniz. Yine de güncel mimariye sahip bir sistemde çalışıyorsanız yeni dosya sistemleri dolayısıyla dosyanın oluşturulma tarihi de tutuluyordur mutlaka.</p>

<p>Neticede bakın benim sürekli öznitelik olarak bahsetmiş olduğum bu meta veriler üzerinden dosya hakkında çeşitli tarih bilgilerini öğrenebiliyoruz. Sistem yönetimi sırasında özellikle sırlama ve denetleme gibi işlevleri yerine getirirken bu bilgilerden faydalanabiliyoruz.</p>

<p><code class="language-plaintext highlighter-rouge">touch</code> komutu da erişim ve düzenleme tarihlerinin doğrudan değiştirilmesi konusunda bize yardımcı oluyor.</p>

<p>Örneğin ben dosyanın erişim tarihini güncellemek istersem “<strong>a</strong>ccess” yani “erişim” ifadesinin kısaltmasından gelen <code class="language-plaintext highlighter-rouge">a</code> seçeneği ile <code class="language-plaintext highlighter-rouge">touch -a dosya ismi</code> şeklinde dosyanın erişim tarihini şimdiki tarih ile değiştirebilirim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">stat </span>yeni-liste 
  File: yeni-liste
  Size: 228             Blocks: 8          IO Block: 4096   regular file
Device: 801h/2049d      Inode: 2893400     Links: 1
Access: <span class="o">(</span>0644/-rw-r--r--<span class="o">)</span>  Uid: <span class="o">(</span> 1000/    taylan<span class="o">)</span>   Gid: <span class="o">(</span> 1000/    taylan<span class="o">)</span>
Access: 2023-06-11 05:24:30.303662486 <span class="nt">-0400</span>
Modify: 2023-06-11 10:29:21.455971533 <span class="nt">-0400</span>
Change: 2023-06-11 10:36:40.927598070 <span class="nt">-0400</span>
 Birth: 2023-06-11 05:22:23.195248608 <span class="nt">-0400</span>

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">touch</span> <span class="nt">-a</span> yeni-liste                                                        

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">stat </span>yeni-liste                                                        
  File: yeni-liste
  Size: 228             Blocks: 8          IO Block: 4096   regular file
Device: 801h/2049d      Inode: 2893400     Links: 1
Access: <span class="o">(</span>0644/-rw-r--r--<span class="o">)</span>  Uid: <span class="o">(</span> 1000/    taylan<span class="o">)</span>   Gid: <span class="o">(</span> 1000/    taylan<span class="o">)</span>
Access: 2023-06-11 10:41:09.213674288 <span class="nt">-0400</span>
Modify: 2023-06-11 10:29:21.455971533 <span class="nt">-0400</span>
Change: 2023-06-11 10:41:09.213674288 <span class="nt">-0400</span>
 Birth: 2023-06-11 05:22:23.195248608 <span class="nt">-0400</span>
</code></pre></div></div>

<p>Bakın erşim tarihi bu komutu girdiğim zaman olarak değişmiş.</p>

<p>Benzer şekilde yalnızca düzenlenme tarihini değiştirmek istiyorsam “modify” ifadesinin kısaltmasından gelen <code class="language-plaintext highlighter-rouge">m</code> seçeneğini de kullanabilirim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">stat </span>yeni-liste                                                        
  File: yeni-liste
  Size: 228             Blocks: 8          IO Block: 4096   regular file
Device: 801h/2049d      Inode: 2893400     Links: 1
Access: <span class="o">(</span>0644/-rw-r--r--<span class="o">)</span>  Uid: <span class="o">(</span> 1000/    taylan<span class="o">)</span>   Gid: <span class="o">(</span> 1000/    taylan<span class="o">)</span>
Access: 2023-06-11 10:41:09.213674288 <span class="nt">-0400</span>
Modify: 2023-06-11 10:29:21.455971533 <span class="nt">-0400</span>
Change: 2023-06-11 10:41:09.213674288 <span class="nt">-0400</span>
 Birth: 2023-06-11 05:22:23.195248608 <span class="nt">-0400</span>

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">touch</span> <span class="nt">-m</span> yeni-liste                                                        

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">stat </span>yeni-liste                                                        
  File: yeni-liste
  Size: 228             Blocks: 8          IO Block: 4096   regular file
Device: 801h/2049d      Inode: 2893400     Links: 1
Access: <span class="o">(</span>0644/-rw-r--r--<span class="o">)</span>  Uid: <span class="o">(</span> 1000/    taylan<span class="o">)</span>   Gid: <span class="o">(</span> 1000/    taylan<span class="o">)</span>
Access: 2023-06-11 10:41:09.213674288 <span class="nt">-0400</span>
Modify: 2023-06-11 10:56:52.024845155 <span class="nt">-0400</span>
Change: 2023-06-11 10:56:52.024845155 <span class="nt">-0400</span>
 Birth: 2023-06-11 05:22:23.195248608 <span class="nt">-0400</span>
</code></pre></div></div>

<p>Bakın düzenlenme tarihi de tam olarak komutu girdiğim tarih ile değişmiş.</p>

<p>Eğer biz komutu girdiğimiz sıradaki mevcut tarih yerine spesifik bir tarih belirtmek istersek “date” ifadesinin kısaltmasından gelen <code class="language-plaintext highlighter-rouge">-d</code> seçeneğini kullanarak tam tarih bilgisini yazmamız gerekiyor.</p>

<p>Ben denemek için 2015 yılının 1 haziran gününde saat tam 12:33’te hem erişim hem de düzenleme tarihi olarak tanımlamak istediğim için komutumu <code class="language-plaintext highlighter-rouge">touch -d "2015-06-01 12:33:00" yeni-liste</code>  şeklinde giriyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">touch</span> <span class="nt">-d</span> <span class="s2">"2015-06-01 12:33:00"</span> yeni-liste 

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">stat </span>yeni-liste 
  File: yeni-liste
  Size: 228             Blocks: 8          IO Block: 4096   regular file
Device: 801h/2049d      Inode: 2893400     Links: 1
Access: <span class="o">(</span>0644/-rw-r--r--<span class="o">)</span>  Uid: <span class="o">(</span> 1000/    taylan<span class="o">)</span>   Gid: <span class="o">(</span> 1000/    taylan<span class="o">)</span>
Access: 2015-06-01 12:33:00.000000000 <span class="nt">-0400</span>
Modify: 2015-06-01 12:33:00.000000000 <span class="nt">-0400</span>
Change: 2023-06-11 11:02:12.749127535 <span class="nt">-0400</span>
 Birth: 2023-06-11 05:22:23.195248608 <span class="nt">-0400</span>
</code></pre></div></div>

<p>Bakın hem erişim hem de düzenlenme tarihi değişmiş.</p>

<p>Eğer ikisini birden değiştirmek istemezsek bunu özellikle ilgili seçenek sayesinde belirtebiliriz. Ben yalnızca düzenlenme saatini değiştirmek istediğim için <code class="language-plaintext highlighter-rouge">-d</code> seçeneğinden önce “<code class="language-plaintext highlighter-rouge">m</code>” seçeneğini de ekliyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">touch</span> <span class="nt">-md</span> <span class="s2">"2016-06-01 12:33:00"</span> yeni-liste                              

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">stat </span>yeni-liste                                 
  File: yeni-liste
  Size: 228             Blocks: 8          IO Block: 4096   regular file
Device: 801h/2049d      Inode: 2893400     Links: 1
Access: <span class="o">(</span>0644/-rw-r--r--<span class="o">)</span>  Uid: <span class="o">(</span> 1000/    taylan<span class="o">)</span>   Gid: <span class="o">(</span> 1000/    taylan<span class="o">)</span>
Access: 2015-06-01 12:33:00.000000000 <span class="nt">-0400</span>
Modify: 2016-06-01 12:33:00.000000000 <span class="nt">-0400</span>
Change: 2023-06-11 11:05:39.816609760 <span class="nt">-0400</span>
 Birth: 2023-06-11 05:22:23.195248608 <span class="nt">-0400</span>
</code></pre></div></div>

<p>Bakın bu kez de yalnızca düzenlenme tarihi tam olarak benim belirtmiş olduğum tarih olarak değişmiş oldu.</p>

<p>İşte <code class="language-plaintext highlighter-rouge">touch</code> aracının en temel kullanımı bu şekilde. Yani artık <code class="language-plaintext highlighter-rouge">touch</code> aracının yalnızca boş dosya oluşturmak için değil, aslında tarih bilgilerini düzenlemek için kullanıldığını biliyoruz. Tarih değişimine pek ihtiyaç duymasanız da ihtiyaç duyduğunuzda bu aracın kullanımını anımsıyor olacaksınız. Zaten kullanımı çok basit olduğu için seçenekleri unutmuş olsanız bile <code class="language-plaintext highlighter-rouge">touch —help</code> komutuyla kontrol edebilirsiniz.</p>

<h1 id="echo-komutu">echo Komutu</h1>

<p>Daha önce örneklerimizde <code class="language-plaintext highlighter-rouge">echo</code> komutunu sıklıkla kullandık. “echo” “eko” ifadesi sizin de bildiğiniz gibi Türkçe olarak “yankılanmak, yansıtmak” anlamına geliyor. Zaten komutun işlevi de tam olarak bu. Kendisine argüman olarak verilenleri konsola veya yönlendirildiği yere yansıtıyor. En basit haliyle <code class="language-plaintext highlighter-rouge">echo</code> komutundan sonra yazacağımız tüm ifadeler, <code class="language-plaintext highlighter-rouge">echo</code> tarafından konsola bastırılıyor. Ben örnek olarak <code class="language-plaintext highlighter-rouge">echo merhabalar</code> yazıyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo </span>merhabalar
merhabalar

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="err">$</span>
</code></pre></div></div>

<p>Gördüğünüz gibi “merhabalar” çıktısı konsola basıldı. Dilersek konsola bastırmak yerine herhangi bir dosyaya da yönlendirebiliriz. Örneğin <code class="language-plaintext highlighter-rouge">echo "hello" &gt; hello.txt</code> komutunu girersem, hello ifadesi hello.txt dosyasına yazılmış olacak. Zaten daha önce de <code class="language-plaintext highlighter-rouge">echo</code> komutunu bu şekilde yönlendirmelerle birlikte kullanmıştık.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"hello"</span> <span class="o">&gt;</span> hello.txt

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat </span>hello.txt 
hello
</code></pre></div></div>

<p>Bakın dosyamız oluşturulmuş ve içerisine “hello” verisi de eklenmiş.</p>

<p>Ayrıca <code class="language-plaintext highlighter-rouge">echo</code> komutunu yalnızca tek satırlık veriler için kullanmak zorunda da değiliz. Eğer yazacaklarımız birden fazla satır tutacaksa, tırnak işaretini kapatmadan satır satır, yazmak istediklerimizi yazabiliyoruz. Ben denemek için açtığım tırnağı kapatmadan birden fazla satırda veriler ekleyip, en son gireceklerim bittiğinde açtığım tırnağı kapatıp enter ile komutumu onaylıyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"bu ilk
&gt; bu ikinci
&gt; bu uc
&gt; bu ise son satır"</span>
bu ilk
bu ikinci
bu uc
bu ise son satır

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="err">$</span>
</code></pre></div></div>

<p>Bakın tırnağı kapatana kadar girmiş olduğum tüm veriler, aynen girdiğim şekilde konsola bastırılmış oldu.</p>

<p>Eğer konsola bastırmak yerine bu yazdıklarımı bir dosyaya yönlendirmek istersem tırnağı kapattıktan sonra yönlendirme operatörü ile ilgili dosyayı belirtip enter ile işlemi onaylayabiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"bu ilk
bu ikinci
bu uc
bu ise son satır"</span> <span class="o">&gt;</span> satırlar

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]                                                             
└─<span class="nv">$ </span><span class="nb">cat </span>satırlar 
bu ilk
bu ikinci
bu uc
bu ise son satır
</code></pre></div></div>

<p>Gördüğünüz gibi <code class="language-plaintext highlighter-rouge">&gt;</code> yönlendirme operatörü sayesinde <code class="language-plaintext highlighter-rouge">echo</code> komutuna birden fazla satırda girmiş olduğum verileri “<strong><em>satırlar</em></strong>” isimli dosyaya sorunuzca aktarmış oldum.</p>

<p><code class="language-plaintext highlighter-rouge">echo</code> komutunun çıktılarını bir dosyaya sorunsuzca yönlendirebildik ancak daha önce de bizzat deneyimlediğimiz gibi <code class="language-plaintext highlighter-rouge">echo</code> komutunun standart girdiden veri okumadığına tekrar dikkatinizi çekmek istiyorum. Bu durumu tekrar teyit etmek istersek, örneğin biraz önce <code class="language-plaintext highlighter-rouge">echo</code> komutu ile içine satırlar eklediğimiz “<strong><em>satırlar</em></strong>” dosyasını <code class="language-plaintext highlighter-rouge">echo</code> komutu aracılığı ile konsola bastırmak üzere <code class="language-plaintext highlighter-rouge">echo &lt; sonuclar</code> şeklinde komutumuzu girebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo</span> &lt; satırlar                                                            

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="err">$</span>
</code></pre></div></div>

<p>Bakın, gördüğünüz gibi konsola herhangi bir çıktı basılmadı. Çünkü <code class="language-plaintext highlighter-rouge">echo</code> komutu standart girdiden veri okumuyor. Biz göndersek de <code class="language-plaintext highlighter-rouge">echo</code> komutu standart girdiden veri kabul etmediği için <code class="language-plaintext highlighter-rouge">echo</code> komutuna aslında yankılayabileceği hiç bir argüman vermiş olmuyoruz. Dolayısıyla konsola hiç bir veri bastırılamıyor. <code class="language-plaintext highlighter-rouge">echo</code> komutu çalışma yapısı gereği yalnızca kendisine argüman olarak verilmiş olan ifadeleri konsola yankılıyor yani bastırıyor.</p>

<p>Zaten <code class="language-plaintext highlighter-rouge">help echo</code> komutu ile yardım sayfasına göz atacak olursanız, yardım bilgisinin en üstünde <code class="language-plaintext highlighter-rouge">echo</code> komutunun argümanları standart çıktıya yazdırdığı açıkça yazıyor.</p>

<p><img src="https://superua1.github.io//egitim/metin/8.png" alt="8.png" class="responsive img-zoomable" /></p>

<p>Ayrıca gördüğünüz gibi standart girdiden veri kabul ettiğine dair herhangi bir açıklama da bulunmuyor. Burada kast edilen argüman yapısının ne olduğunu zaten biliyorsunuz.</p>

<p>Özetle <code class="language-plaintext highlighter-rouge">echo</code> yalnızca kendisine argüman olarak aktarılanları standart çıktı aracılığı ile konsola veya özellikle belirtildiyse başka bir hedefe yönlendirmekle mükellef bir araç. Eğer hatırlıyorsanız, ben yönlendirmelerden bahsederken kimi araçların standart girdiden veri almayabileceğinden de bahsetmiştim. İşte <code class="language-plaintext highlighter-rouge">echo</code> aracı da bahsi geçen bu araçlardan biri. Kimi araçlar yalnızca argümanları işlemek için tasarlandıklarından, standart girdiden veri kabul etmiyorlar.</p>

<p>Hatta <code class="language-plaintext highlighter-rouge">echo</code> komutunun yalnızca argümanları yankıladığına dair basit bir örnek vermek gerekirse <code class="language-plaintext highlighter-rouge">echo *</code> komutunu kullanabiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]                                                                                      
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="k">*</span>
ada calısma Desktop Documents dosya.txt Downloads harf.txt hatalı.txt hatasız2.txt hatasız.txt hello.txt klasor liste2 liste3 liste.txt metin metin1.txt metin2.txt Music nihai-liste Pictures Public satırlar sayi.txt sonuc Templates test.sh Videos yeni yeni klasor yeni-liste yepyenidosya
</code></pre></div></div>

<p>Biliyorsunuz buradaki yıldız <code class="language-plaintext highlighter-rouge">*</code> işareti kabuk için tüm dosya ve dizin isimleriyle eşleşen bir genişletme karakteri. Dolayısıyla bu karakterin olduğu yere kabuk tarafından mevcut dosya ve dizin isimlerinden uygun olan tüm karakterler getirilebiliyor. Kabuk <code class="language-plaintext highlighter-rouge">echo</code> komutunu gördüğünde bu aracı çalıştırması gerektiğini anlıyor, daha sonra yıldız simgesini görüyor. Yıldız işareti bash kabuğu için dosya ismi genişletmesi anlamına geldiği için kabuğumuz bu genişletmeyi uyguluyor. Yani yıldız işretinin yerini, mevcut dizindeki dosya ve klasörlerin isimleri alıyor. Dolayısıyla <code class="language-plaintext highlighter-rouge">echo</code> komutuna da argüman olarak dosya ve dizinlerin isimleri verilmiş oluyor. <code class="language-plaintext highlighter-rouge">echo</code> komutu da argümanlarını konsola çıktı olarak yansıtıyor yani standart çıktılarını konsola yönlendiriyor.</p>

<p>İşte sizlerin de görebildiği gibi, kabuğun çalışma yapısını ve temel özelliklerini bildiğimizde, bu örnekte olduğu gibi komut verme konusunda inanılmaz esnekliğe sahip olabiliyoruz. Ben sadece dikkat çekici bir örnek olması için tekrar bu örneği ele aldım.</p>

<p>Tıpkı bu örnekte olduğu gibi <code class="language-plaintext highlighter-rouge">echo</code> komutu da dahil tüm komutların pek çok esnek kullanım imkanları var. Yeter ki biz temelde nasıl çalıştıklarını bilelim.</p>

<p>Ayrıca şu ana kadar ele aldığımız kullanımlar dışında <code class="language-plaintext highlighter-rouge">echo</code> komutun pek çok ek seçeneği bulunuyor. Bunları görmek için tekrar <code class="language-plaintext highlighter-rouge">help echo</code> komutunu kullanabiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">help echo
echo</span>: <span class="nb">echo</span> <span class="o">[</span><span class="nt">-neE</span><span class="o">]</span> <span class="o">[</span>arg ...]
    Write arguments to the standard output.
    
    Display the ARGs, separated by a single space character and followed by a
    newline, on the standard output.
    
    Options:
      <span class="nt">-n</span>        <span class="k">do </span>not append a newline
      <span class="nt">-e</span>        <span class="nb">enable </span>interpretation of the following backslash escapes
      <span class="nt">-E</span>        explicitly suppress interpretation of backslash escapes
    
    <span class="sb">`</span><span class="nb">echo</span><span class="s1">' interprets the following backslash-escaped characters:
      \a        alert (bell)
      \b        backspace
      \c        suppress further output
      \e        escape character
      \E        escape character
      \f        form feed
      \n        new line
      \r        carriage return
      \t        horizontal tab
      \v        vertical tab
      \\        backslash
      \0nnn     the character whose ASCII code is NNN (octal).  NNN can be
                0 to 3 octal digits
      \xHH      the eight-bit character whose value is HH (hexadecimal).  HH
                can be one or two hex digits
      \uHHHH    the Unicode character whose value is the hexadecimal value HHHH.
                HHHH can be one to four hex digits.
      \UHHHHHHHH the Unicode character whose value is the hexadecimal value
                HHHHHHHH. HHHHHHHH can be one to eight hex digits.
    
    Exit Status:
    Returns success unless a write error occurs.
</span></code></pre></div></div>

<p>Bakın burada pek çok özel karakter bulunuyor. Hepsine tek tek değinmemize gerek yok. Ama kısaca bir göz atalım.</p>

<p>Normalde echo komutunun ardından yazdığımız ifade konsola doğrudan bastırılıyor.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo </span>merhaba                                                                                                 
merhaba

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo </span>merhaba                                                                                                 
merhaba

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
</code></pre></div></div>

<p>Burada dikkat etmemiz gereken detay, aslında bizim girdiğimiz ifadeden sonra <code class="language-plaintext highlighter-rouge">echo</code> komutunun otomatik olarak yeni satıra geçme karakteri gizlice kullanıyor olması. Bu durumu teyit etmek için otomatik olarak yeni satıra geçme özelliğini kapatmak üzere <code class="language-plaintext highlighter-rouge">-n</code> seçeneğini kullanabiliriz. <code class="language-plaintext highlighter-rouge">n</code> seçeneği “<strong>n</strong>ewline” yani “yeni satır” ifadesinin kısaltmasından geliyor. Bu şekilde aklınızda daha kolay kalabilir.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="nt">-n</span> merhaba                                                                                              
merhaba
┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="err">$</span>
</code></pre></div></div>

<p>Önceki çıktı ile kıyaslayacak olursanız bir alt satıra geçilmediğini teyit edebilirsiniz. Böylelikle <code class="language-plaintext highlighter-rouge">echo</code> komutunun aslında, gizli “yeni satır” eklediğini öğrenmiş olduk. Elbette yardım sayfası üzerinde de görebildiğimiz gibi <code class="language-plaintext highlighter-rouge">echo</code> aracının pek çok biçimlendirme özelliği bulunuyor.</p>

<p>Kısaca bu biçimlendirme özelliklerinden de bahsedecek olursak. <code class="language-plaintext highlighter-rouge">echo</code> aracı, ters slash <code class="language-plaintext highlighter-rouge">\</code> ile başlayan ifadeleri gördüğünde onların özel anlamlarına göre çıktıyı biçimlendiriyor. Fakat bu ifadeleri doğrudan kullanamıyoruz. Bu biçimlendirme ifadelerini kullanırken <code class="language-plaintext highlighter-rouge">echo</code> komutunun <code class="language-plaintext highlighter-rouge">-e</code> seçeneğini kullanarak, <code class="language-plaintext highlighter-rouge">echo</code> komutuna bu karakterlere özel anlamlarına göre dikkate alaması gerektiğini özellikle belirtmemiz şart. Aksi halde buradaki ifadeleri kullansak bile bunlar <code class="language-plaintext highlighter-rouge">echo</code> komutu için sıradan karakterlerden ibaret olacak. Hemen deneyelim. Ben yeni satıra geçmeyi sağlayan <code class="language-plaintext highlighter-rouge">\n</code> ifadesini kullanacağım. Komutumu <code class="language-plaintext highlighter-rouge">echo "merhaba \n dünya"</code> şeklinde giriyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"merhaba </span><span class="se">\n</span><span class="s2"> dünya"</span>
merhaba <span class="se">\n</span> dünya

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="err">$</span>
</code></pre></div></div>

<p>Bakın çıktılarda <code class="language-plaintext highlighter-rouge">\n</code> ifadesi de yazdığımız şekilde duruyor ve yeni bir satıra da geçilmemiş. Aynı örneğini bu kez <code class="language-plaintext highlighter-rouge">-e</code> seçeneği varken tekrar deneyelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"merhaba </span><span class="se">\n</span><span class="s2"> dünya"</span>                                                                                   
merhaba 
 dünya

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="err">$</span>
</code></pre></div></div>

<p>Bakın bu kez <code class="language-plaintext highlighter-rouge">\n</code> ifadesi <code class="language-plaintext highlighter-rouge">echo</code> komutu tarafından dikkate alındı ve ikinci kelimemiz bir alt satırda bastırıldı. Dikkat ettiyseniz tırnak içinde yazdım. Çünkü biçimlendirme özelliklerinin doğru şekilde çalışması için tırnak içinde yazmamız gerekiyor. Daha önce tek ve çift tırnak kullanımı arasındaki farklardan bahsetmiştik. Bu doğrultuda tek veya çift tırnak kullanma seçimi size ait.</p>

<p>Ayrıca hatırlıyorsanız daha önce <code class="language-plaintext highlighter-rouge">echo</code> komutunu ve süslü parantez genişletmelerini kullanarak sıralı karakterleri alt alta olacak şekilde biçimlendirmiştik. Şimdi tekrar aynı komutu kullanıp sonuçlarına bakabiliriz. Aynı örneği gerçekleştirmek için <code class="language-plaintext highlighter-rouge">echo -e "\n"{a..z}</code> komutunu girelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="o">{</span>a..z<span class="o">}</span>

a 
b 
c 
d 
e 
f 
g 
h 
i 
j 
k 
l 
m 
n 
o 
p 
q 
r 
s 
t 
u 
v 
w 
x 
y 
z
</code></pre></div></div>

<p>Bakın <code class="language-plaintext highlighter-rouge">echo</code> komutunun <code class="language-plaintext highlighter-rouge">-e</code> seçeneğinden ve <code class="language-plaintext highlighter-rouge">\n</code> şeklinde yazılan yeni satır biçimlendirme özelliğinden faydalanmış olduk. Etkisini görmek için aynı örneği <code class="language-plaintext highlighter-rouge">\n</code> olmadan da test edebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="nt">-e</span> <span class="o">{</span>a..z<span class="o">}</span>                                                                                           
a b c d e f g h i j k l m n o p q r s t u v w x y z
</code></pre></div></div>

<p>Bakın yeni satıra geçme karakteri olmayınca tüm veriler aynı satırda bastırıldı. Bu örnek bu biçimlendirme karakterlerinin gerektiğinde oldukça kullanışlı olabildiğini gösteren çok basit bir örnek.</p>

<p>İşte sizler de benim bu örnek üzerinden ele aldığım gibi, yardım sayfasında yer alan diğer tüm biçimlendirme özelliklerini <code class="language-plaintext highlighter-rouge">-e</code> seçeneği ile birlikte <code class="language-plaintext highlighter-rouge">echo</code> komutu üzerinden kullanabilirsiniz.</p>

<p>Buradaki seçeneklerin hepsini ezberlemek zorunda değilsiniz. Hatta hiç birini ezberlemeyin. Çünkü ezberlemeniz gerekmiyor, kullandıkça bu ifadeleri zaten hatırlıyor olacaksınız. Hatırlayamadığınız zaman yardım sayfasından kısa sürede tekrar bakabilirsiniz. Zaten kısaltmaların, temsil ettiği biçimlendirme özellikleri ile uyumlu olduğunu da göz önünde bulundurduğumuzda, pratik yaptıkça sık kullandığınız seçeneklerin hemen aklınıza geldiğini sizler de fark edeceksiniz. Ayrıca buradaki biçimlendirme ifadeleri, çoğu araçta benzer şekilde olduğundan bir kez öğrendiğinizde sistem üzerindeki metin biçimlendirme araçların pek çoğunda aynı ifadeleri kullanabiliyor olacaksınız.</p>

<p>Yani özetle benim bahsetmediğim diğer seçeneklerin açıklamasına bakarak, tam olarak nasıl bir biçimlendirme uyguladığını bizzat test etmeniz yeterli. Hem bu sayede pratik yapmış olursunuz.</p>

<h1 id="paste-komutu">paste Komutu</h1>

<p>İleride dosya içeriklerini değiştirip dosyaların değişimlerini kıyaslamak için yan yana bastırmak istediğimiz örneklerle karşılaşacağımız için ilk olarak <code class="language-plaintext highlighter-rouge">paste</code> aracından bahsetmek istedim. Normalde <code class="language-plaintext highlighter-rouge">cat</code> komutu ile birden fazla dosyayı okurken dosyaların içerikleri peşi sıra alt alta bastırılıyorken, <code class="language-plaintext highlighter-rouge">paste</code> aracı ile bu çıktıların yan yana bastırılmasını sağlayabiliriz. Yani <code class="language-plaintext highlighter-rouge">cat</code> aracı satırların birleştirilmiş çıktılarını üretirken, <code class="language-plaintext highlighter-rouge">paste</code> aracı sütunların birleştirilmiş çıktılarını sunuyor.</p>

<p>Ben denemek için önceden oluşturduğum “<strong><em>şehir” “harf”</em></strong> ve “<strong><em>rakam”</em></strong> isimli dosyaları yan yana bastırmak istiyorum. Ama bundan önce <code class="language-plaintext highlighter-rouge">cat</code> komutu ile farkını daha rahat gözlemleyebilmek adına bu dosyaları okumak üzere <code class="language-plaintext highlighter-rouge">cat harf sehir rakam</code> komutunu girelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat </span>harf sehir rakam
a
b
c
d
e
f
istanbul
Ankara
İzmir
bursa
antayla
Kocaeli
1
2
3
4
5
6
</code></pre></div></div>

<p>Bakın tam da beklediğimiz gibi tüm dosyalardaki satırlar alt alta birleşik halde bastırıldı. Şimdi bunları yan yana bastırmak için <code class="language-plaintext highlighter-rouge">paste harf sehir rakam</code> şeklinde komutumuz tekrar girelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">paste </span>harf sehir rakam                                                                                       
a       istanbul        1
b       Ankara  2
c       İzmir   3
d       bursa   4
e       antayla 5
f       Kocaeli 6
</code></pre></div></div>

<p>Bakın bu kez dosyalardaki satırlar üç farklı sütunda yan yana bastırılmış oldu. <code class="language-plaintext highlighter-rouge">paste</code> aracının bize sunduğu kolaylık tam olarak bu.</p>

<p>Burada dosya içeriklerinin kolay ayırt edilebilmesi için sütunlar arasında boşluklar yer alıyor. Fakat dilersek, bastırılan sütunlar arasında boşluk yerine özel bir işaret yani özel bir sınırlayıcı karakter de ekleyebiliriz. Örneğin ben her bir sütun arasına kısa dikey çizgi eklemek istiyorum. <code class="language-plaintext highlighter-rouge">paste</code> aracına sütunları nasıl ayıracağını belirtmek için de İngilizce “<strong>d</strong>elimiter” yani “sınırlayıcı” ifadesinin kısalmasından gelen <code class="language-plaintext highlighter-rouge">-d</code> seçeneğinin ardından sınırlayıcı karakteri yazabiliriz.</p>

<p>Ben sınırlayıcı olarak dikey çizgiyi kullanmak istediğim için komutumuz <code class="language-plaintext highlighter-rouge">paste -d "|" harf sehir rakam</code> şeklinde giriyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">paste</span> <span class="nt">-d</span> <span class="s2">"|"</span> harf sehir rakam                                                                                
a|istanbul|1
b|Ankara|2
c|İzmir|3
d|bursa|4
e|antayla|5
f|Kocaeli|6
</code></pre></div></div>

<p>Bakın, tüm sütunların arasında dikey çizgi yer alıyor, çünkü ben sınırlayıcı karakter olarak buradaki dik çizgi karakterini tanımlamıştım. Tabii ki sizler dilediğiniz bir karakteri sınırlayıcı olarak kullanabilirsiniz. Hatta birden fazla sınırlayıcı karakter de belirtebilirsiniz. Örneğin dikey çizgi ve kısa çizgi karakterlerini sınırlayıcı olarak kullanırsak, sırasıyla iki sınırlayıcı da dosya içeriklerini sınırlamak için kullanılıyor olacak. Bu durumu daha net gözlemeyebilmek adına daha fazla dosyayı yan yana bastırsak daha iyi olur. Ben aynı dosyaları tekrar tekrar yan yana bastırmak istiyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">paste</span> <span class="nt">-d</span> <span class="s2">"|-"</span> harf sehir rakam sehir harf rakam
a|istanbul-1|istanbul-a|1
b|Ankara-2|Ankara-b|2
c|İzmir-3|İzmir-c|3
d|bursa-4|bursa-d|4
e|antayla-5|antayla-e|5
f|Kocaeli-6|Kocaeli-f|6
</code></pre></div></div>

<p>Bakın, gördüğünüz gibi sırasıyla hem dikey çizgi hem de kısa çizgi karakterleri sütunlar arasındaki sınırlayıcı olarak kullanılmış. İşte sizler de bu şekilde sütunları istediğiniz sınırlayıcı karakterle birbirinden ayırabilirsiniz. Birden fazla sınırlayıcı belirttiğimizde tıpkı burada aldığımız çıktıda da olduğu gibi bu karakterler sırasıyla soldan sağa doğru tekrar eden bir örüntü gibi kullanılıyor olacak. İhtiyacınız doğrultusunda tek ve birden fazla sınırlayıcı karakter belirtebilirsiniz. Hatta sınırlayıcı olarak tırnak içinde hiç bir karakter belirtmezseniz doğrudan boşluk olmadan dosyaların birbirine yapıştırılmasını da sağlayabilirsiniz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">paste</span> <span class="nt">-d</span> <span class="s2">""</span> harf sehir rakam                                                              
aistanbul1
bAnkara2
cİzmir3
dbursa4
eantayla5
fKocaeli6
</code></pre></div></div>

<p>Bakın, dosyalardaki tüm satırlar aralarında boşluk olmadan sütunlarda birleştirilmiş. Tıpkı bu örnekte olduğu gibi ihtiyacınıza yönelik şekilde sınırlayıcı karakter belirtmekte özgürsünüz.</p>

<p>Ayrıca sınırlama işareti dışında eğer her bir satırı yan yana değil de alt alta eşleşecek şekilde sıralamak istersek <code class="language-plaintext highlighter-rouge">-s</code> seçeneğini de kullanabiliyoruz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">paste</span> <span class="nt">-s</span> harf sehir rakam                                                                                 
a       b       c       d       e       f
istanbul        Ankara  İzmir   bursa   antayla Kocaeli
1       2       3       4       5       6
</code></pre></div></div>

<p>Görebildiğiniz gibi normalde satırlar yan yana basılırken şimdi dosyalardaki her bir satır alt alta gelmiş şekilde basılmış oldu.</p>

<p>Sizler ihtiyacınıza göre <code class="language-plaintext highlighter-rouge">paste</code> aracını kullanarak istediğiniz sayıda dosyanın satırlarını birebir yan yana ya da alt alta birleştirebilirsiniz. Eğer birden fazla dosya içeriğinin yan yana birleştirilmiş hali lazımsa komutunuzun sonuna yönlendirme işareti ekleyip çıktıları yeni bir dosya olarak kaydedebilirsiniz. Ben en son girdiğim komutun sonuna <code class="language-plaintext highlighter-rouge">&gt; paste-sonucları</code> ekleyip çıktıları dosyaya kaydediyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">paste</span> <span class="nt">-s</span> harf sehir rakam <span class="o">&gt;</span> paste-sonucları                                                                  

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat </span>paste-sonucları                                                                                          
a       b       c       d       e       f
istanbul        Ankara  İzmir   bursa   antayla Kocaeli
1       2       3       4       5       6
</code></pre></div></div>

<p>Bakın çıktılar dosyama kaydolmuş. Neticede <code class="language-plaintext highlighter-rouge">paste</code> aracını kullanarak mevcut dosyaları yan yana veya dikey olarak nasıl birleştirebileceğimizi de ele almış olduk. Ayrıca ben yönlendirmek için tek büyüktür yine yeni bir dosya oluşturmayı tercih ettim ama siz diğer yönlendirme alternatiflerini biliyorsunuz.</p>

<p>Zaten artık hatırlatmama gerek yok. Sizler yönlendirmeler ile ilgili bilmeniz gereken tüm temel altyapıya sahipsiniz. İhtiyaçlarınıza göre sistem üzerinde tüm araçlarda kullanabilirsiniz. Özellikle veri bilimi gibi alanlarda çalışırken, bu şekilde birden fazla kaynaktan alınan verilerin istenildiği şekilde derlenebilmesi çok kullanışlı olabiliyor. Tüm mesele elimizdeki verileri ihtiyaçlarımıza göre düzenleyip kullanabilmek.</p>

<h1 id="sort-komutu">sort Komutu</h1>

<p>Özellikle düzensiz haldeki büyük veriler üzerinde çalışıyorken <code class="language-plaintext highlighter-rouge">sort</code> gibi araçlar yardımıyla bu verileri düzenlememiz gerekebiliyor. Tahmin edebileceğiniz gibi zaten buradaki <code class="language-plaintext highlighter-rouge">sort</code> aracının ismi de Türkçe olarak “sıralamak-sınıflandırmak” ifadelerine karşılık geliyor.</p>

<p><code class="language-plaintext highlighter-rouge">sort</code> aracı sayesinde elimizdeki düzensiz verileri, belirli özelliklere göre kolayca sınıflandırabiliyoruz.</p>

<p>sort aracının kullanılabilecek pek çok özelliği olmasına karşın, eğer herhangi bir seçenek belirtmeden doğrudan karışık satırları <code class="language-plaintext highlighter-rouge">sort</code> aracına iletirsek;</p>

<p>Öncelikle tüm satırlardaki ilk karakterlere bakıp sırasıyla sayılar, daha sonra harfler ve son olarak eğer aynı harfler varsa küçük harfler öncelikli olacak şekilde sıralanıyorlar. Ve bu sıralama işlemi tüm satırlardaki tüm karakterler sıralanıncaya kadar tekrar tekrar devam ediyor.</p>

<p>Yani ilk olarak tüm satırlardaki karakterlere bakılıp tüm satırlar buradaki kural dahilinde sıralanıyor. Daha sonra ilk karakteri aynı olan satırlar ikinci karaktere göre kendi içlerinde bir daha sıralanıyor ve bu işlem satırlardaki tüm karakterler bitine kadar bu şekilde gerçekleştiriliyor. Bu şekilde tüm satırlarda yer alan tüm karakterleri baştan sonra kendi standart kuralı dahilinde sıralamış oluyor.</p>

<p>Uygulamalı olarak daha net anlaşılacağı için hemen bir dosya üzerinde test edelim. Ben örnek olarak içerisinde küçük büyük harfler ve rakamlar bulunan bir şablon kullanacağım. Bakın benim kullanacağım şablon bu. İçerisinde düzensiz veriler bulunan bu şablonu kullanıyorum çünkü biraz önce bahsetmiş olduğumuz tüm sıralama kurallarını net biçimde görmemiz mümkün olacak.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat</span> <span class="o">&gt;</span> sablon
b3
ba
B3
3B
a2
A1
a1
2a
1b
3b
</code></pre></div></div>

<p>Görebildiğiniz gibi kullanacağımız bu şablon, içerisinde küçük büyük harfler ve rakamlar bulunan son derece düzensiz bir içeriğe sahip. Şimdi bu dosyanın ismini <code class="language-plaintext highlighter-rouge">sort</code> komutundan sonra argüman olarak yapıp düzenli bir listenin nasıl göründüğüne bakalım.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">sort </span>sablon
1b
2a
3b
3B
a1
A1
a2
b3
B3
ba
</code></pre></div></div>

<p>Aldığımız çıktıyı inceleyecek olursak. Bakın öncelikle tüm satırlardaki ilk karakterlere bakılmış ve bunlar sayısal olarak sıralanmış. Daha sonra alfabetik olarak sıralanmış. <strong>a</strong> karakteri <strong>b</strong> den önce geldiği için küçük büyük harf fark etmeksizin ilk harfinde <strong>a</strong> olan tüm satırlar ilk karakterinde <strong>b</strong> olanlardan önce sıralanmış. Alfabetik sıralamadan sonra da aynı karaktere sahip olan satırlarda küçük karakterler büyüklerden önce sıralanmış. Bu sebeple küçük <strong>a</strong> karakterleri büyüklerden önce geliyor. Fakat burada <strong>A1</strong> satırı, başında küçük <strong>a</strong> olasına rağmen <strong>a2</strong> den önce gelmiş.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a1
A1
a2
</code></pre></div></div>

<p>Bu durumun nedeni ikinci karakterdeki <strong>2</strong> rakamı aslında. <code class="language-plaintext highlighter-rouge">sort</code> aracı sıralama işlemini tüm karakterleri tek tek sıralayıp tekrar tekrar sıralama yaptığı için bu şekilde çıktı aldık. Yani aslında <code class="language-plaintext highlighter-rouge">sort</code> aracı tıpkı bu örneğimizde olduğu gibi öncelikle sırasıyla tek tek karakterlere bakarak sıralama yapıyor olsa da tüm karakterlerin kendisine göre hesapladığı ağırlık değerlerine göre yeniden sıralanmasını sağlıyor.</p>

<p>Yani aslında <code class="language-plaintext highlighter-rouge">sort</code> aracı ilk turda yalnızca buradaki ilk karaktere bakarak listeyi şu şekilde sıralıyor.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1b
2a
3b
3B
a1
a2
A1
b3
ba
B3
</code></pre></div></div>

<p>Daha sonra sıra ikinci karaktere bakmaya geliyor. Bu durumda ilk karakteri aynı olanları ikinci karaktere bakarak sıralıyor. Buradaki <strong>A1</strong> satırındaki <strong>1</strong> rakamı, <strong>a2</strong> satırındaki <strong>2</strong> rakamından küçük olduğu için daha fazla öncelik kazanıyor. Dolayısıyla baştaki <strong>a</strong> karakterinin büyük küçük olması bu sıralamayı değiştirmiyor.</p>

<p>İlk örneğimizde tek bir dosyadaki satırları sıraladık ancak dilersek birden fazla dosyayı da tek seferde <code class="language-plaintext highlighter-rouge">sort</code> komutu ile sıralayabiliriz. Hem bu sayede birden fazla dosya içeriğini sıralı şekilde birleştirmiş oluruz. Tıpkı <code class="language-plaintext highlighter-rouge">cat</code> komutun olduğu gibi ancak bu veriler sıralanmış olacak.</p>

<p>Ben denemek için <code class="language-plaintext highlighter-rouge">cat &gt; sayi</code> komutuyla yeni bir dosya açıp buna düzensiz veriler giriyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat</span> <span class="o">&gt;</span> sayi                    
10
4
6
2
21
95
3
3
75
8
1
01
40
</code></pre></div></div>

<p>Şimdi bir de düzensiz harfler oluşturmak üzere <code class="language-plaintext highlighter-rouge">cat &gt; harf</code> komutunun ardından rastgele karakterleri girelim.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">┌──</span><span class="p">(</span><span class="nx">taylan</span><span class="p">@</span><span class="nd">linuxdersleri</span><span class="p">)</span><span class="o">-</span><span class="p">[</span><span class="o">~</span><span class="p">]</span>
<span class="err">└─</span><span class="nx">$</span> <span class="nx">cat</span> <span class="o">&gt;</span> <span class="nx">harf</span>
<span class="nx">a</span>
<span class="nx">g</span>
<span class="nx">F</span>
<span class="nx">z</span>
<span class="nx">D</span>
<span class="nx">g</span>
<span class="nx">O</span>
<span class="nx">p</span>
<span class="nx">l</span>
<span class="nx">k</span>
<span class="nx">S</span>
<span class="nx">C</span>
<span class="nx">E</span>
<span class="nx">n</span>
<span class="nx">M</span>
<span class="nx">h</span>
<span class="nx">t</span>
<span class="nx">N</span>
</code></pre></div></div>

<p>Şimdi her iki dosyamızın ismini de argüman olarak verip aynı anda sıralamasını sağlayalım.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">sort </span>sayi harf                       
01
1
10
2
21
3
3
4
40
6
75
8
95
a
C
D
E
F
g
g
h
k
l
M
n
N
O
p
S
t
z
</code></pre></div></div>

<p>Gördüğünüz gibi dosyalar birleştirilip ortak şekilde sıralanmış oldu. Öncelikle rakamlar, daha sonra küçük karakter önce olacak şekilde alfabetik sıralama gerçekleştirilmiş. Ama sanki aldığımız çıktı biraz tuhaf gibi. Normalde sayıların sıralanması deyince çoğu kişinin aklına iki basamaklıklar da dahil tüm hepsinin küçükten büyüğe doğru sıralanması gerektiği geliyor. Ama önceki açıklamalarımıza dikkat ettiyseniz <code class="language-plaintext highlighter-rouge">sort</code> komutu her bir satırın yalnızca tek bir karakterini sıralıyor. Dolayısıyla sıralama yapılırken aslında sayılar değil 0 dan 9 a kadar olan rakamlar arasında sıralama yapılıyor. Buradaki ilk karakter olan yani ilk basamakta yer alan tüm rakamlar zaten matematiksel olarak küçükten büyüğe doğru sıralanmış. İlk karakterler sıralandıktan sonra da ilk karakteri yani ilk basamağı aynı olan rakamların da ikinci basamakları kendi içlerinde tekrar sıralanmış.</p>

<p>Yani aldığımız çıktıda herhangi bir problem yok. <code class="language-plaintext highlighter-rouge">sort</code> komutu buradaki sayıların bütüncül matematiksel büyüklüğüne bakmıyor, tek tek her bir satırdaki birer karakterlere bakıp ona göre sıralıyor.</p>

<p>Eğer dosya içeriğinin matematiksel büyüklüğü dikkate alınarak sıralansın istersek bunu “<strong>n</strong>umerical” yani “sayısal” ifadesin kısaltması olan <code class="language-plaintext highlighter-rouge">-n</code> seçeneği ile özellikle belirtmemiz gerekiyor. Şimdi “<strong><em>sayi</em></strong>” dosyasını <code class="language-plaintext highlighter-rouge">-n</code> seçeneğini de kullanarak tekrar sıralayalım.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">sort</span> <span class="nt">-n</span> sayi
01
1
2
3
3
4
6
8
10
21
40
75
95
</code></pre></div></div>

<p>Bakın bu kez dosya içeriğindeki veriler matematiksel büyüklüklerine göre sıralandı. Yani eğer sayısal sıralama yapacaksınız <code class="language-plaintext highlighter-rouge">n</code> seçeneğini kullanmanız gerektiğini unutmayın lütfen. Ya da unutun, tekrar yardım sayfasına bakıp hatırlayabilirsiniz zaten. Sadece yeri gelmişken bahsetmek istedim.</p>

<h2 id="sıralamayı-tersine-çevirmek">Sıralamayı Tersine Çevirmek</h2>

<p>Eğer <code class="language-plaintext highlighter-rouge">sort</code> komutunun sıraladığı satırları tersine çevirmek istersek, “<strong>r</strong>everse” yani “ters” ifadesinin kısaltması olan “<code class="language-plaintext highlighter-rouge">r</code>” seçeneğini kullanabiliyoruz.</p>

<p>Rahatça kıyaslayabilmek için öncelikle seçenek olmadan <code class="language-plaintext highlighter-rouge">sort</code> komutunu kullanalım.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">sort </span>sayi
01
1
10
2
21
3
3
4
40
6
75
8
95
</code></pre></div></div>

<p>Şimdi de -r seçeneğini ekleyip tersten sıralayalım.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">sort</span> <span class="nt">-r</span> sayi                         
95
8
75
6
40
4
3
3
21
2
10
1
01
</code></pre></div></div>

<p>Bakın iki çıktıyı kıyasladığımızda, satırların tam tersi şekilde sıralandığını görebiliyoruz.</p>

<p>Elbette dilersek <code class="language-plaintext highlighter-rouge">n</code> seçeneğiyle de birlikte kullanabiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">sort</span> <span class="nt">-n</span> sayi                        
01
1
2
3
3
4
6
8
10
21
40
75
95

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">sort</span> <span class="nt">-nr</span> sayi                        
95
75
40
21
10
8
6
4
3
3
2
1
01
</code></pre></div></div>

<p>Sizde bu seçenek sayesinde elinizdeki verileri ters alfabetik ya da ters numerik şekilde sıralayabilirsiniz.</p>

<h2 id="sütunlar-özel-sıralama">Sütunlar Özel Sıralama</h2>

<p><code class="language-plaintext highlighter-rouge">sort</code> komutu en baştan başlayıp tüm satırlardaki karakterleri tek tek sıralıyor. Fakat biz her zaman satırların en başındaki karaktere bakılmasını istemeyebiliriz. Yalnızca her satırın en başındaki karaktere göre sıralama yapmak yerine eğer mevcutsa, diğer sütunlara göre sıralama yapılmasını da sağlayabiliriz.</p>

<p>Örnek olarak isimler ve yaşları içeren bir şablon kullanabiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ahmet 21
mehmet 44
Ayse 24
adnan 43
Nil 20
naz 29
</code></pre></div></div>

<p>Eğer seçenek kullanmadan yalnızca <code class="language-plaintext highlighter-rouge">sort</code> komutunu kullanırsak, en baştaki karakterlere göre sıralanacak.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">sort </span>veri                      
adnan 43
ahmet 21
Ayse 24
mehmet 44
naz 29
Nil 20
</code></pre></div></div>

<p>Bakın çıktılar ilk sütundaki ilk karakterlere göre sıralandı.</p>

<p>Şimdi <code class="language-plaintext highlighter-rouge">sort</code> komutuna yalnızca <strong>2. sütuna</strong> bakarak sıralama yapmasını söyleyelim. Bunun için “<code class="language-plaintext highlighter-rouge">k</code>” seçeneğini kullanabiliyoruz. Hangi sütuna göre sıralanacağını belirtmek için “<code class="language-plaintext highlighter-rouge">k</code>” seçeneğinden sonra sütun sayısını girmemiz gerekiyor. Ben <strong>2. sütuna</strong> göre sıralanmasını ve matematiksel büyüklüğe göre sıralanmasını istediğim için komutumu <code class="language-plaintext highlighter-rouge">sort -nk 2 dosya adı</code> şeklinde giriyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">sort</span> <span class="nt">-nk</span> 2 veri                      
Nil 20
ahmet 21
Ayse 24
naz 29
adnan 43
mehmet 44
</code></pre></div></div>

<p>Gördüğünüz gibi girmiş olduğum “<code class="language-plaintext highlighter-rouge">k</code>” seçeneği sayesinde bu kez <strong>2. sütuna</strong> yani yaş sayılarına göre sıralama yapıldı. İşte sizler de içerisinde birden fazla sütun bulunan bu gibi dosyaların, hangi sütunlarına göre sıralanması gerektiğini “<code class="language-plaintext highlighter-rouge">k</code>” seçeneği ile özellikle belirtebilirsiniz.</p>

<h2 id="yalnızca-benzersiz-olanları-bastırmak">Yalnızca Benzersiz Olanları Bastırmak</h2>

<p>Eğer <code class="language-plaintext highlighter-rouge">sort</code> komutuna verilen girdide birbirini tekrar eden satırlar varsa bunları teke indirebiliriz. <code class="language-plaintext highlighter-rouge">sort</code> komutunda bu filtrelemeyi uygulamak için İngilizce “<strong>u</strong>nique” yani “benzersiz” ifadesinin kısaltması olan “<code class="language-plaintext highlighter-rouge">u</code>” seçeneğini kullanabiliyoruz.</p>

<p>Ben denemek için basit bir isim soyisim listesi kullanacağım.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Ahmet Yılmaz
Ayşe Demir
Cemal Özkan
Mustafa Öztürk
Fatma Kaya
Ali Can
Zeynep Aksoy
Hasan Şahin
Ahmet Şen
Emine Akgün
Mustafa Aydın
Hatice Türkmen
İbrahim Karaca
Esra Özdemir
Melek Akyüz
Murat Çelik
Seda Kaya
Cemal Özkan
Hatice Yıldız
Ahmet Şen
Leyla Koçak
Mustafa Yılmaz
Melek Akyüz
</code></pre></div></div>

<p>Bakın burada isim kısmı aynı olan satırlar ve isim soy isim aynı olan satırlar var. sort -u komutunu çalıştırıp nasıl bir çıktı elde edeceğimize bakalım.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">sort</span> <span class="nt">-u</span> liste                        
Ahmet Şen
Ahmet Yılmaz
Ali Can
Ayşe Demir
Cemal Özkan
Emine Akgün
Esra Özdemir
Fatma Kaya
Hasan Şahin
Hatice Türkmen
Hatice Yıldız
İbrahim Karaca
Leyla Koçak
Melek Akyüz
Murat Çelik
Mustafa Aydın
Mustafa Öztürk
Mustafa Yılmaz
Seda Kaya
Zeynep Aksoy
</code></pre></div></div>

<p>Bakın isimler kısmı aynı olmasına rağmen satırlar basıldı. Fakat birebir aynı olan satırlar yani isim ve soy isimin aynı olduğu satırlardan yalnızca bir tanesi basıldı. Gördüğünüz gibi bu şekilde birebir tekrar eden satırları <code class="language-plaintext highlighter-rouge">u</code> seçeneği ile tek bir satır basılacak şekilde sıralayabiliyoruz.</p>

<p><code class="language-plaintext highlighter-rouge">sort</code> komutunun tüm seçenekleri benim bahsettiklerimle sınırlı da değil. Burada ele aldıklarımız dışında <code class="language-plaintext highlighter-rouge">sort</code> komutunun birkaç özelliği daha bulunuyor. Ancak ben geri kalan özelliklerden, başka araçları kullanarak da faydalanabileceğimizi bildiğim için <code class="language-plaintext highlighter-rouge">sort</code> komutunu için bu kadarlık bilginin yeterli olduğunu düşünüyorum. Merak ediyorsanız <code class="language-plaintext highlighter-rouge">sort —help</code> komutunun çıktılarına göz atabilirsiniz.</p>

<h1 id="shuf">shuf</h1>

<p><code class="language-plaintext highlighter-rouge">shuf</code> aracının ismi İngilizce “<strong>shuf</strong>fle” yani “karıştırmak” ifadesinden geliyor.</p>

<p><code class="language-plaintext highlighter-rouge">shuf</code> aracı sayesinde mevcut satırların rastgele olacak şekilde karıştırılmasını sağlayabiliyoruz. Ben örnek olması için <code class="language-plaintext highlighter-rouge">echo -e “\n”{1..10} &gt; liste1</code> komutu ile 1’den 10’a kadar alt alta sayıları dosyaya kaydediyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="o">{</span>1..10<span class="o">}</span> <span class="o">&gt;</span> liste1

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat </span>liste1         
1 
2 
3 
4 
5 
6 
7 
8 
9 
10
</code></pre></div></div>

<p>Eğer ben bu dosyamın satır sıralamalarını karıştırmak istersem <code class="language-plaintext highlighter-rouge">shuf</code> komutunu kullanabilirim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">shuf </span>liste1                          
6 
1 
7 
9 
3 
2 
8 
5 
4 
10
</code></pre></div></div>

<p>Bakın bu kez rastgele sıralanmış şekilde satırlar bastırıldı. Komutumuzu her kullandığımızda, gördüğünüz gibi satırların sıralaması rastgele olacak şekilde karıştırılıyor.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">shuf </span>liste1                          
1 
8 
5 
6 
10
7 
4 
3 
2 
9
</code></pre></div></div>

<p>Tabii ki biz özellikle yönlendirme yapmadığımız sürece buradaki karıştırma işlemi kaynak dosyayı etkilemiyor. <code class="language-plaintext highlighter-rouge">shuf</code> komutu kaynak dosyadan okuyup karıştırdığı satırları konsolumuza bastırıyor. Yani orijinal dosyada bir değişiklik olmuyor. Teyit etmek için tekrar cat komutu ile “<strong><em>liste1</em></strong>” dosyamızı okuyabiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat </span>liste1         
1 
2 
3 
4 
5 
6 
7 
8 
9 
10
</code></pre></div></div>

<p>Bakın dosyanın içeriğinde herhangi bir değişiklik olmamış. Çünkü dediğim gibi <code class="language-plaintext highlighter-rouge">shuf</code> komutu yalnızca okuduğu satırları rastgele karıştırıp standart çıktıya yönlendiriyor. Eğer biz bu karışık listeyi bir dosyaya kaydetmek istersek, yönlendirme operatörü ile istediğimiz bir dosyaya yönlendirebiliriz. Ben bunun için komutun sonuna <code class="language-plaintext highlighter-rouge">&gt; karisik.txt</code> şeklinde ekliyorum ve <code class="language-plaintext highlighter-rouge">paste</code> komutu ile de orijinal ile karışık olanları yan yana bastırıyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">shuf </span>liste1 <span class="o">&gt;</span> karisik.txt
┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">paste </span>liste1 karisik.txt             
        3 
1       8 
2       5 
3       9 
4       10
5       6 
6       7 
7       2 
8 
9       4 
10      1
</code></pre></div></div>

<p>Bakın kaynak dosyada hiç bir değişiklik yok ve yönlendirme operatörü sayesinde standart çıktıyı yönlendirdiğimiz “<strong><em>karisik.txt</em></strong>” dosyasının içeriği de istediğimiz gibi karışık satırlardan oluşuyor.</p>

<p>Bu basit kullanım dışında eğer isterseniz tüm satırlar yerine belirli sayıda satırların bastırılmasını da sağlayabilirsiniz. Örneğin ben 10 satırdan oluşan bu listenin karıştırılıp, yalnızca 3 satırın bana çıktı olarak verilmesini istiyorum. Bunun için “<code class="language-plaintext highlighter-rouge">n</code>” seçeneğinin ardından istediğim satır sayısını yazmam yeterli. Yani komutumuzu <code class="language-plaintext highlighter-rouge">shuf -n 3 liste1</code> şeklinde girebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">shuf</span> <span class="nt">-n</span> 3 liste1
8 
9 
2
</code></pre></div></div>

<p>Bakın rastgele 3 satır bastırıldı. Komutumu tekrar tekrar girdiğimizde, yalnızca 3 satır olacak şekilde rastgele satırların bastırıldığını görebiliyoruz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">shuf</span> <span class="nt">-n</span> 3 liste1                     
5 
1 
10
</code></pre></div></div>

<p>Neticede artık elinizdeki verileri karıştırmak istediğinizde <code class="language-plaintext highlighter-rouge">shuf</code> aracını nasıl kullanabileceğinizi biliyorsunuz. <code class="language-plaintext highlighter-rouge">shuf</code> aracının diğer seçeneklerini merak ediyorsanız <code class="language-plaintext highlighter-rouge">shuf —help</code> komutu ile yardım bilgisine göz atıp, kendiniz keşfedebilirsiniz.</p>

<h1 id="nl-komutu">nl Komutu</h1>

<p>Eğer satırların başına satır numaralarını eklemek istersek “<strong>n</strong>umbering <strong>l</strong>ine” yani “satır numaralandırma” ifadesinin kısalmasından gelen <code class="language-plaintext highlighter-rouge">nl</code> komutunu kullanabiliyoruz. Özellikle çok fazla verinin tek bir satıra sığdırıldığı yoğun içerikli dosyalarda içeriği daha rahat okuyabilmek için numaralandırma bize kolaylık sunabiliyor.</p>

<p>Ben denemek için daha önce oluşturmuş olduğum içerisinde isimler bulunan “<strong><em>liste</em></strong>” isimli dosyasını kullanacağım. Satırları numaralamak için <code class="language-plaintext highlighter-rouge">nl liste</code> şeklinde dosyamızın ismini argüman olarak verebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">nl </span>liste                             
     1  Ahmet Yılmaz
     2  Ayşe Demir
     3  Cemal Özkan
     4  Mustafa Öztürk
     5  Fatma Kaya
     6  Ali Can
     7  Zeynep Aksoy
     8  Hasan Şahin
     9  Ahmet Şen
    10  Emine Akgün
    11  Mustafa Aydın
    12  Hatice Türkmen
    13  İbrahim Karaca
    14  Esra Özdemir
    15  Melek Akyüz
    16  Murat Çelik
    17  Seda Kaya
    18  Cemal Özkan
    19  Hatice Yıldız
    20  Ahmet Şen
    21  Leyla Koçak
    22  Mustafa Yılmaz
    23  Melek Akyüz
    24  MELEK AKYÜZ
    25  mustafa Yılmaz
</code></pre></div></div>

<p>Bakın sırasıyla tüm satırların başında numara bulunuyor.</p>

<p>Ayrıca mesela eğer birden fazla dosyayı argüman olarak girersek, girdiğimiz argüman sıralamasına göre bu dosya içerikleri birleştirilip o şekilde numaralandırılıyor. Ben denemek için <code class="language-plaintext highlighter-rouge">nl liste harf</code> şeklinde iki tane dosya ismini giriyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">nl </span>liste harf                        
     1  Ahmet Yılmaz
     2  Ayşe Demir
     3  Cemal Özkan
     4  Mustafa Öztürk
     5  Fatma Kaya
     6  Ali Can
     7  Zeynep Aksoy
     8  Hasan Şahin
     9  Ahmet Şen
    10  Emine Akgün
    11  Mustafa Aydın
    12  Hatice Türkmen
    13  İbrahim Karaca
    14  Esra Özdemir
    15  Melek Akyüz
    16  Murat Çelik
    17  Seda Kaya
    18  Cemal Özkan
    19  Hatice Yıldız
    20  Ahmet Şen
    21  Leyla Koçak
    22  Mustafa Yılmaz
    23  Melek Akyüz
    24  MELEK AKYÜZ
    25  mustafa Yılmaz
    26  a
    27  g
    28  F
    29  z
    30  D
    31  g
    32  O
    33  p
    34  l
    35  k
    36  S
    37  C
    38  E
    39  n
    40  M
    41  h
    42  t
    43  N
</code></pre></div></div>

<p>Bakın öncelikle “<strong><em>liste</em></strong>” dosyasının içeriği daha sonra “<strong><em>harf</em></strong>” dosyasının içeriği birleştirilmiş ve birleşik şekilde bu satırlar numaralandırılmış. İşte <code class="language-plaintext highlighter-rouge">nl</code> aracını kullanarak satırları numaralandırmak bu kadar kolay.</p>

<p><code class="language-plaintext highlighter-rouge">nl</code> komutunun da tıpkı diğer pek çok araç gibi elbette birden fazla ek seçeneği bulunuyor. Eğer <code class="language-plaintext highlighter-rouge">nl —help</code> komutunu kullanırsak, seçenekleri görebiliriz. Ancak açıkçası ben bu kadar seçenekle şu an ilgilenmiyorum. İleride gerekirse tekrar dönüp bakabilirim, yardım sayfaları bunun için var.</p>

<p>Ayrıca ben <code class="language-plaintext highlighter-rouge">nl</code> aracından özellikle bahsettim fakat aslında benim ihtiyacımı <code class="language-plaintext highlighter-rouge">cat</code> komutunun “<code class="language-plaintext highlighter-rouge">n</code>” seçeneği de yeterince iyi görüyor. Örneğin aynı dosyayı <code class="language-plaintext highlighter-rouge">cat -n</code> seçeneği ile de numaralandırabilirim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat</span> <span class="nt">-n</span> liste
     1  Ahmet Yılmaz                                             
     2  Ayşe Demir                                               
     3  Cemal Özkan                                              
     4  Mustafa Öztürk                                           
     5  Fatma Kaya                                               
     6  Ali Can                                                  
     7  Zeynep Aksoy                                             
     8  Hasan Şahin                                              
     9  Ahmet Şen                                                
    10  Emine Akgün                                              
    11  Mustafa Aydın                                                    
    12  Hatice Türkmen                                                   
    13  İbrahim Karaca                                                   
    14  Esra Özdemir                                                               
    15  Melek Akyüz                                                                
    16  Murat Çelik                                                                
    17  Seda Kaya                                                                        
    18  Cemal Özkan                                                                      
    19  Hatice Yıldız                                                                           
    20  Ahmet Şen                                                                               
    21  Leyla Koçak                                                                             
    22  Mustafa Yılmaz                                                                          
    23  Melek Akyüz                                                                                     
    24  MELEK AKYÜZ                                                                                              
    25  mustafa Yılmaz
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]                                                                                                           
└─<span class="nv">$ </span><span class="nb">cat</span> <span class="nt">-n</span> liste harf
     1  Ahmet Yılmaz                                                                                                         
     2  Ayşe Demir                                                                                                           
     3  Cemal Özkan                                                                                                          
     4  Mustafa Öztürk                                                                                                       
     5  Fatma Kaya                                                                                                           
     6  Ali Can                                                                                                                           
     7  Zeynep Aksoy                                                                                                                      
     8  Hasan Şahin                                                                                                                       
     9  Ahmet Şen
    10  Emine Akgün
    11  Mustafa Aydın
    12  Hatice Türkmen
    13  İbrahim Karaca
    14  Esra Özdemir
    15  Melek Akyüz
    16  Murat Çelik
    17  Seda Kaya
    18  Cemal Özkan
    19  Hatice Yıldız
    20  Ahmet Şen
    21  Leyla Koçak
    22  Mustafa Yılmaz
    23  Melek Akyüz
    24  MELEK AKYÜZ
    25  mustafa Yılmaz
    26  a
    27  g
    28  F
    29  z
    30  D
    31  g
    32  O
    33  p
    34  l
    35  k
    36  S
    37  C
    38  E
    39  n
    40  M
    41  h
    42  t
    43  N
</code></pre></div></div>

<p>Peki madem <code class="language-plaintext highlighter-rouge">cat</code> komutu ile aynı işi yapabiliyoruz neden ek olarak <code class="language-plaintext highlighter-rouge">nl</code> komutunu ele aldık?</p>

<p><code class="language-plaintext highlighter-rouge">nl</code> komutunu ele aldım, çünkü kullanımı ile sık karşılaşabilirsiniz. <code class="language-plaintext highlighter-rouge">nl</code> komutunu sunduğu ek özellikler için özellikle kabuk programlamada sıklıkla tercih ediliyor. Ben sadece sık kullanıldığı için <code class="language-plaintext highlighter-rouge">nl</code> komutundan da haberdar olmanızı istedim. Hangi iş için hangi komutu kullanacağınız tamamen sizin alışkanlıklarınıza bağlı. Aklınıza ilk <code class="language-plaintext highlighter-rouge">nl</code> komutu geliyorsa, bu aracı kullanabilirsiniz. Pek çok farklı aracın benzer özellikler için farklı seçenek tanımları bulunduğu için aslında <code class="language-plaintext highlighter-rouge">nl</code> gibi spesifik olarak tek bir işi yapan aracı bilmek bir avantaj. Zaten <code class="language-plaintext highlighter-rouge">nl</code> aracının ismi ana işlevini çağrıştırdığı için hatırlaması çok kolay. Bu sayede aynı özellik için farklı araçların farklı seçeneklerini hatırlamak yerine tek bir aracı hatırlayıp o iş için bu aracı kullanabiliyoruz. Elinizdeki verileri numaralandırmak mı istiyorsunuz, <code class="language-plaintext highlighter-rouge">nl</code> aracını kullanabilirsiniz.</p>

<h1 id="wc-komutu">wc komutu</h1>

<p><code class="language-plaintext highlighter-rouge">wc</code> aracı en temel haliyle kelimeleri saymamızı sağlayan işlevsel bir araçtır. <code class="language-plaintext highlighter-rouge">wc</code> komutunun ismi de “<strong>w</strong>ord <strong>c</strong>ount” yani “kelime sayma” ifadesinin kısaltmasından geliyor. Ben kelime dedim ama yalnızca kelimeleri değil, karakterleri, satırları ve ayrıca baytları saymak için de kullanabiliyoruz. Eğer  ek bir seçenek olmadan <code class="language-plaintext highlighter-rouge">wc</code> aracına okuması gereken dosyayı argüman olarak verirsek, sırasıyla kaç satır, kelime ve karakter olduğunu ve okunan dosyanın ismini bastırıyor. Ben denemek isimleri ve soyisimleri içeren dosyam üzerinde kullanıyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">wc </span>liste
 25  50 333 liste
</code></pre></div></div>

<p>Buradaki ilk sayı dosya içeriğinin kaç satır olduğunu, ortadaki sayı toplam kaç kelime olduğunu ve son sayı ise toplam kaç karakter olduğunu bildiriyor.</p>

<p>İstersek bu çıktıların hepsini almak yerine yalnızca ihtiyacımız olan çıktıları da bastırabiliriz. Örneğin ben yalnızca satırların basılmasını istersem İngilizce “<strong>l</strong>ines” yani “satırlar” ifadesinin kısaltması olan “<code class="language-plaintext highlighter-rouge">l</code>” seçeneğini kullanabilirim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">wc</span> <span class="nt">-l</span> liste                                                                                                                           
25 liste
</code></pre></div></div>

<p>Bakın bu kez yalnızca kaç satır olduğunu öğrendik. Bu arada dosya içeriğinde boş satırlar olduğunda bu satırların da sayıldığını da farkında olun.</p>

<p>Satır sayısı yerine kelime sayısını öğrenmek için de yine İngilizce karşılığı “<strong>w</strong>ord” yani “kelime” olan “<code class="language-plaintext highlighter-rouge">w</code>” seçeneğini kullanabiliyoruz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">wc</span> <span class="nt">-w</span> liste                                                                                                                          
50 liste
</code></pre></div></div>

<p>Bakın bu sefer de yalnızca kelime sayısı bastırıldı.</p>

<p>Yalnızca karakter sayısını öğrenmek istersek, c seçeneğini kullanabiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">wc</span> <span class="nt">-c</span> liste                                                                                                                          
333 liste
</code></pre></div></div>

<p>Bakın yalnızca bayt sayısı da bastırmayı başardık.</p>

<p>Ayrıca tüm seçenekleri tek tek kullanabileceğimiz gibi elbette aynı anda da kullanabiliriz. Ancak dikkat etmeniz gereken detay, alacağınız çıktıların komutun en başında bahsettiğimiz standart sıralamasında olacağıdır. Yani seçenekleri hangi sıralamada vermiş olursak olalım, aldığımız çıktılar, soldan sağa doğru; satır, kelime, karakter sayısı ve dosya adı şeklinde olacak. Denemek için ben <code class="language-plaintext highlighter-rouge">wc -wl liste</code> şeklinde yani kelimelerin ve satırların hesaplanacağı şekilde komutumu giriyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">wc</span> <span class="nt">-wl</span> liste                                                                                                                         
 25  50 liste
</code></pre></div></div>

<p>Şimdi birde seçeneklerin sıralamasını değiştirip tekrar girmeyi deneyelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">wc</span> <span class="nt">-lw</span> liste                                                                                                                         
 25  50 liste
</code></pre></div></div>

<p>Bakın iki çıktıdaki sayıların sıralaması da aynı. Yani bizim verdiğimiz seçenek sıralamasının <code class="language-plaintext highlighter-rouge">wc</code> komutu için bir önemi yok. Her koşulda, çıktılar kendi standartlarında, varsa satır daha sonra kelime sayısı ve son olarak karakter sayısını verecek şekilde oluyor oluyor.</p>

<p>Bu çıktı sıralamasını aklınızda tutamıyorsanız sorun yok. Çünkü <code class="language-plaintext highlighter-rouge">man wc</code> komutunu kullanıp, komut açıklamasındaki sıralama tanımına bakabilirsiniz. Ayrıca ben şimdiye kadar hep karakter uzunluğu dedim ama aslında kast ettiğim karakterlerin bayt uzunluğuydu. Zaten manual sayfalarında da bu sebeple “byte” şeklinde yazıyor.  İyi ki yardım sayfaları var, haksız mıyım ?</p>

<p>Ayrıca ben şimdiye kadar hep tekil dosyalar üzerinden örnek verim fakat istersek birden fazla dosya ismi de belirtebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">wc</span> <span class="nt">-lw</span> liste harf                                                                                                                     
 25  50 liste
 17  18 harf
 42  68 total
</code></pre></div></div>

<p>Bakın ayrı ayrı ve toplam şekilde tüm sonuçlar konsola bastırıldı. Bu şekilde ister tek isterseniz de birden fazla dosyanın istatistiklerini kontrol edebilirsiniz.</p>

<p>Ben şimdi daha fazla araçtan bahsetmeden önce pipe yapısından bahsedip, araçlar arasında nasıl veri yönlendirmesi yapabileceğimizi ele almak istiyorum.</p>

<p></p>
          <div align="center" class="custom-control custom-switch">
                
            <input type="checkbox" class="custom-control-input" id="readCheckbox"  onchange="markAsRead()">
            <label class="custom-control-label" for="readCheckbox">Okundu Olarak İşaretle  </label>
          </div>
          <p></p>
          <div align="center">
            <button id="linkedinShareButton" class="mavi btn btn-outline-primary">
              <svg width="24px" height="24px" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" fill="none"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"><path fill="#0A66C2" d="M12.225 12.225h-1.778V9.44c0-.664-.012-1.519-.925-1.519-.926 0-1.068.724-1.068 1.47v2.834H6.676V6.498h1.707v.783h.024c.348-.594.996-.95 1.684-.925 1.802 0 2.135 1.185 2.135 2.728l-.001 3.14zM4.67 5.715a1.037 1.037 0 01-1.032-1.031c0-.566.466-1.032 1.032-1.032.566 0 1.031.466 1.032 1.032 0 .566-.466 1.032-1.032 1.032zm.889 6.51h-1.78V6.498h1.78v5.727zM13.11 2H2.885A.88.88 0 002 2.866v10.268a.88.88 0 00.885.866h10.226a.882.882 0 00.889-.866V2.865a.88.88 0 00-.889-.864z"></path></g></svg>
              Paylaş
            </button>
            <button id="twitterShareButton" class="mavi btn btn-outline-primary">
              <svg width="24px" height="24px" viewBox="0 -4 48 48" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000000"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <title>Twitter-color</title> <desc>Created with Sketch.</desc> <defs> </defs> <g id="Icons" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"> <g id="Color-" transform="translate(-300.000000, -164.000000)" fill="#00AAEC"> <path d="M348,168.735283 C346.236309,169.538462 344.337383,170.081618 342.345483,170.324305 C344.379644,169.076201 345.940482,167.097147 346.675823,164.739617 C344.771263,165.895269 342.666667,166.736006 340.418384,167.18671 C338.626519,165.224991 336.065504,164 333.231203,164 C327.796443,164 323.387216,168.521488 323.387216,174.097508 C323.387216,174.88913 323.471738,175.657638 323.640782,176.397255 C315.456242,175.975442 308.201444,171.959552 303.341433,165.843265 C302.493397,167.339834 302.008804,169.076201 302.008804,170.925244 C302.008804,174.426869 303.747139,177.518238 306.389857,179.329722 C304.778306,179.280607 303.256911,178.821235 301.9271,178.070061 L301.9271,178.194294 C301.9271,183.08848 305.322064,187.17082 309.8299,188.095341 C309.004402,188.33225 308.133826,188.450704 307.235077,188.450704 C306.601162,188.450704 305.981335,188.390033 305.381229,188.271578 C306.634971,192.28169 310.269414,195.2026 314.580032,195.280607 C311.210424,197.99061 306.961789,199.605634 302.349709,199.605634 C301.555203,199.605634 300.769149,199.559408 300,199.466956 C304.358514,202.327194 309.53689,204 315.095615,204 C333.211481,204 343.114633,188.615385 343.114633,175.270495 C343.114633,174.831347 343.106181,174.392199 343.089276,173.961719 C345.013559,172.537378 346.684275,170.760563 348,168.735283" id="Twitter"> </path> </g> </g> </g></svg>
              Paylaş
            </button>
            <p></p>
            <h5>📮 Hata, eksik ve öneri bildirimlerinizi <a href="https://superua1.github.io//bildirim.html">buradan</a> iletebilirsiniz. </h5>
          </div>

        <p></p>



  

  

  

  

  

  

  

  

  

  
    
    
    
    


<div data-pagefind-ignore="all" class="row mb-2">
  
      
    <div class="col-md-6">
      <div class="no-gutters border rounded overflow-hidden flex-md-row mb-4 shadow-sm h-md-250 position-relative">
        <div class="col p-4 d-flex flex-column position-static">
          <div class="row">
            <div align="left" class="align-self-center col-2">
              <svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 320 512">
                <!--! Font Awesome icon code -->
                <path d="M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l192 192c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L77.3 256 246.6 86.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-192 192z" fill="currentColor"/>
              </svg>
            </div>
            <div align="right" class="col-10">
              <div class="mb-1 text-muted"><strong>Önceki</strong></div>
              <p class="card-text">Kabuk Genişletmeleri</p>
            </div>
          </div>
          <a href="https://superua1.github.io//egitim/kabuk-genisletmeleri/" title="Kabuk Genişletmeleri" class="stretched-link"></a>
        </div>
      </div>
    </div>
  

  
      
    <div class="col-md-6">
      <div class="no-gutters border rounded overflow-hidden flex-md-row mb-4 shadow-sm h-md-250 position-relative">
        <div class="col p-4 d-flex flex-column position-static">
          <div class="row">
            <div align="left" class="col-10">
              <div class="mb-1 text-muted"><strong>Sonraki</strong></div>
              <p class="card-text">Metinleri Filtrelemek</p>
            </div>
            <div align="right" class="align-self-center col-2">
              <svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 320 512">
                <!--! Font Awesome icon code -->
                <path d="M310.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-192 192c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L242.7 256 73.4 86.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l192 192z" fill="currentColor"/>
              </svg>
            </div>
          </div>
          <a href="https://superua1.github.io//egitim/metinleri-filtrelemek/" title="Metinleri Filtrelemek" class="stretched-link"></a>
        </div>
      </div>
    </div>
  
</div>


      </div>

      <div class="col-md-3">
        <p></p>
        <div class="no-gutters border rounded overflow-hidden flex-md-row mb-4 shadow-sm h-md-250 position-relative">
          <h3 align="center" class="mavi">Sayfa İçeriği</h3>
          <div data-pagefind-subpage>
            <ul id="toc" class="section-nav">
<li class="toc-entry <hh1"><a href="#her-şey-bir-dosyadır--her-şey-bir-bayt-akışıdır">Her Şey Bir Dosyadır | Her Şey Bir Bayt Akışıdır</a></li>
<li class="toc-entry <hh1"><a href="#yönlendirmeler">Yönlendirmeler</a>
<ul>
<li class="toc-entry <hh2"><a href="#hatasız-çıktıları-yönlendirmek--standart-output">Hatasız Çıktıları Yönlendirmek | Standart Output</a></li>
<li class="toc-entry <hh2"><a href="#hatalı-çıktıları-yönlendirmek--standart-error">Hatalı Çıktıları Yönlendirmek | Standart Error</a></li>
<li class="toc-entry <hh2"><a href="#üzerine-yazma--tek-büyüktür-operatörü-">Üzerine Yazma | Tek Büyüktür Operatörü &gt;</a></li>
<li class="toc-entry <hh2"><a href="#ekleme--çift-büyüktür-operatörü-">Ekleme | Çift Büyüktür Operatörü &gt;&gt;</a></li>
<li class="toc-entry <hh2"><a href="#veri-girişi--standart-input">Veri Girişi | Standart Input</a></li>
</ul>
</li>
<li class="toc-entry <hh1"><a href="#cat-komutu">cat Komutu</a></li>
<li class="toc-entry <hh1"><a href="#tac-komutu">tac Komutu</a></li>
<li class="toc-entry <hh1"><a href="#rev-komutu">rev Komutu</a></li>
<li class="toc-entry <hh1"><a href="#touch-komutu">touch Komutu</a></li>
<li class="toc-entry <hh1"><a href="#echo-komutu">echo Komutu</a></li>
<li class="toc-entry <hh1"><a href="#paste-komutu">paste Komutu</a></li>
<li class="toc-entry <hh1"><a href="#sort-komutu">sort Komutu</a>
<ul>
<li class="toc-entry <hh2"><a href="#sıralamayı-tersine-çevirmek">Sıralamayı Tersine Çevirmek</a></li>
<li class="toc-entry <hh2"><a href="#sütunlar-özel-sıralama">Sütunlar Özel Sıralama</a></li>
<li class="toc-entry <hh2"><a href="#yalnızca-benzersiz-olanları-bastırmak">Yalnızca Benzersiz Olanları Bastırmak</a></li>
</ul>
</li>
<li class="toc-entry <hh1"><a href="#shuf">shuf</a></li>
<li class="toc-entry <hh1"><a href="#nl-komutu">nl Komutu</a></li>
<li class="toc-entry <hh1"><a href="#wc-komutu">wc komutu</a></li>
</ul>
          </div>
        </div>
        <p></p>

	  
	  
      <div class="no-gutters border rounded overflow-hidden flex-md-row mb-4 shadow-sm h-md-250 position-relative">
        <div class="col p-4 d-flex flex-column position-static">
			<p align="center" class="mavi text-primary">Video Eğitim</p>
		<img src="https://superua1.github.io//video-egitim.png"/>
          <p class="card-text mb-auto">Buradaki anlatımları, video eğitim üzerinden takip etmek ve gerektiğinde soru sorabilmek isterseniz kursa gözatın.</p>
         <a href="https://www.udemy.com/course/kali-linux-ile-sifirdan-temel-linux-egitimi/?referralCode=04ABD09E6ED5DA93F7A2" class=" stretched-link"></a>
        </div>
        </div>
  
        <p></p>

	  
	  
      <div class="no-gutters border rounded overflow-hidden flex-md-row mb-4 shadow-sm h-md-250 position-relative">
        <div class="col p-4 d-flex flex-column position-static">
			<p align="center" class="kirmizi text-danger">Kitap</p>
		<img src="https://superua1.github.io//kitap.png"/>
          <p class="card-text mb-auto">Linux sistem yönetimine giriş için kitap arıyorsnız gözatın.</p>
         <a href="https://www.udemy.com/course/kali-linux-ile-sifirdan-temel-linux-egitimi/?referralCode=04ABD09E6ED5DA93F7A2" class=" stretched-link"></a>
        </div>
        </div>
  
      </div>
	  
    </div>
</div>
  
  <hr>

<footer class="container py-5">
  <div class="row">
    <div class="col-6 col-md">
 <h5><a href="/">Linux Dersleri</a> | <a target="_blank" href="https://github.com/Linux-Dersleri/linux-dersleri.github.io"><i class="fa fa-github fa-lg"></i></a></h5>
 <p class="small">GNU/Linux için Türkçe içerik sağlamak üzere kurulmuş bir platformdur.</p>
	 
	  
    </div>
    <div class="col-6 col-md">
      <h5>Eğitim Serileri</h5>
      <ul class="list-unstyled text-small">
        <li><a class="text-muted" href="#">Sıralı Doküman</a></li>
        <li><a class="text-muted" href="#">Video Eğitim</a></li>
      </ul>
    </div>
    
  
    <div class="col-6 col-md">
      <h5>Hakkında</h5>
      <ul class="list-unstyled text-small">
        <li><a class="text-muted" href="https://superua1.github.io//sıkca-sorulan-sorular.html">S.S.S.</a></li>
        <li><a class="text-muted" href="https://superua1.github.io//gizlilik.html">Veri Politikası</a></li>
        <li><a class="text-muted" href="https://superua1.github.io//bildirim.html">Geri Bildirim</a></li>
		<li><a class="text-muted" href="mailto: info@linuxdersleri.net">İletişim</a></li>
      </ul>
    </div>
	<div class="col-6 col-md">
      <h5>Android Uygulaması</h5>
      <ul class="list-unstyled text-small">
        <a href='https://play.google.com/store/apps/details?id=com.bildik.linuxdersleri&pcampaignid=pcampaignidMKT-Other-global-all-co-prtnr-py-PartBadge-Mar2515-1'><img style="width: 75%;" alt='Google Play'den alın' src='https://play.google.com/intl/en_us/badges/static/images/badges/tr_badge_web_generic.png'/></a>
	  </ul>
	  
    </div>
  </div>
</footer>


<script src="https://superua1.github.io//assets/js/jquery-3.3.1.slim.min.js"></script>
<script src="https://superua1.github.io//assets/js/script.js"></script>		
<script src="https://superua1.github.io//assets/js/bootstrap.min.js"></script>

<script>
    // Twitter share button functionality
    var twitterShareButton = document.getElementById("twitterShareButton");
        twitterShareButton.addEventListener("click", function() {
          var tweetText = " #Linux Dersleri platformundaki \"Metinsel Verileri İşlemek\" içeriğini faydalı bulduğum için paylaşmak istedim. https://superua1.github.io//egitim/metinsel-verileri-islemek/";
          var tweetUrl = "https://twitter.com/intent/tweet?text=" + encodeURIComponent(tweetText);
          window.open(tweetUrl, "_blank");
        });
  
        // LinkedIn share button functionality
        var linkedinShareButton = document.getElementById("linkedinShareButton");
        linkedinShareButton.addEventListener("click", function() {
          var postUrl = "https://www.linkedin.com/sharing/share-offsite/?mini=true&url=https://superua1.github.io//egitim/metinsel-verileri-islemek/&title=Metinsel Verileri İşlemek&summary=\"Metinsel Verileri İşlemek\" içeriğini faydalı bulduğum için paylaşmak istedim.";
          window.open(postUrl, "_blank");
        });
        </script>
<script src="https://superua1.github.io//assets/js/read.js"></script>
<script src="https://superua1.github.io//assets/js/zooming.min.js"></script>
<script>
   // Listen to images after DOM content is fully loaded
   document.addEventListener('DOMContentLoaded', function () {
        new Zooming({
          // options...
        }).listen('.img-zoomable')
      })
</script>
</body>

</html>
