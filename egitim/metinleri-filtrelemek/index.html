<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="utf-8">
<link rel="icon" href="/logo.svg" type="image/svg+xml" />
<title>Linux Dersleri | Metinleri Filtrelemek &#8211; Linux Eğitimi</title>
<meta name="description" content="Metinler üzerinde çalışmak için gerekli olan yaklaşımları ve araçları tanıyoruz.">
<meta name="keywords" content="pipe, xargs, grep, regex, find, locate, cut, tr, sed, awk, more, less, head, tail">








<link rel="canonical" href="https://superua1.github.io//egitim/metinleri-filtrelemek/">
<link href="https://superua1.github.io//feed.xml" type="application/atom+xml" rel="alternate" title="Linux Eğitimi Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="https://superua1.github.io//assets/css/font-awesome.min.css">
<link rel="stylesheet" href="https://superua1.github.io//assets/css/bootstrap.min.css">
<link rel="stylesheet" href="https://superua1.github.io//assets/css/style.css">


<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="https://superua1.github.io//favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="https://superua1.github.io//favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="https://superua1.github.io//images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="https://superua1.github.io//images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="https://superua1.github.io//images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://superua1.github.io//images/apple-touch-icon-144x144-precomposed.png">

<link rel="stylesheet" href="https://superua1.github.io//assets/css/read.css">
<style>
 .grid {
        column-count: 2;
        column-gap: 1rem;
      }

  </style>
</head>
<body>

<div class="bs-canvas-overlay bs-canvas-anim bg-dark position-fixed w-100 h-100"></div>
<nav class="navbar x-navbar sticky-top navbar-expand-lg navbar-light bg-light border-bottom">
	
  <div class="collapse navbar-collapse">
    <a class="navbar-brand active" href="https://superua1.github.io//">
      <img src="https://superua1.github.io//logo.svg" width="30" height="30" class="align-top" alt="">
      Linux Dersleri
    </a>
    <ul class="navbar-nav">
      <li class="nav-item active">
        <a class="nav-link" href="https://superua1.github.io//egitim.html">Eğitimler</a>
      </li>
      <li class="nav-item active">
        <a class="nav-link" href="https://superua1.github.io//blog/">Blog</a>
      </li>
	  <li class="nav-item active">
        <a class="nav-link" href="https://superua1.github.io//komutlar">Komut Listesi</a>
      </li>
	  <li class="nav-item active">
        <a class="nav-link" href="https://superua1.github.io//test">Test</a>
      </li>
      <li class="nav-item active">
        <a class="nav-link" href="https://superua1.github.io//etiketler">Etiketler</a>
      </li>
	 <li class="nav-item active">
        <a class="nav-link" href="https://superua1.github.io//hakkında.html">Hakkında</a>
      </li>
    </ul>
	
  </div>
 
<a class="btn" data-toggle="modal" data-target="#searchModal"><i class="fa fa-search" style="width:16px;height:16px"></i></a>
	<a onclick="tema()" class="btn" ><i class="fa fa-adjust fa-lg"></i></a> 
	<a href="https://superua1.github.io//bildirim.html" class="btn" ><i class="fa fa-paper-plane"></i></a> 
</nav>	
<nav class="navbar y-navbar sticky-top navbar-expand-lg navbar-light bg-light border-bottom">
<button class="btn"  data-toggle="canvas" data-target="#bs-canvas-left" aria-expanded="false" aria-controls="bs-canvas-left"><i class="fa fa-align-justify fa-lg"></i></button>
		<a href="https://superua1.github.io//" class="btn"  ><i class="fa fa-home fa-lg"></i></a>     
	<a class="btn" data-toggle="modal" data-target="#searchModal"><i class="fa fa-search" style="width:16px;height:16px"></i></a>
		
		<a onclick="tema()" class="btn" ><i class="fa fa-adjust fa-lg"></i></a> 
		<a href="https://superua1.github.io//bildirim.html" class="btn" ><i class="fa fa-paper-plane"></i></a> 
		
</nav>

<div style="background-color: var(--background);" id="bs-canvas-left" class="bs-canvas bs-canvas-anim bs-canvas-left position-fixed h-100" >
   <div class="container">
    
      <a class="btn bs-canvas-close close" aria-label="Close">
        <span aria-hidden="true">&times;</span>
      </a>
      <a class="navbar-brand" href="https://superua1.github.io//">
        <img src="https://superua1.github.io//logo.svg" width="30" height="30" class="align-top" alt="">
        Linux Dersleri
      </a>
  
    
    
   <hr>
 <a data-toggle="modal" data-target="#searchModal" class="btn">🕵️ Arama</a>
  <a href="https://superua1.github.io//egitim" class="btn">🎓 Eğitimler</a>
  <a href="https://superua1.github.io//blog" class="btn">🗃️ Blog</a>
  <a href="https://superua1.github.io//komutlar" class="btn">📜 Komut Listesi</a>
  <a href="https://superua1.github.io//test" class="btn">🎯 Test</a>
  <a href="https://superua1.github.io//etiketler" class="btn">🏷️ Etiketler</a>
  <a href="https://superua1.github.io//hakkında.html" class="btn">🐧 Hakkında</a>
 
  <a href="https://superua1.github.io//bildirim.html" class="btn">📮 Geri Bildirim</a>
  <hr>
  
  <div align="center">
  <h5>Android Uygulaması</h5>
      <ul class="list-unstyled text-small">
        <a href="https://play.google.com/store/apps/details?id=com.bildik.linuxdersleri&amp;pcampaignid=pcampaignidMKT-Other-global-all-co-prtnr-py-PartBadge-Mar2515-1"><img style="width: 75%;" alt="Google Play" den="" alın'="" src="https://play.google.com/intl/en_us/badges/static/images/badges/tr_badge_web_generic.png"></a>
	  </ul>
	  <hr>
 <h5><a href="/">Linux Dersleri</a> | <a target="_blank" href="https://github.com/Linux-Dersleri/linux-dersleri.github.io"><i class="fa fa-github fa-lg"></i></a></h5>
 <p class="small">GNU/Linux için Türkçe içerik sağlamak üzere kurulmuş bir platformdur.</p>

	  </div>
    
</div>

</div>



<!-- Modal -->
<div class="modal fade" id="searchModal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
  <div class="modal-dialog" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="searchModalLabel">🕵️ Site Geneli Arama:</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <link href="https://superua1.github.io//pagefind/pagefind-ui.css" rel="stylesheet">
<script src="https://superua1.github.io//pagefind/pagefind-ui.js" type="text/javascript"></script>

<div id="search"></div>
<script>

    window.addEventListener('DOMContentLoaded', (event) => {
        new PagefindUI({ element: "#search", showImages: false });
		
    });
	
</script>
      </div>

    </div>
  </div>
</div>

<script src="https://superua1.github.io//assets/js/jquery-3.3.1.slim.min.js" type="text/javascript"></script>
<div id="progress-bar-container">
  <div id="progress-bar"></div>
</div>
      <div class="container-fluid">
  <div class="row mb-2">
      <div style="font-size: 18px;" class="col-md-9" data-pagefind-filter="Bölüm:Eğitim Serisi:">
        	<h1 align="center">10. Ders: Metinleri Filtrelemek</h1> 
<div align="center"><i class="fa fa-tags" aria-hidden="true"></i>
          <a href="https://superua1.github.io//etiketler.html#pipe" class="btn btn-outline-primary btn-sm" title="Pages tagged pipe">pipe</a> <a href="https://superua1.github.io//etiketler.html#xargs" class="btn btn-outline-primary btn-sm" title="Pages tagged xargs">xargs</a> <a href="https://superua1.github.io//etiketler.html#grep" class="btn btn-outline-primary btn-sm" title="Pages tagged grep">grep</a> <a href="https://superua1.github.io//etiketler.html#regex" class="btn btn-outline-primary btn-sm" title="Pages tagged regex">regex</a> <a href="https://superua1.github.io//etiketler.html#find" class="btn btn-outline-primary btn-sm" title="Pages tagged find">find</a> <a href="https://superua1.github.io//etiketler.html#locate" class="btn btn-outline-primary btn-sm" title="Pages tagged locate">locate</a> <a href="https://superua1.github.io//etiketler.html#cut" class="btn btn-outline-primary btn-sm" title="Pages tagged cut">cut</a> <a href="https://superua1.github.io//etiketler.html#tr" class="btn btn-outline-primary btn-sm" title="Pages tagged tr">tr</a> <a href="https://superua1.github.io//etiketler.html#sed" class="btn btn-outline-primary btn-sm" title="Pages tagged sed">sed</a> <a href="https://superua1.github.io//etiketler.html#awk" class="btn btn-outline-primary btn-sm" title="Pages tagged awk">awk</a> <a href="https://superua1.github.io//etiketler.html#more" class="btn btn-outline-primary btn-sm" title="Pages tagged more">more</a> <a href="https://superua1.github.io//etiketler.html#less" class="btn btn-outline-primary btn-sm" title="Pages tagged less">less</a> <a href="https://superua1.github.io//etiketler.html#head" class="btn btn-outline-primary btn-sm" title="Pages tagged head">head</a> <a href="https://superua1.github.io//etiketler.html#tail" class="btn btn-outline-primary btn-sm" title="Pages tagged tail">tail</a>   
		 <p></p> 
		  <div align="center" class="col-sm-3">
		<img class="responsive" src="https://superua1.github.io//egitim/metinfiltrecover.png" alt="">
		  </div>	</div>	  

		  <hr>	
		  <h6 align="right" id="meta-da">
			<i class="fa fa-clock-o" aria-hidden="true"></i>

114 dk.


		   

  <i class="fa fa-user" aria-hidden="true"></i><a href="https://superua1.github.io//hakkında.html"> Taylan Özgür Bildik</a>


		  
		  </h6>  
		  
		  
        <h1 id="pipe-hakkında">pipe Hakkında</h1>

<p>Şimdiye kadar sistem üzerindeki yapıların dosya olarak ele alındığından ve dolayısıyla dosya içeriklerini yani baytları istediğimiz gibi manipüle edilip yönlendirebilmenin neden çok önemli olduğundan pek çok kez söz ettik. Yani her şeyin aslında bir bayt akışı olduğunu vurguladık hep. Vurgulamaya da devam edeceğiz. Özetle sistemi komut satırı üzerinden yöneten kişi olarak bizim işimiz gücümüz hep bayt akışlarını kontrol etmek.</p>

<p>Şimdiye kadarki anlatımlarımızda dosya içeriklerinde birtakım değişiklikler yapabileceğimiz bazı araçları tanıdık. Başka araçlardan da bahsedeceğiz ancak devam etmeden önce birden fazla aracı birbirine bağlayarak çalıştırmamıza yardımcı olan “<strong>pipe</strong>” yani “boru” mekanizmasından bahsetmem gerekiyor.</p>

<p>Yönlendirme işlemleri sırasında girdileri ve çıktıları istediğimiz şekilde nasıl aktarabileceğimizi öğrendik. Sizlerin de bildiği üzere yönlendirme sırasında bir aracın çıktıları bir dosyaya veya bir dosyadaki verileri de bir araca girdi olarak aktarabiliyoruz.</p>

<p>Pipe yapısına ihtiyaç duymamızdaki en temel iki sebep; hızlı çalışması ve aynı anda paralel şekilde işlemler arasında aktarım yapılabilmesi.</p>

<p>Burada bahsi geçen pipe mekanizmasını dik çizgi <code class="language-plaintext highlighter-rouge">|</code> operatörü sayesinde kullanabiliyoruz. Pipe mekanizmasında, bu dik çizgi işaretinden önceki komutun çıktıları üretildikleri sıralamaya uygun şekilde bu çizgiden sonraki komuta girdi olarak aktarılıyor.</p>

<p>Yani veriler, ilk işlemin ürettiği sıraya uygun şekilde tek yönlü olarak bir sonraki işleme aktarılıyor. Daha iyi anlamak adına çalışma yapısına daha yakından bakalım.</p>

<p>Basit bir örnek üzerinden gidecek olursak; Diyelim ki ben <code class="language-plaintext highlighter-rouge">find</code> komutu ile /etc dizinini altında sonu “<strong><em>.sh</em></strong>” uzantısıyla biten dosyaları araştırmak, bulunan dosyaları isimlerine göre alfanümerik olarak sıralamak ve daha sonra numaralandırmak istiyorum. Bu işi yapacak <strong>tek bir araç</strong> var mı varsa da hangi seçenekleri kullanmalıyım tam olarak bilmiyorum. Ancak her birini yapan ayrı ayrı üç araç biliyorum. <code class="language-plaintext highlighter-rouge">find</code> <code class="language-plaintext highlighter-rouge">sort</code> ve <code class="language-plaintext highlighter-rouge">nl</code> araçları ilk aklıma gelenler. Sizin şu anda <code class="language-plaintext highlighter-rouge">find</code> aracını bilmediğinizin farkındayım, ancak merak etmeyin ileride bu aracımızı da ayrıca ele alacağız. Şimdi pipe yapısının çalışma mekanizmasını ele alabilmek için vereceğim örneğe odaklanmanız yeterli. Neticede ihtiyacım olan sonuca ulaşabilmek için bu üç aracı bir arada kullanabilirim.</p>

<p>Öncelikle sonu “<strong><em>.sh</em></strong>” uzantısı ile biten dosyaların bulunabilmesi için <code class="language-plaintext highlighter-rouge">find /etc -name *.sh -type f</code> komutunu giriyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>find /etc/ <span class="nt">-name</span> <span class="s2">"*.sh"</span> <span class="nt">-type</span> f                             
/etc/init.d/keyboard-setup.sh
/etc/init.d/hwclock.sh
/etc/init.d/console-setup.sh
find: ‘/etc/ipsec.d/private’: Permission denied
find: ‘/etc/vpnc’: Permission denied
/etc/wpa_supplicant/functions.sh
/etc/wpa_supplicant/action_wpa.sh
/etc/wpa_supplicant/ifupdown.sh
/etc/macchanger/ifupdown.sh
/etc/xdg/plasma-workspace/env/taylan-themes.sh
find: ‘/etc/ssl/private’: Permission denied
/etc/profile.d/gawk.sh
/etc/profile.d/taylan.sh
/etc/profile.d/dotnet-cli-tools-bin-path.sh
/etc/profile.d/vte-2.91.sh
/etc/profile.d/bash_completion.sh
/etc/console-setup/cached_setup_terminal.sh
/etc/console-setup/cached_setup_keyboard.sh
/etc/console-setup/cached_setup_font.sh
find: ‘/etc/polkit-1/localauthority’: Permission denied
</code></pre></div></div>

<p>Bakın “<strong><em>/etc</em></strong>” dizini altında dosya ismi “<strong><em>.sh</em></strong>” ile biten tüm dosyalar listelenmiş oldu. Hatta daha temiz bir çıktı almak istersek, yetki hatalarını “<strong><em>/dev/null</em></strong>” dosyası aracılığı ile yok edebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>find /etc/ <span class="nt">-name</span> <span class="s2">"*.sh"</span> <span class="nt">-type</span> f 2&gt;/dev/null                 
/etc/init.d/keyboard-setup.sh
/etc/init.d/hwclock.sh
/etc/init.d/console-setup.sh
/etc/wpa_supplicant/functions.sh
/etc/wpa_supplicant/action_wpa.sh
/etc/wpa_supplicant/ifupdown.sh
/etc/macchanger/ifupdown.sh
/etc/xdg/plasma-workspace/env/taylan-themes.sh
/etc/profile.d/gawk.sh
/etc/profile.d/taylan.sh
/etc/profile.d/dotnet-cli-tools-bin-path.sh
/etc/profile.d/vte-2.91.sh
/etc/profile.d/bash_completion.sh
/etc/console-setup/cached_setup_terminal.sh
/etc/console-setup/cached_setup_keyboard.sh
/etc/console-setup/cached_setup_font.sh
</code></pre></div></div>

<p>Şimdi bu çıktıları alfabetik olarak sıralamak istediğim için <code class="language-plaintext highlighter-rouge">sort</code> aracına aktarmam gerekiyor. Aktarmak için pipe kullanabilirim. Pipe çubuk <code class="language-plaintext highlighter-rouge">|</code> simgesi ile kullanılıyor.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>find /etc/ <span class="nt">-name</span> <span class="s2">"*.sh"</span> <span class="nt">-type</span> f 2&gt;/dev/null | <span class="nb">sort</span>
/etc/console-setup/cached_setup_font.sh
/etc/console-setup/cached_setup_keyboard.sh
/etc/console-setup/cached_setup_terminal.sh
/etc/init.d/console-setup.sh
/etc/init.d/hwclock.sh
/etc/init.d/keyboard-setup.sh
/etc/macchanger/ifupdown.sh
/etc/profile.d/bash_completion.sh
/etc/profile.d/dotnet-cli-tools-bin-path.sh
/etc/profile.d/gawk.sh
/etc/profile.d/taylan.sh
/etc/profile.d/vte-2.91.sh
/etc/wpa_supplicant/action_wpa.sh
/etc/wpa_supplicant/functions.sh
/etc/wpa_supplicant/ifupdown.sh
/etc/xdg/plasma-workspace/env/taylan-themes.sh
</code></pre></div></div>

<p>Bakın <code class="language-plaintext highlighter-rouge">find</code> aracının üretmiş olduğu çıktılar <code class="language-plaintext highlighter-rouge">sort</code> aracına aktarılıp <code class="language-plaintext highlighter-rouge">sort</code> aracının sıralama yapıp sonuçlarını konsola yönlendirmesi ile sonuçlanmış oldu. Sıralama işleminden sonra da, sıralanmış çıktıları numaralandırmak için de <code class="language-plaintext highlighter-rouge">sort</code> aracının çıktılarını <code class="language-plaintext highlighter-rouge">nl</code> aracına aktarabilirim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>find /etc/ <span class="nt">-name</span> <span class="s2">"*.sh"</span> <span class="nt">-type</span> f 2&gt;/dev/null | <span class="nb">sort</span> | <span class="nb">nl      
     </span>1  /etc/console-setup/cached_setup_font.sh
     2  /etc/console-setup/cached_setup_keyboard.sh
     3  /etc/console-setup/cached_setup_terminal.sh
     4  /etc/init.d/console-setup.sh
     5  /etc/init.d/hwclock.sh
     6  /etc/init.d/keyboard-setup.sh
     7  /etc/macchanger/ifupdown.sh
     8  /etc/profile.d/bash_completion.sh
     9  /etc/profile.d/dotnet-cli-tools-bin-path.sh
    10  /etc/profile.d/gawk.sh
    11  /etc/profile.d/taylan.sh
    12  /etc/profile.d/vte-2.91.sh
    13  /etc/wpa_supplicant/action_wpa.sh
    14  /etc/wpa_supplicant/functions.sh
    15  /etc/wpa_supplicant/ifupdown.sh
    16  /etc/xdg/plasma-workspace/env/taylan-themes.sh
</code></pre></div></div>

<p>Neticede gördüğünüz gibi tam olarak istediğim işlevi yerine getirmek için birden fazla aracı pipe ile birbirine bağlamış oldum.</p>

<p>Peki bu çıktıyı tam olarak nasıl elde ettik yani pipe tam olarak nasıl çalışıyor ?</p>

<p>Bizim girdiğimiz komutta bulunan üç farklı araç aynı anda üç ayrı işlem olarak başlatıldı. İlk aracın standart çıktısı ikinci aracın standart girdisine bağlandı. İkinci aracın standart çıktısı da üçüncü aracın standart girdisine bağlandı. Üçüncüsü de özellikle başka bir yere yönlendirilmediği için çıktılarını konsola(<strong><em>/dev/tty</em></strong> olarak temsil edildi) bastırmış oldu.</p>

<p><img src="https://superua1.github.io//egitim/metin/9.png" alt="9.png" class="responsive img-zoomable" /></p>

<p>Elbette bu işlemi her bir komutun çıktılarını bir dosyaya aktarıp ilgili dosyadan diğer araçların verileri okumasını sağlayarak da yapabilirdik fakat bu komutu yazmak hem daha uğraştırıcı olacaktı hem de araçlarımız pipe kullanımına oranla daha verimsiz çalışacaktı. Hemen bu durumu gözlemleyelim.</p>

<p>Aynı işlemi bu kez dosyalara yönlendirme ile deneyelim. Öncelikle komutu yazalım, daha sonra açıklayacağım.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>find /etc/ <span class="nt">-name</span> <span class="s2">"*.sh"</span> <span class="nt">-type</span> f 2&gt; /dev/null <span class="o">&gt;</span> bul <span class="p">;</span> <span class="nb">sort</span> &lt; bul <span class="o">&gt;</span> sırala <span class="p">;</span> <span class="nb">nl</span> &lt; sırala
     1  /etc/console-setup/cached_setup_font.sh
     2  /etc/console-setup/cached_setup_keyboard.sh
     3  /etc/console-setup/cached_setup_terminal.sh
     4  /etc/init.d/console-setup.sh
     5  /etc/init.d/hwclock.sh
     6  /etc/init.d/keyboard-setup.sh
     7  /etc/macchanger/ifupdown.sh
     8  /etc/profile.d/bash_completion.sh
     9  /etc/profile.d/dotnet-cli-tools-bin-path.sh
    10  /etc/profile.d/gawk.sh
    11  /etc/profile.d/taylan.sh
    12  /etc/profile.d/vte-2.91.sh
    13  /etc/wpa_supplicant/action_wpa.sh
    14  /etc/wpa_supplicant/functions.sh
    15  /etc/wpa_supplicant/ifupdown.sh
    16  /etc/xdg/plasma-workspace/env/taylan-themes.sh
</code></pre></div></div>

<p>Bu girdiğimiz komutta önce <code class="language-plaintext highlighter-rouge">find</code> komutu çalıştırılacak ve işini tamamladığında çıktılarını “<strong><em>bul</em></strong>” isimli dosyaya aktaracak. Daha sonra <code class="language-plaintext highlighter-rouge">sort</code> komutu “<strong><em>bul</em></strong>” isimli dosyayı okuyacak ve içeriğindeki verileri sıraladıktan sonra “<strong><em>sırala</em></strong>” isimli dosyaya aktaracak. En son <code class="language-plaintext highlighter-rouge">nl</code> komutu “<strong><em>sırala</em></strong>” isimli dosyadaki içeriği okuyup numaralandıracak ve çıktısını konsolumuza basacak. İşte girdiğimiz komutun çalışma yapısı tam olarak bu. Komutların arasında girmiş olduğumuz noktalı virgül karakterleri tek satırda belirtmiş olduğumuz bu komutların sırasıyla çalıştırılmasını sağlıyor. İleride bu konudan da ayrıca bahsedeceğiz.</p>

<p><img src="https://superua1.github.io//egitim/metin/10.png" alt="10.png" class="responsive img-zoomable" /></p>

<p>Bakın pipe yerine kullandığımız bu yönlendirme alternatifini yazması ve açıklaması dahi uzun sürdü.</p>

<p>Çalışma hızı ise pipe’a oranla daha yavaş olacak çünkü bu kullanımda komutlar sırasıyla tek tek ve disk üzerindeki dosyalara veri yazıp okuyarak çalıştırılıyor. Dolayısıyla soldan sağa doğru bir komut çalışmasını tamamlamadan, bir sonraki komut çalıştırılmıyor. Ve disk üzerinde okuma yazma yapıldığı için disk hızına bağlı bir çalışma hızı söz konusu.</p>

<p>Pipe kullanımında ise tüm komutlar ayrı işlem olarak aynı anda paralel şekilde çalıştırılıyor. Her bir aracın ürettiği çıktı da üretilir üretilmez boru hattındaki diğer işlemlere disk üzerine veri yazılıp okunmasına gerek kalmadan sanal dosya sistemi(bellek üzerinden) aktarıldığı için veriler çok daha hızlı işlenmiş oluyor. Bir komut çıktı üretir üretmez, çıktının üretilme sıralaması korunarak bir sonraki işlem aktarıyor, bu sayede tüm veriler sırasıyla işlenmiş oluyor. Tabii ki bizim örneğimizde ilk aracın ürettiği çıktıların hepsinin alındıktan sonra sıralaması gerektiği için <code class="language-plaintext highlighter-rouge">sort</code> aracı <code class="language-plaintext highlighter-rouge">find</code> aracının çıktılarını bitirmesini bekledi aslında. Yani araçlar paralel çalışıyor olsalar da çıktıların gönderilme ve okunma durumlarına bağlı olarak birbirlerini de bekleyebiliyorlar. Yine de pipe mekanizması disk üzerindeki dosyalara okuma yazma yapmadığı ve araçları paralel olarak aynı anda çalıştırabildiği için çok daha verimli bir yaklaşım. Üstelik basit örnek üzerinden de görebildiğiniz gibi birden fazla aracı birbirine bağlayacak çalıştırmak istediğimizde pipe ile komut girmek çok da daha kolay ve kısa.</p>

<p>Ayrıca örnek üzerinde peşi sıra pipe kullandığımız bu komutun bütününe de “<strong>pipeline</strong>” yani “boru hattı” deniyor. Neticede birden fazla pipe yani boru kullanarak ikiden fazla aracı birbirine bağladığımız için boru hattı oluşturmuş oluyoruz.</p>

<p>Tıpkı buradaki örneğimizde olduğu gibi ihtiyacımıza yönelik spesifik çözüm için bildiğimiz birden fazla aracın basit özelliklerini pipe yardımıyla bir arada kullanabiliyoruz. Bu yaklaşım sayesinde pek çok işlevi olan tek bir karmaşık araç yerine, basit işlevleri olan pek çok aracı farklı kombinasyonlar ile birlikte kullanıp sınırsız çeşitlilikte çözüm üretebiliyoruz. Zaten zaman içinde pipe yapısını ister istemez ne kadar sık kullandığınıza bizzat şahit olacaksınız.</p>

<h1 id="xargs-komutu">xargs Komutu</h1>

<p>Pipe yapısından bahsederken, pipe’ın önceki işlemden gelen standart çıktıları sonraki işleme standart girdi olarak aktardığını söylemiştim. Eğer pipe ile veri yönlendirmek istediğiniz araç yalnızca argüman alarak çalışıyorsa yani standart girdiden veri kabul etmiyorsa tabii ki ilgili veriler araç tarafından alınıp işlenmiyor. Dolayısıyla pipeline olarak ifade ettiğimiz boru hattı tıkanmış oluyor.</p>

<p>İşte bu duruma çözüm olarak da <code class="language-plaintext highlighter-rouge">xargs</code> isimli aracı kullanabiliyoruz.</p>

<p><code class="language-plaintext highlighter-rouge">xargs</code> aracı, standart girdiden okuduğu verileri kendisinden sonraki komutun argümanı olarak iletebiliyor. Bu sayede standart girdiden veri kabul etmeyen araçları, tıpkı biz elle o araca argümanlar girmişiz gibi çalıştırabiliyoruz. <code class="language-plaintext highlighter-rouge">xargs</code> aracının isminin açılımı da zaten “e<strong>X</strong>tended <strong>ARG</strong>ument<strong>S</strong>” yani “genişletilmiş argümanlar” ifadesinden geliyor.</p>

<p>Bu aracın çok fazla seçeneği var ama şimdilik temel kullanımı hakkında bilgi sahibi olmamız yeterli.</p>

<p>Ben çok basit bir örnek vermek istiyorum. Bunun için öncelikle içerisinde veri bulunan dosyamı oluşturmak üzere <code class="language-plaintext highlighter-rouge">echo “dosya1 dosya2 dosya3” &gt; oku-beni</code> şeklinde komutumu giriyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"dosya1 dosya2 dosys3"</span> <span class="o">&gt;</span> oku-beni

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat </span>oku-beni 
dosya1 dosya2 dosys3
</code></pre></div></div>

<p>Bakın buraya yazmış olduğum ifadeler dosyama kaydolmuş. Şimdi ben bu dosyada geçen ifadelerin kullanılarak yeni dosyalar oluşturulması için <code class="language-plaintext highlighter-rouge">touch</code> aracına bu dosyadan veri yönlendirmek istiyorum.</p>

<p>Bunun için <code class="language-plaintext highlighter-rouge">cat oku-beni</code> komutuyla dosyanın okunup pipe ile bu çıktıların <code class="language-plaintext highlighter-rouge">touch</code> aracına yönlendirilmesini sağlayabiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">cat </span>oku-beni | <span class="nb">touch
touch</span>: missing file operand
Try <span class="s1">'touch --help'</span> <span class="k">for </span>more information.

</code></pre></div></div>

<p>Gördüğünüz gibi <code class="language-plaintext highlighter-rouge">touch</code> komutu oluşturulacak dosya isimleri argüman olarak iletilmediği için hata verdi. Bu hatanın argüman eksikliğinden kaynaklandığını teyit etmek istersek tekrar yalnızca <code class="language-plaintext highlighter-rouge">touch</code> komutunu girebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">touch
touch</span>: missing file operand
Try <span class="s1">'touch --help'</span> <span class="k">for </span>more information.
</code></pre></div></div>

<p>Bakın yine aynı hatayı aldık çünkü <code class="language-plaintext highlighter-rouge">touch</code> aracına herhangi bir dosya ismini argüman olarak iletmedik.</p>

<p><code class="language-plaintext highlighter-rouge">touch</code> aracı yalnızca kendisine argüman olarak iletilen verileri işleyip standart girdiden veri okumadığı için pipe ile ilettiğimiz “<strong><em>oku-beni”</em></strong> dosyasının içeriği <code class="language-plaintext highlighter-rouge">touch</code> aracı tarafından işlenmedi. Bu durumda bu çıktıları önce <code class="language-plaintext highlighter-rouge">xargs</code> aracına yönlendirip oradan da <code class="language-plaintext highlighter-rouge">touch</code> aracına argüman olarak iletilmelerini sağlayabiliriz. Ben bunun için komutumu bu kez <code class="language-plaintext highlighter-rouge">cat oku-beni | xargs touch</code> şeklinde yazıyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/klasor]
└─<span class="nv">$ </span><span class="nb">cat </span>oku-beni | xargs <span class="nb">touch</span> 

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/klasor]
└─<span class="nv">$ </span><span class="nb">ls                                                           
</span>dosya1  dosya2  dosys3  oku-beni
</code></pre></div></div>

<p>Bakın tam olarak dosyada bulunan veriler ile aynı isimde yeni dosyalar oluşturulmuş. Yani <code class="language-plaintext highlighter-rouge">xargs</code> aracının standart girdiden okuduğu verileri hemen yanındaki komutun argümanı olarak çalıştırdığını bizzat teyit etmiş olduk.</p>

<p><img src="https://superua1.github.io//egitim/metin/11.png" alt="11.png" class="responsive img-zoomable" /></p>

<p><code class="language-plaintext highlighter-rouge">xargs</code> aracı kendisine girdi olarak verilerin tüm verileri standart şekilde boşluklarından parçalara ayırıp bunların her birini hemen yanındaki komuta ayrı ayrı argüman olarak iletiyor. Zaten bu sebeple benim bu dosyada aralarında boşluk bırakarak yazdığım tüm verilerim argüman olarak <code class="language-plaintext highlighter-rouge">touch</code> aracına iletildi.</p>

<p>İşte bu yaklaşım sayesinde standart girdiden veri kabul etmeyen yani yalnızca argüman olarak çalışan araçlara kolaylıkla veri yönlendirmesi yapabiliyoruz. Neticede <code class="language-plaintext highlighter-rouge">xargs</code> aracının en temel kullanımı bu şekilde. Artık en temel kullanım amacını bildiğiniz için geri kalan tüm detaylar için yardım sayfalarına göz atmanız yeterli.</p>

<h1 id="tee">tee</h1>

<p>Biz pipe yapısını kullandığımızda verilerimiz yalnızca tek yönlü şekilde aktarılıyor. Eğer biz hem bir sonraki işleme hem de bir dosyaya aynı verilerin yazılmasını istiyorsak, bu işlem için <code class="language-plaintext highlighter-rouge">tee</code> aracını kullanmamız gerekiyor. Çünkü pipe mekanizması tek başına bunu desteklemiyor.  Pipe mekanizmasını düz boru <code class="language-plaintext highlighter-rouge">|</code> olarak düşünecek olursak buradaki <code class="language-plaintext highlighter-rouge">tee</code> aracı da bildiğiniz <code class="language-plaintext highlighter-rouge">T</code> boru görevi görüyor. İlk işlemden aldığı çıktıyı okuyor, istenilen dosyaya ve aynı zamanda bir sonraki işlemin standart girdisine yönlendiriyor.</p>

<p>Basit bir örnek üzerinden ele alabiliriz. Örneğin  <code class="language-plaintext highlighter-rouge">ls /</code> komutu ile “<strong><em>/</em></strong>” yani ana dizin altındaki dosyaları listeleyecek olursak uzun bir liste alırız.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">ls</span> /                                                         
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var
</code></pre></div></div>

<p>Ben uzun bir liste istemiyorum. Eğer yalnızca ilk 10 satırı listelemek istersem pipe ile verileri <code class="language-plaintext highlighter-rouge">head</code> komutuna aktarabilirim. Buradaki <code class="language-plaintext highlighter-rouge">head</code> aracı, aldığı verilerin yalnızca ilk 10 satını çıktı olarak iletildiği için kullandık. İleride bu araçtan ayrıca bahsediyor olacağız. Şimdi komutumuzu girip deneyelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">ls</span> / | <span class="nb">head
</span>bin
boot
dev
etc
home
initrd.img
initrd.img.old
lib
lib32
lib64
</code></pre></div></div>

<p>Bakın yalnızca ilk 10 içerik listelenmiş oldu. Ben <code class="language-plaintext highlighter-rouge">ls</code> komutunun tüm çıktılarının bir dosyaya kaydedilmesini hem de <code class="language-plaintext highlighter-rouge">head</code> komutu ile yalnızca ilk 10 satırını okumak istiyor da olabilirim. Bunun için <code class="language-plaintext highlighter-rouge">tee</code> komutunu kullanabilirim. Yani komutumuzu <code class="language-plaintext highlighter-rouge">ls / | tee liste.txt | head</code> şeklinde yazabiliriz. Bu komut sayesinde ilk olarak <code class="language-plaintext highlighter-rouge">ls</code> aracı “<strong><em>/</em></strong>” dizini altındaki tüm içeriği listeleyip pipe ile <code class="language-plaintext highlighter-rouge">tee</code> aracına aktaracak. <code class="language-plaintext highlighter-rouge">tee</code> aracı da aldığı çıktıyı “<strong><em>liste.txt</em></strong>” isimlide dosyaya kaydedecek ve ayrıca aynı verileri <code class="language-plaintext highlighter-rouge">head</code> aracına pipe ile yönlendirecek. <code class="language-plaintext highlighter-rouge">head</code> aracı da aldığı verilerden yalnızca ilk 10 satırı konsola çıktı olarak bastıracak.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">ls</span> / | <span class="nb">tee </span>liste.txt | <span class="nb">head                                  
</span>bin
boot
dev
etc
home
initrd.img
initrd.img.old
lib
lib32
lib64
┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="err">$</span>
</code></pre></div></div>

<p>Bakın ilk 10 satır konsola basılmış oldu. Şimdi “<strong><em>liste.txt</em></strong>” dosyasının içeriğine bakalım.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat </span>liste.txt                              
bin
boot
dev
etc
home
initrd.img
initrd.img.old
lib
lib32
lib64
libx32
lost+found
media
mnt
opt
proc
root
run
sbin
srv
sys
tmp
usr
var
vmlinuz
vmlinuz.old
</code></pre></div></div>

<p>Gördüğünüz gibi <code class="language-plaintext highlighter-rouge">ls</code> komutunun tüm çıktıları da bu listeye kaydedilmiş. Yani <code class="language-plaintext highlighter-rouge">tee</code> komutu <code class="language-plaintext highlighter-rouge">ls</code> komutunun çıktılarını hem dosyaya hem de bir sonraki işlem olan <code class="language-plaintext highlighter-rouge">head</code> işlemine iletmiş oldu. Burada fark ettiyseniz <code class="language-plaintext highlighter-rouge">tee</code> aracı kendisine verilen tüm verileri hem dosyaya hem de bir sonraki araca eksiksiz şekilde iletiyor. İşte <code class="language-plaintext highlighter-rouge">tee</code> komutu pipeline üzerinde bu amaçla sıklıkla kullanılıyor.</p>

<p><img src="https://superua1.github.io//egitim/metin/12.png" alt="12.png" class="responsive img-zoomable" /></p>

<p>Mesela <code class="language-plaintext highlighter-rouge">ls / | head | tee liste.txt</code> şeklinde komut girecek olursak size nasıl bir çıktı alırız ? Hemen girip deneyelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">ls</span> / | <span class="nb">head</span> | <span class="nb">tee </span>liste.txt
bin
boot
dev
etc
home
initrd.img
initrd.img.old
lib
lib32
lib64

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat </span>liste.txt                                                
bin
boot
dev
etc
home
initrd.img
initrd.img.old
lib
lib32
lib64

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="err">$</span>
</code></pre></div></div>

<p>Bakın <code class="language-plaintext highlighter-rouge">ls /</code> komutunun çıktıları pipe ile <code class="language-plaintext highlighter-rouge">head</code> aracına iletildi. <code class="language-plaintext highlighter-rouge">head</code> aracı da ilk 10 satırı alıp <code class="language-plaintext highlighter-rouge">tee</code> aracına iletti. <code class="language-plaintext highlighter-rouge">tee</code> aracı da kendisine iletilen bu 10 satırı hem “<strong><em>liste.txt</em></strong>” dosyasına hem de konsola yönlendirdi. Bu sebeple hem konsol çıktısında hem de “<strong><em>liste.txt</em></strong>” dosyasında ilk 10 satırı almış olduk.</p>

<p><img src="https://superua1.github.io//egitim/metin/13.png" alt="13.png" class="responsive img-zoomable" /></p>

<p>Bence buradaki iki örnek <code class="language-plaintext highlighter-rouge">tee</code> aracının nasıl çalıştığını gayet iyi biçimde özetliyor.</p>

<p>Bu temel yaklaşım dışında, birden fazla dosyaya aynı veriyi kaydetmek isterseniz, dosyaların isimlerini argüman olarak vermeniz yeterli. Ben denemek için aynı komutu çağırıp, bir dosya ismi daha belirtiyorum ve komutumu bu şekilde onaylıyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">ls</span> / | <span class="nb">head</span> | <span class="nb">tee </span>liste.txt liste2.txt          
bin
boot
dev
etc
home
initrd.img
initrd.img.old
lib
lib32
lib64
</code></pre></div></div>

<p>Şimdi <code class="language-plaintext highlighter-rouge">paste</code> komutu ile her iki dosyayı da yan yana bastırabiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">paste </span>liste.txt liste2.txt 
bin     bin
boot    boot
dev     dev
etc     etc
home    home
initrd.img      initrd.img
initrd.img.old  initrd.img.old
lib     lib
lib32   lib32
lib64   lib64
</code></pre></div></div>

<p>Gördüğünüz gibi aynı verileri birden fazla dosyaya da yönlendirebiliyoruz.</p>

<p><code class="language-plaintext highlighter-rouge">tee</code> yaklaşımı sayesinde dilersek standart(<code class="language-plaintext highlighter-rouge">&lt;</code> <code class="language-plaintext highlighter-rouge">&gt;</code> <code class="language-plaintext highlighter-rouge">&amp;&gt;</code> vs..) yönlendirmelerin alternatifi olarak, yönlendirmelerin hem konsola hem de dosyalara kaydolmasını da sağlayabiliriz. Normalde sizin de bildiğiniz gibi eğer bir komutun çıktısını bir dosyaya yönlendirirsek konsola bir çıktı basılmaz. Hemen teyit etmek için <code class="language-plaintext highlighter-rouge">ls &gt; liste</code> şeklinde komutumuzu girelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/klasor]
└─<span class="nv">$ </span><span class="nb">ls</span> <span class="o">&gt;</span> liste                                                   

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/klasor]
└─<span class="err">$</span>
</code></pre></div></div>

<p>Bakın <code class="language-plaintext highlighter-rouge">ls</code> komutunun çıktısı konsola basılmadı çünkü <code class="language-plaintext highlighter-rouge">ls</code> komutunun çıktıları belirttiğim dosyaya yönlendirildi. <code class="language-plaintext highlighter-rouge">cat</code> komutu ile de bu durumu teyit edebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/klasor]
└─<span class="nv">$ </span><span class="nb">cat </span>liste                                                    
dosya1
dosya2
dosys3
liste
oku-beni
</code></pre></div></div>

<p>Şimdi aynı örneği <code class="language-plaintext highlighter-rouge">tee</code> komutunu ile tekrarlayalım. <code class="language-plaintext highlighter-rouge">ls | tee liste2</code> şeklinde komutumu giriyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/klasor]
└─<span class="nv">$ </span><span class="nb">ls</span> | <span class="nb">tee </span>liste2                                              
dosya1
dosya2
dosys3
liste
liste2
oku-beni

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/klasor]
└─<span class="nv">$ </span><span class="nb">cat </span>liste2                                                   
dosya1
dosya2
dosys3
liste
liste2
oku-beni
</code></pre></div></div>

<p>Bakın <code class="language-plaintext highlighter-rouge">tee</code> aracı sayesinde <code class="language-plaintext highlighter-rouge">ls</code> komutunun çıktıları konsola bastırılmakla birlikte dosyaya da kaydedilmiş. Eğer ben <code class="language-plaintext highlighter-rouge">tee</code> aracından sonra bir pipe daha kullanıp bir araç ismi yazsaydım <code class="language-plaintext highlighter-rouge">tee</code> aracının elindeki veriler bu araca yönlendirilecekti. Fakat <code class="language-plaintext highlighter-rouge">tee</code> aracından sonra bir araç ismi girmediğim için <code class="language-plaintext highlighter-rouge">tee</code> aracı elindeki verileri dosyaya yazmasının yanı sıra standart çıktı adresi olan konsola da bastırmış oldu.</p>

<p><img src="https://superua1.github.io//egitim/metin/14.png" alt="14.png" class="responsive img-zoomable" /></p>

<p><code class="language-plaintext highlighter-rouge">tee</code> aracının kullanımı gördüğünüz gibi son derece kolay olduğu için daha fazla örneğe gerek yok. Yine de son olarak birkaç kullanım detayını daha bilmenizde fayda var.</p>

<h3 id="üzerine-ekleme">Üzerine Ekleme</h3>

<p>Normalde <code class="language-plaintext highlighter-rouge">tee</code> komutu aynı isimde bir dosya varsa onun üzerine yazar. Yani o dosyanın içeriğini yok edip, elindeki verileri o dosyaya yazar. Eğer aynı isimli dosya varsa dosya içeriğinin sonuna yeni verilerin eklenmesini istersek “<strong>a</strong>ppend” yani “ekleme” ifadesinin kısaltması olan <code class="language-plaintext highlighter-rouge">a</code> seçeneğini kullanabiliriz.</p>

<p>Ben denemek için <code class="language-plaintext highlighter-rouge">echo "deneme" | tee deneme.txt</code> komutunu giriyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/klasor]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"deneme"</span> | <span class="nb">tee </span>deneme.txt                               
deneme

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/klasor]
└─<span class="nv">$ </span><span class="nb">cat </span>deneme.txt                                
deneme
</code></pre></div></div>

<p>Bakın veri kaydolmuş. Şimdi aynı dosyaya bu kez farklı veri göndermek için <code class="language-plaintext highlighter-rouge">echo “test” | tee deneme.txt</code> şeklinde aynı dosyanın ismini de yazıp komutumuzu girelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/klasor]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"test"</span> | <span class="nb">tee </span>deneme.txt                               
<span class="nb">test</span>

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/klasor]
└─<span class="nv">$ </span><span class="nb">cat </span>deneme.txt                                               
<span class="nb">test</span>
</code></pre></div></div>

<p>Bakın dosyanın eski içeriği silinip <code class="language-plaintext highlighter-rouge">tee</code> aracının en son yönlendirdiği veri eklenmiş. Bizzat gördüğümüz gibi <code class="language-plaintext highlighter-rouge">tee</code> aracına özellikle belirtmediğimiz sürece tıpkı tek yönlendirme <code class="language-plaintext highlighter-rouge">&gt;</code> operatörü kullandığımızdaki gibi hedefteki dosya içeriğinin üzerine yazılıyor.</p>

<p>Ben verileri dosyanın sonuna eklemek istediğim için “<strong>a</strong>ppend” yani “ekleme” ifadesinin kısaltmasından gelen <code class="language-plaintext highlighter-rouge">a</code> seçeneği ile komutumu tekrar girmek istiyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/klasor]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"test2"</span> | <span class="nb">tee</span> <span class="nt">-a</span> deneme.txt                             
test2

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/klasor]
└─<span class="nv">$ </span><span class="nb">cat </span>deneme.txt                                               
<span class="nb">test
</span>test2
</code></pre></div></div>

<p>Bakın <code class="language-plaintext highlighter-rouge">tee</code> aracın <code class="language-plaintext highlighter-rouge">echo</code> aracından “<strong>test2</strong>” ifadesini aldığı için bunu konsola bastırdı. Ayrıca <code class="language-plaintext highlighter-rouge">tee</code> aracına <code class="language-plaintext highlighter-rouge">a</code> seçeneğini de eklediğimiz için bu veriyi “<strong><em>deneme.txt</em></strong>” dosyasının sonuna ekliyor. Kısacası tıpkı yönlendirme operatörlerinde bir dosyanın sonuna yeni veri eklemek için çift operatör <code class="language-plaintext highlighter-rouge">&gt;&gt;</code> kullandığımız gibi <code class="language-plaintext highlighter-rouge">tee</code> komutu için de <code class="language-plaintext highlighter-rouge">a</code> seçeneğini kullanmamız gerekiyor. <strong>Aksi halde <code class="language-plaintext highlighter-rouge">tee</code> aracı aynı isimli dosyanın üzerine yeni verileri yazıp eskilerini yok ediyor.</strong></p>

<p>Son olarak hazır <code class="language-plaintext highlighter-rouge">tee</code> komutundan bahsetmişken pratik bir kullanımından da bahsetmek istiyorum. Diyelim ki yetkimiz olmayan bir dosyaya örneğin <strong><em>/etc/apt/sources.list</em></strong> dosyasına ekleme yapmak istiyoruz.</p>

<p>Normalde yetki gerektiren bir görevi yerine getirmek için komutumuzun en başına <code class="language-plaintext highlighter-rouge">sudo</code> ifadesini yazıp eğer yetkimiz uygunsa çalıştırabiliyoruz. Normalde <strong><em>/etc/apt/sources.list</em></strong>  dosyasını düzenlemek için yetkimiz yok fakat en yetkili kullanıcı gibi davranmak için komutumuzun başına <code class="language-plaintext highlighter-rouge">sudo</code> yazı işlemi yerine getirmeyi deneyebiliriz.</p>

<p>Yani örneğin <code class="language-plaintext highlighter-rouge">sudo echo "eklenecek veri" &gt;&gt; /etc/apt/sources.list</code> şeklinde komutumuzu girebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/klasor]
└─<span class="nv">$ </span><span class="nb">sudo echo</span> <span class="s2">"eklenecek veri"</span> <span class="o">&gt;&gt;</span> /etc/apt/sources.list
bash: /etc/apt/sources.list: Permission denied
</code></pre></div></div>

<p>Ancak gördüğünüz gibi yetki hatası aldık. Halbuki ileri de ayrıca ele alacağımız <code class="language-plaintext highlighter-rouge">sudo</code> komutu bizim yetkili şekilde bu dosyaya veri ekleyebilmemizi sağlamalıydı.</p>

<p>Burada <code class="language-plaintext highlighter-rouge">sudo</code> komutu işe yaramadı çünkü <strong>yönlendirmeler üzerinde <code class="language-plaintext highlighter-rouge">sudo</code> komutunun etkisi bulunmuyor</strong>. Yani yönlendirmeyi yine mevcut yetkisiz kullanıcımız yapmış oluyor. Dolayısıyla <code class="language-plaintext highlighter-rouge">sudo</code> komutunu kullansak dahi yönlendirme operatörü ile, ilgili dosyaya veri yazma yetkisi kazanamayız. Fakat bunun yerine <code class="language-plaintext highlighter-rouge">tee</code> komutunu <code class="language-plaintext highlighter-rouge">sudo</code> ile yetkili şekilde çalıştırabiliriz. Hadi hemen deneyelim. Ben <code class="language-plaintext highlighter-rouge">echo "####" | sudo tee -a /etc/apt/sources.list</code> şeklinde komutumu yazıyorum. <strong>Buradaki <code class="language-plaintext highlighter-rouge">a</code> seçeneğini unutmayın aksi halde bu çok önemli dosyasının tüm içeriğinin silinmesine neden olabilirsiniz.</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/klasor]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"####"</span> | <span class="nb">sudo tee</span> <span class="nt">-a</span> /etc/apt/sources.list
<span class="o">[</span><span class="nb">sudo</span><span class="o">]</span> password <span class="k">for </span>taylan:       
yeni satır
</code></pre></div></div>

<p>Ve gördüğünüz gibi parolamızı girip komutu onayladığımızda herhangi bir yetki hatası almıyoruz. <code class="language-plaintext highlighter-rouge">cat</code> komutuyla dosya içeriğine de bakalım.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/klasor]
└─<span class="nv">$ </span><span class="nb">cat</span> /etc/apt/sources.list
<span class="c"># See https://www.taylan.org/docs/general-use/taylan-linux-sources-list-repositories/</span>
deb http://http.taylan.org/taylan taylan-rolling main contrib non-free

<span class="c"># Additional line for source packages</span>
<span class="c"># deb-src http://http.taylan.org/taylan taylan-rolling main contrib non-free</span>
yeni satır
</code></pre></div></div>

<p>Bakın dosyanın en sonuna “<strong>####</strong>” ifadesi eklenmiş.</p>

<p>!!Dikkat: Düzenleme yaptığımız dosya önemli bir konfigürsyon dosyası olduğu için dosya yapısını bozmamak adına yalnızca  “<strong>####</strong>” ifadesini ekledim. Eğer siz farkı bir veri eklerseniz sistemi güncelleme ve paket yükleme noktasında sorunlar yaşayabilirsiniz. Bu sebeple “<strong>#</strong>” hariç bir karakter eklemeyin veya eklediyseniz de <code class="language-plaintext highlighter-rouge">sudo nano /etc/apt/sources.list</code> komutu ile dosyayı açıp ilgili satırı silin ve <kbd>Ctrl</kbd> + <kbd>x</kbd> ile dosyayı kaydedip kapatın.</p>

<p>Böylelikle yönlendirme operatörlerinin <code class="language-plaintext highlighter-rouge">sudo</code> ile yetki kazanamadığından ve alternatif olarak <code class="language-plaintext highlighter-rouge">tee</code> komutu sayesinde yetkili şekilde dosya içeriğine veri yönlendirebileceğimizden de haberdar olduk. Ele aldığımız örnekleri de dikkate aldığımızda <code class="language-plaintext highlighter-rouge">tee</code> aracını tıpkı <code class="language-plaintext highlighter-rouge">T</code> boru gibi düşünmek bence oldukça mantıklı. Konsol üzerinde hem standart çıktıya hem de bir dosyaya yönlendirme yapmak istediğinizde veya bir yönlendirme işlemini yetkili şekilde yapmak istediğinizde <code class="language-plaintext highlighter-rouge">tee</code> aracını kullanabiliyoruz. Mesela ben en son girmiş olduğum komutta konsola çıktı bastırılmadan yalnızca dosyaya veri yönlendirmek isteseydim standart çıktıları <strong><em>/dev/null</em></strong> dizinine de yönlendirebilirdim. Ben denemek için en son komutumu çağırıp bu kez sonuna <code class="language-plaintext highlighter-rouge">&gt; /dev/null</code> şeklinde yazıyorum ve komutumu bu şekilde onaylıyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/klasor]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"####"</span> | <span class="nb">sudo tee</span> <span class="nt">-a</span> /etc/apt/sources.list <span class="o">&gt;</span> /dev/null  

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~/klasor]
└─<span class="nv">$ </span><span class="nb">cat</span> /etc/apt/sources.list                                    
<span class="c"># See https://www.taylan.org/docs/general-use/taylan-linux-sources-list-repositories/</span>
deb http://http.taylan.org/taylan taylan-rolling main contrib non-free

<span class="c"># Additional line for source packages</span>
<span class="c"># deb-src http://http.taylan.org/taylan taylan-rolling main contrib non-free</span>

<span class="c">####</span>
<span class="c">####</span>
</code></pre></div></div>

<p>Bakın konsola herhangi bir çıktı bastırılmadı çünkü standart çıktıyı <strong><em>/dev/null</em></strong> dosyasına yönlendirerek yok etmiş oldum. Siz de bu şekilde pipe üzerinden gelen verileri bir dosyaya yazmak istediğinizde bu yaklaşımı kullanabilirsiniz.</p>

<p>!!Dikkat: Örneklerimiz sırasında kullandığımız bu <strong><em>/etc/apt/sources.list</em></strong> dosyası, sistemin paket yönetimi için önemli bir dosya. O sebeple <code class="language-plaintext highlighter-rouge">sudo nano /etc/apt/sources.list</code> ile bu dosyayı tekrar açıp, eklediğiniz gereksiz verileri silmenizi öneriyorum. Aksi halde paket yönetimi konusunda sorun yaşayabilirsiniz.</p>

<h1 id="grep">grep</h1>

<p><code class="language-plaintext highlighter-rouge">grep</code> aracının ismi “<strong>g</strong>lobal <strong>r</strong>egular <strong>e</strong>xpression <strong>p</strong>rint” ifadesinin kısaltmasından geliyor. Ve tam olarak isminde de olduğu şekilde “regex” sayesinde verileri filtreleme konusunda çok yetenekli bir araç.</p>

<p><code class="language-plaintext highlighter-rouge">grep</code> aracı standart girdiden veya kendisine argüman olarak verilmiş olan dosyadan veri okuyup filtreleyebiliyor. Hemen bizzat görmek için en temel kullanımıyla başlayabiliriz.</p>

<p>Ben denemek için <strong><em>/etc/passwd</em></strong> dosyasında kaç kez “<strong>false</strong>” ifadesinin geçtiğini öğrenmek üzere <code class="language-plaintext highlighter-rouge">grep</code> komutundan sonra araştırmak istediğim kelimeyi ve daha sonra da hangi dosyada araştırılacağını <code class="language-plaintext highlighter-rouge">grep "false" /etc/passwd</code> şeklinde giriyorum.</p>

<p><img src="https://superua1.github.io//egitim/metin/15.png" alt="15.png" class="responsive img-zoomable" /></p>

<p>Bakın içerisinde “<strong>false</strong>” ifadesi bulunan tüm satırlar listelendi. Benzer şekilde aslında standart girdiden alınan veriler de <code class="language-plaintext highlighter-rouge">grep</code> tarafından işlendiği için komutumuzu <code class="language-plaintext highlighter-rouge">cat /etc/passwd | grep false</code> şeklinde de girebilirdik.</p>

<p><img src="https://superua1.github.io//egitim/metin/16.png" alt="16.png" class="responsive img-zoomable" /></p>

<p>Bakın yine aynı sonucu elde ettik çünkü <code class="language-plaintext highlighter-rouge">cat</code> aracı <strong><em>/etc/passwd</em></strong> dosyasının içeriğini pipe ile <code class="language-plaintext highlighter-rouge">grep</code> aracına aktardı, <code class="language-plaintext highlighter-rouge">grep</code> de benim istediğim doğrultusunda içinde “<strong>false</strong>” ifadesi geçen satıları filtreleyip standart çıktıya yani konsola yönlendirdi. İşte <code class="language-plaintext highlighter-rouge">grep</code> aracının en temel kullanımı bu şekilde. İster dosyadan isterseniz de standart girdiden <code class="language-plaintext highlighter-rouge">grep</code> aracına veri yönlendirip verilerin okunmasını sağlayabilirsiniz.</p>

<p>Şimdi ben <code class="language-plaintext highlighter-rouge">grep</code> aracının birkaç farklı kullanım özelliğinden daha bahsetmek istiyorum.</p>

<h2 id="ters-arama--hariç-tutmak">Ters Arama | Hariç Tutmak</h2>

<p>Aradığımız kelime ile eşleşen verileri nasıl filtreleyebileceğimizi ele aldık. Eğer tersi şekilde aradığımız ifadenin geçmediği bölümleri istersek bulun için <code class="language-plaintext highlighter-rouge">grep</code> aracının hariç tutma özelliğini kullanabiliriz. Hariç tutma özelliğini kullanmak için de kısaca <code class="language-plaintext highlighter-rouge">v</code> seçeneğini kullanabiliyoruz.</p>

<p>Yani örneğin ben <strong><em>/etc/passwd</em></strong> dosyasının içinde “false” ifadesinin geçmediği satırları listelemek istersem <code class="language-plaintext highlighter-rouge">grep -v "false" /etc/passwd</code> şeklinde komutumu girebilirim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">grep</span> <span class="nt">-v</span> <span class="s2">"false"</span> /etc/passwd                                                            
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
<span class="nb">sync</span>:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
proxy:x:13:13:proxy:/bin:/usr/sbin/nologin
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
backup:x:34:34:backup:/var/backups:/usr/sbin/nologin
list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin
irc:x:39:39:ircd:/run/ircd:/usr/sbin/nologin
gnats:x:41:41:Gnats Bug-Reporting System <span class="o">(</span>admin<span class="o">)</span>:/var/lib/gnats:/usr/sbin/nologin
nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin
systemd-network:x:100:102:systemd Network Management,,,:/run/systemd:/usr/sbin/nologin
systemd-resolve:x:101:103:systemd Resolver,,,:/run/systemd:/usr/sbin/nologin
_apt:x:102:65534::/nonexistent:/usr/sbin/nologin
strongswan:x:105:65534::/var/lib/strongswan:/usr/sbin/nologin
systemd-timesync:x:106:112:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologin
redsocks:x:107:113::/var/run/redsocks:/usr/sbin/nologin
rwhod:x:108:65534::/var/spool/rwho:/usr/sbin/nologin
iodine:x:109:65534::/run/iodine:/usr/sbin/nologin
messagebus:x:110:114::/nonexistent:/usr/sbin/nologin
miredo:x:111:65534::/var/run/miredo:/usr/sbin/nologin
_rpc:x:112:65534::/run/rpcbind:/usr/sbin/nologin
usbmux:x:113:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin
tcpdump:x:114:120::/nonexistent:/usr/sbin/nologin
rtkit:x:115:121:RealtimeKit,,,:/proc:/usr/sbin/nologin
sshd:x:116:65534::/run/sshd:/usr/sbin/nologin
dnsmasq:x:117:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin
statd:x:118:65534::/var/lib/nfs:/usr/sbin/nologin
avahi:x:119:125:Avahi mDNS daemon,,,:/run/avahi-daemon:/usr/sbin/nologin
nm-openvpn:x:120:126:NetworkManager OpenVPN,,,:/var/lib/openvpn/chroot:/usr/sbin/nologin
stunnel4:x:121:127::/var/run/stunnel4:/usr/sbin/nologin
nm-openconnect:x:122:128:NetworkManager OpenConnect plugin,,,:/var/lib/NetworkManager:/usr/sbin/nologin
sslh:x:125:130::/nonexistent:/usr/sbin/nologin
postgres:x:126:131:PostgreSQL administrator,,,:/var/lib/postgresql:/bin/bash
pulse:x:127:132:PulseAudio daemon,,,:/run/pulse:/usr/sbin/nologin
saned:x:128:135::/var/lib/saned:/usr/sbin/nologin
inetsim:x:129:137::/var/lib/inetsim:/usr/sbin/nologin
colord:x:131:139:colord colour management daemon,,,:/var/lib/colord:/usr/sbin/nologin
geoclue:x:132:140::/var/lib/geoclue:/usr/sbin/nologin
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
taylan:x:1000:1000:taylan,,,:/home/taylan:/usr/bin/bash
</code></pre></div></div>

<p>Bakın “false” ifadesinin geçtiği satırlar hariç tüm içerikler konsola bastırıldı.</p>

<p>Ben yalnızca tek bir dosya üzerinde filtreleme yaptım ancak istersek birden fazla dosyanın tüm içeriğinde de filtreleme yapabiliriz. Ben denemek için <strong><em>/etc/passwd</em></strong> ve <strong><em>/etc/group</em></strong> dosya içeriklerinde “<strong>root</strong>” ifadesinin aranmasını istiyorum. Bunun için <code class="language-plaintext highlighter-rouge">grep “root” /etc/passwd /etc/group</code> şeklinde komutumu giriyorum.</p>

<p><img src="https://superua1.github.io//egitim/metin/17.png" alt="17.png" class="responsive img-zoomable" /></p>

<p>Bakın eşleşmiş olan satırlar hangi dosyada bulundukları da belirtilerek filtrelenmiş oldu. Yani gördüğünüz gibi istersek aynı anda çoklu şekilde dosyalar üzerinde de çalışabiliyoruz. Çoklu dosyalarla çalışmanın yanında dilersek alt dizinlerdekiler de dahil bir dizin içindeki tüm içeriklerin <code class="language-plaintext highlighter-rouge">grep</code> aracı tarafından filtrelenmesini sağlayabiliriz. Bunun için özyineleme yani “<strong>r</strong>ecursive” seçeneğinin kısalması olan <code class="language-plaintext highlighter-rouge">r</code> seçeneğini kullanabiliyoruz.</p>

<h2 id="özyinelemeli-araştırma">Özyinelemeli Araştırma</h2>

<p>Örnek olarak “<strong><em>/etc/</em></strong>” dizini içinde, içinde “bashrc” ifadesi geçen tüm dosyaları filtrelemeyi deneyebiliriz. Bunun için <code class="language-plaintext highlighter-rouge">grep -r “bashrc” /etc/ 2&gt; /dev/null</code> şeklinde komutumu giriyorum. Buradaki <code class="language-plaintext highlighter-rouge">-r</code> seçeneği benim hedef gösterdiğim bu dizinden başlayıp tüm alt dizinler de dahil olmak üzere tüm dosyalarda “test” ifadesinin geçtiği yerleri filtreleyip bana sunacak. Ayrıca yetki gibi nedenlerle oluşacak olan hatalı çıktıları yok etmek için <code class="language-plaintext highlighter-rouge">2&gt; /dev/null</code> komutunu da ekledim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">grep</span> <span class="nt">-r</span> <span class="s2">"bashrc"</span> /etc/ 2&gt; /dev/null
/etc/skel/.bashrc.original:# ~/.bashrc: executed by bash<span class="o">(</span>1<span class="o">)</span> <span class="k">for </span>non-login shells.
/etc/skel/.bashrc.original:# this, <span class="k">if </span>it<span class="s1">'s already enabled in /etc/bash.bashrc and /etc/profile
/etc/skel/.bashrc.original:# sources /etc/bash.bashrc).
/etc/skel/.profile:    # include .bashrc if it exists
/etc/skel/.profile:    if [ -f "$HOME/.bashrc" ]; then
/etc/skel/.profile:     . "$HOME/.bashrc"
/etc/skel/.bashrc:# ~/.bashrc: executed by bash(1) for non-login shells.
/etc/skel/.bashrc:# this, if it'</span>s already enabled <span class="k">in</span> /etc/bash.bashrc and /etc/profile
/etc/skel/.bashrc:# sources /etc/bash.bashrc<span class="o">)</span><span class="nb">.</span>
/etc/apparmor.d/abstractions/bash:  @<span class="o">{</span>HOME<span class="o">}</span>/.bashrc                  r,
/etc/apparmor.d/abstractions/bash:  /etc/bashrc                      r,
/etc/apparmor.d/abstractions/bash:  /etc/bash.bashrc                 r,
/etc/apparmor.d/abstractions/bash:  /etc/bash.bashrc.local           r,
/etc/apparmor.d/abstractions/bash:  <span class="c"># run out of /etc/bash.bashrc</span>
/etc/bash.bashrc:# System-wide .bashrc file <span class="k">for </span>interactive bash<span class="o">(</span>1<span class="o">)</span> shells.
/etc/bash.bashrc.save.1:# System-wide .bashrc file <span class="k">for </span>interactive bash<span class="o">(</span>1<span class="o">)</span> shells.
/etc/bash.bashrc.save:# System-wide .bashrc file <span class="k">for </span>interactive bash<span class="o">(</span>1<span class="o">)</span> shells.
/etc/profile:    <span class="c"># The file bash.bashrc already sets the default PS1.</span>
/etc/profile:    <span class="k">if</span> <span class="o">[</span> <span class="nt">-f</span> /etc/bash.bashrc <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
/etc/profile:      <span class="nb">.</span> /etc/bash.bashrc
</code></pre></div></div>

<p>Bakın sırasıyla tüm dizinlerde gezildi ve “bashrc” ifadesi eşleşen satırlar ilgili dosyanın ismi de başta olacak şekilde bize sunuldu. Bu sayede kapsamlı şekilde istediğimiz spesifik kelime ile eşleşen dosyaları bulmamız mümkün oluyor. Buradaki <code class="language-plaintext highlighter-rouge">r</code> seçeneğinin fonksiyonunu teyit etmek isterseniz <code class="language-plaintext highlighter-rouge">r</code> seçeneği olmadan komutu tekrar girmeyi deneyebilirsiniz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">grep</span> <span class="s2">"bashrc"</span> /etc/
<span class="nb">grep</span>: /etc/: Is a directory
</code></pre></div></div>

<p>Bakın <strong><em>/etc/</em></strong> adresinin bir dizin olduğu, yani dosya olmadığı için “<strong>bashrc</strong>” ifadesi geçen bir eşleşme bulunamayacağı konusunda uyarıldık.  Bu sebeple alt dizinler de dahil, dizin içeriklerinde araştırma yapılabilmesi için “özyinelemeli” araştırma yapmak üzere <code class="language-plaintext highlighter-rouge">r</code> seçeneğini kullanmamız gerek.</p>

<h2 id="yalnızca-dizin-i̇simlerini-bastırmak">Yalnızca Dizin İsimlerini Bastırmak</h2>

<p>Eğer aradığımız ifadeyle eşleşen verilerin tam olarak hangi satırada olduğunu görmek yerine yalnızca dosya isimlerinin bastırılmasını istersek <code class="language-plaintext highlighter-rouge">l</code> seçeneğini de kullanabiliriz. Ben denemek için girmiş olduğum komuta <code class="language-plaintext highlighter-rouge">l</code> seçeneğini ekleyeceğim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">grep</span> <span class="nt">-rl</span> <span class="s2">"bashrc"</span> /etc/ 2&gt; /dev/null
/etc/skel/.bashrc.original
/etc/skel/.profile
/etc/skel/.bashrc
/etc/apparmor.d/abstractions/bash
/etc/bash.bashrc
/etc/bash.bashrc.save.1
/etc/bash.bashrc.save
/etc/profile
</code></pre></div></div>

<p>Bakın bu kez yalnızca içerisinde benim aradığım ifadeyi bulunduran dosyaların isimleri bastırılmış oldu. Çok daha derli toplu bir çıktı elde etmiş olduk.</p>

<p>Şimdi ben <code class="language-plaintext highlighter-rouge">grep</code> aracının diğer özelliklerinden bahsetmek için uzun bir isim listesi kullanmak istiyorum.  Dilerseniz siz de buradan dosyayı indirip, anlatımları bu dosya üzerinden test edebilirsiniz.</p>

<p><a href="https://superua1.github.io//egitim/metin/isimler.txt">isimler.txt</a></p>

<h2 id="tırnak-kullanımı">Tırnak Kullanımı</h2>

<p>Mesela ben isimler.txt dosyasında tam olarak “<strong>ahmet can</strong>” ifadesinin geçtiği satırları aramak istiyorum. Bunun için konsola <code class="language-plaintext highlighter-rouge">grep ahmet can isimler.txt</code> şeklinde komut girmeyi deneyebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">grep </span>ahmet can isimler.txt                                                   
<span class="nb">grep</span>: can: No such file or directory
isimler.txt:ahmet
isimler.txt:ahmet kürşad
isimler.txt:ahmet ali
isimler.txt:kenan ahmet
isimler.txt:ahmet
isimler.txt:ahmet can durmus
isimler.txt:can ahmet furkan
</code></pre></div></div>

<p>Bakın yalnızca başında “<strong>ahmet</strong>” olan satırlar getirildi ve “can” isimli dosya veya dizin bulunamadı şeklinde hata verildi. Çünkü grep aracı, araştırmak istediğimiz ifadeyi parantez içinde girmediğimiz zaman ilk argümanın aranacak ifade olduğunu, diğer argümanların ise araştırmanın yapılacağı dosya veya dizinler olduğunu düşünüyor. Komutumuzu bu kez tırnak içinde tekrar girelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">grep</span> <span class="s2">"ahmet can"</span> isimler.txt                                                   
ahmet can durmus
</code></pre></div></div>

<p>Bakın bu kez tam olarak tırnak içinde yazmış olduğum ifadeyi içeren satır getirilmiş oldu. Bizzat bu basit örneğimiz üzerinden teyit ettiğimiz gibi tırnak kullanımı önemli. Zaten hatırlıyorsanız daha önce kabuk genişletmelerinden bahsederken, <code class="language-plaintext highlighter-rouge">grep</code> ile <code class="language-plaintext highlighter-rouge">regex</code> kullanmak için de tırnak içinde yazmıştık. Tırnaklar sayesinde kesin olarak isteklerimizi iletmemiz mümkün oluyor.</p>

<h2 id="küçük-büyük-harf-duyarlılığı">Küçük Büyük Harf Duyarlılığı</h2>

<p>Fark ettiyseniz bir önceki örneğimizde aldığımız çıktıların hepsi küçük büyük harf duyarlılığı dahilinde tam olarak yazdığımız ifade ile eşleşenlerdi. Eğer filtreleme yapılırken küçük büyük harf duyarlılığının görmezden gelinmesini istersek <code class="language-plaintext highlighter-rouge">i</code> seçeneğini kullanabiliyoruz. Buradaki <code class="language-plaintext highlighter-rouge">i</code> seçeneği “<strong>i</strong>nsensitive” yani “duyarsız” ifadesinin kısaltmasından geliyor. Pek çok araç da aynı şekilde küçük büyük harfin görmezden gelinmesi için <code class="language-plaintext highlighter-rouge">i</code> seçeneğini kullanmamızı istiyor.</p>

<p>Şimdi ben test etmek için en son girmiş olduğum komutu tekrar çağırıp, buraya <code class="language-plaintext highlighter-rouge">i</code> seçeneğini de ekliyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">grep</span> <span class="nt">-i</span> <span class="s2">"ahmet can"</span> isimler.txt                                                
Ahmet can
Ahmet Can Yazar
ahmet can durmus
</code></pre></div></div>

<p>Bakın bu kez küçük büyük harf demeden “ahmet can” ifadesi ile eşleşen tüm satırlar getirilmiş oldu. Neticede hepsi “ahmet can” ifadesiyle eşleşiyor ama küçük büyük harf farkları var. Siz de <code class="language-plaintext highlighter-rouge">i</code> seçeneği sayesinde bu şekilde filtreleme yapılırken küçük büyük harflerin görmezden gelinmesini sağlayabilirsiniz.</p>

<h2 id="kelime-odaklı-filtreleme">Kelime Odaklı Filtreleme</h2>

<p>Tam olarak aradığımız kelime ile eşleşenleri filtrelemek için “<strong>w</strong>ord” ifadesinin kısaltmasından gelen <code class="language-plaintext highlighter-rouge">w</code> seçeneğini kullanabiliyoruz.</p>

<p>Kullanımını daha net gözlemleyebilmek için öncelikle <code class="language-plaintext highlighter-rouge">grep “ali” isimler.txt</code> komutunu girelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">grep</span> <span class="s2">"ali"</span> isimler.txt                                                      
halil cansun
ali
Halil cansun
Mustafa alican
halime
Mehmet ali
ahmet ali
ali said
ali
</code></pre></div></div>

<p>Bakın çıktılarda yalnızca “ali” ifadesi değil, satırın herhangi bir noktasında “ali” ifadesi geçenler de bastırılmış oldu. Eğer ben bu şekilde herhangi bir noktada değil de tek başına “ali” ifadesini arıyorsam aynı komutumu bu kez <code class="language-plaintext highlighter-rouge">w</code> seçeneğiyle birlikte kullanabilirim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">grep</span> <span class="nt">-w</span> <span class="s2">"ali"</span> isimler.txt                                                      
ali
Mehmet ali
ahmet ali
ali said
ali
</code></pre></div></div>

<p>Bakın bu kez yalnızca tam olarak “ali” kelimesinin tek başına bulunduğu satırlar filtrelenmiş oldu.</p>

<h2 id="okunaklı-çıktılar">Okunaklı Çıktılar</h2>

<p>Aldığımız çıktıları daha okunaklı hale getirebiliriz. Mesela eğer <code class="language-plaintext highlighter-rouge">n</code> seçeneğini eklersek, satır numaralarını da görmemiz mümkün.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">grep</span> <span class="nt">-wn</span> <span class="s2">"ali"</span> isimler.txt                                                     
43:ali
454:Mehmet ali
536:ahmet ali
554:ali said
598:ali
</code></pre></div></div>

<p>Bakın bu kez bu ifadelerin tam olarak hangi satırda geçtiği satırın en başında yazıyor.</p>

<p>Ayrıca satır numarası yerine istersek toplamda kaç eşleşme olduğunu öğrenmek için “<strong>c</strong>ount” ifadesinin kısaltmasından gelen <code class="language-plaintext highlighter-rouge">c</code> seçeneğini de kullanabiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">grep</span> <span class="nt">-wc</span> <span class="s2">"ali"</span> isimler.txt                                                     
5
</code></pre></div></div>

<p>Bakın toplam kaç eşleşme olduğu burada yazıyor. Benim dosyamda tam olarak 5 kere tamamı küçük harfli “ali” kelimesi geçiyormuş.</p>

<h2 id="çoklu-filtre">Çoklu Filtre</h2>

<p>Dilersek verileri aşamalı olarak filtreleyip istediğimiz nihai verilere ulaşabiliriz.</p>

<p>Örneğin ben /var/log/user.log dosyasında “kali” ve “error” ifadelerinin geçtiği satırları filtrelemek istiyorum. Eğer komutumu <code class="language-plaintext highlighter-rouge">cat /var/log/user.log | grep “kali”</code> şeklinde girecek olursam yalnızca “kali” ifadesinin geçtiği satırlar getirilecek.</p>

<p><img src="https://superua1.github.io//egitim/metin/25.png" alt="25.png" class="responsive img-zoomable" /></p>

<p>Ama ben hem “kali” hem de küçük büyük harf fark etmeksizin “error” ifadesinin geçtiği satırları filtrelemek istiyorum. Bunun için bir önceki komutumuza bir <code class="language-plaintext highlighter-rouge">grep</code> filtresi daha ekleyebiliriz.</p>

<p>Pipe yardımıyla ilk <code class="language-plaintext highlighter-rouge">grep</code> aracının filtrelediği sonuçları alıp, ikinci <code class="language-plaintext highlighter-rouge">grep</code> aracına filtrelemesi için iletelim.</p>

<p><img src="https://superua1.github.io//egitim/metin/26.png" alt="26.png" class="responsive img-zoomable" /></p>

<p>Bakın bu kez “kali” ve “error” ifadelerinin bulunduğu satırları filtrelemiş olduk. Yani bu basit örneğimiz üzerinden pipe mekanizması sayesinde aslında ne kadar esnekliğe sahip olduğumuzu bir kez daha bizzat teyit etmiş olduk. Siz de benzer çözümler için dilediğiniz kadar aracı uygun şekilde birbirine bağlayıp çalıştırabilirsiniz.</p>

<p>Tamamdır bence temel <code class="language-plaintext highlighter-rouge">grep</code> kullanımı için bu kadar bilgi yeterli.</p>

<p>Ben son olarak <code class="language-plaintext highlighter-rouge">grep</code> ile temel düzeyde <strong>regex</strong> kullanımından da bahsedip anlatımı noktalamak istiyorum.</p>

<h2 id="grep-üzerinde-regex-kullanımı">Grep Üzerinde Regex Kullanımı</h2>

<p><code class="language-plaintext highlighter-rouge">grep</code> aracı; “basit”, “genişletilmiş” ve “perl uyumlu” olmak üzere üç tür genişletme özelliğini destekliyor olmasına karşın varsayılan olarak “basit” genişletmeyi kullanıyor.</p>

<p>Biz öncelikle basit Regex’in temel karakterlerini tanıyarak başlayalım.</p>

<p><code class="language-plaintext highlighter-rouge">.</code> - Herhangi bir tek karakteri temsil eder (satır sonu karakteri hariç).
<code class="language-plaintext highlighter-rouge">*</code> - Bir önceki karakterin sıfır veya daha fazla tekrarını temsil eder.
<code class="language-plaintext highlighter-rouge">+</code> - Bir önceki karakterin bir veya daha fazla tekrarını temsil eder.
<code class="language-plaintext highlighter-rouge">?</code> - Bir önceki karakterin sıfır veya bir kez tekrarını temsil eder.
<code class="language-plaintext highlighter-rouge">^</code> - Dizinin başlangıcını temsil eder.
<code class="language-plaintext highlighter-rouge">$</code> - Dizinin sonunu temsil eder.
<code class="language-plaintext highlighter-rouge">[]</code> - Bir karakter kümesini belirtir. Bu kümedeki herhangi bir karakterle eşleşir.
<code class="language-plaintext highlighter-rouge">[a-z]</code> - Küçük harflerin olduğu bir karakter aralığını belirtir.
<code class="language-plaintext highlighter-rouge">[A-Z]</code> - Büyük harflerin olduğu bir karakter aralığını belirtir.
<code class="language-plaintext highlighter-rouge">[0-9]</code> - Rakamların olduğu bir karakter aralığını belirtir.
<code class="language-plaintext highlighter-rouge">\\</code> - Özel karakterlerin (örneğin <code class="language-plaintext highlighter-rouge">.</code> ) özel anlamlarını iptal eder.
<code class="language-plaintext highlighter-rouge">|</code> - Alternatifler arasında bir seçenek yani “ya da” koşulu belirtir.</p>

<p>Ben örnek olması Regex kullanımını <code class="language-plaintext highlighter-rouge">grep</code> üzerinden çok kısaca ele alıyor olacağım ancak Linux üzerinde Regex’i destekleyen diğer araçlar üzerinde de aynı şekilde Regex kullanabilirsiniz. Bu konu hakkında daha fazla detay almak için “Linux Üzerinde Regex Kullanımı” blog yazısını okuyabilirsiniz.</p>

<h3 id="satır-başı-">Satır Başı: <code class="language-plaintext highlighter-rouge">^</code></h3>

<p>Spesifik olarak belirli bir ifadeyle başlayan satırları filtrelemek istersek şapka ya da düzeltme işareti olarak da bilinen bu <code class="language-plaintext highlighter-rouge">^</code> işareti kullanabiliyoruz.</p>

<p>Örneğin ben “<strong>ay</strong>” ifadesiyle başlayan satırları filtrelemek istersem <code class="language-plaintext highlighter-rouge">grep “^ay” isimler.txt</code> şeklinde komutumu yazabilirim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">grep</span> <span class="s2">"^ay"</span> isimler.txt                                                     
aydin
ayşe fulya
ayşe gizem
aykut
aydin
ayşe
ayşegül
</code></pre></div></div>

<p>Bakın yalnızca başlangıcı “ay” olanlar bastırılmış oldu.</p>

<h3 id="satır-sonu-">Satır Sonu: <code class="language-plaintext highlighter-rouge">$</code></h3>

<p>Tersi şekilde eğer satır sonlarındaki karakterlere göre filtreleme yapmak istersek de dolar <code class="language-plaintext highlighter-rouge">$</code> işaretini kullanabiliyoruz. Ben sonu “<strong>ay</strong>” ifadesiyle bitenleri filtrelemek için <code class="language-plaintext highlighter-rouge">grep “ay$” isimler.txt</code> şeklinde giriyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">grep</span> <span class="s2">"ay$"</span> isimler.txt                                                         
Koray
Mehmet koray
Feray
Tümay
eray
Nuray
Ilkay
gökay
</code></pre></div></div>

<p>Bakın yalnızca satır sonunda “<strong>ay</strong>” ifadesi olanlar bastırıldı. Bu tanımı yazarken dolar işaretini sona eklemiz gerektiğine dikkat edin lütfen. Eğer dolar işaretini bu şekilde sonda değil de başta yazacak olursanız ilgili eşleşme sağlanamaz.</p>

<h3 id="nokta-i̇şareti-">Nokta İşareti <code class="language-plaintext highlighter-rouge">.</code></h3>

<p>Nokta işareti sayesinde tek bir karakter ile eşleşecek şekilde tanımlama yapmamız mümkün.</p>

<p>Denemek için <code class="language-plaintext highlighter-rouge">grep “ay.” isimler.txt</code> şeklinde komutumuzu girelim.</p>

<p><img src="https://superua1.github.io//egitim/metin/18.png" alt="18.png" class="responsive img-zoomable" /></p>

<p>Bakın “<strong>ay</strong>” ifadesi ve devamında küçük büyük olması fark etmeksizin <strong>herhangi bir karakteri</strong> barındıran tüm veriler filtrelenmiş oldu. Örneğin bir nokta daha eklersek, herhangi bir karakter daha ekleneceği için “<strong>ay</strong>” ile başlayıp devamında herhangi iki karakteri barındıranlar filtrelenecek.</p>

<p><img src="https://superua1.github.io//egitim/metin/19.png" alt="19.png" class="responsive img-zoomable" /></p>

<p>Bakın tam olarak beklediğimiz gibi “ay” ile başlayan ve devamında herhangi iki karakteri barındıran tüm satırılar filtrelendi.</p>

<h3 id="köşeli-parantez-">Köşeli Parantez <code class="language-plaintext highlighter-rouge">[]</code></h3>

<p>Eğer rastgele karakterler yerine spesifik olarak bizim istediğimiz bazı karakterlerin bulunduğu verileri filtrelemek istersek köşeli parantez kullanabiliriz. Köşeli parantez içinde karakter kümelerini liste şeklinde verebiliyoruz.</p>

<p>Örneğin ben “a” karakterinden sonra yalnızca “k” “l” ve “r” karakterlerinden birini barındıran verileri filtrelemek istediğim için <code class="language-plaintext highlighter-rouge">grep “a[klr]” isimler.txt</code> şeklinde komutumu giriyorum.</p>

<p><img src="https://superua1.github.io//egitim/metin/20.png" alt="20.png" class="responsive img-zoomable" /></p>

<p>Bakın tam olarak “a” karakterinden sonra köşeli parantez içinde belirttiğimiz karakterlerden birini barındıran tüm veriler filtrelendi. Tersi şekilde eğer köşeli parantez içindeki karakteri hariç tutup bunlar dışındaki herhangi karakterleri kapsamak istersek de köşeli parantezin en başında şapka <code class="language-plaintext highlighter-rouge">^</code> işaretini kullanabiliyoruz.</p>

<p><img src="https://superua1.github.io//egitim/metin/21.png" alt="21.png" class="responsive img-zoomable" /></p>

<p>Yani gördüğünüz gibi şapka işareti sayesinde buradaki karakterleri hariç tutarak filtreleme yapabiliyoruz.</p>

<p>Burada dikkat ettiyseniz bizim köşeli parantez içinde yazdığımız karakterler yalnızca tek bir karakter ile eşleşme sağlıyor. Örneğin ben “a” karakterinden sonra “k” “l” “r” karakterlerini bulundurmayan ama “a” “b” ve “c” karakterinden birini bulunduran veriyi filtrelemek istersem komutumu <code class="language-plaintext highlighter-rouge">grep a[^klr][abc] isimler.txt</code> şeklinde girebilirim.</p>

<p><img src="https://superua1.github.io//egitim/metin/22.png" alt="22.png" class="responsive img-zoomable" /></p>

<p>Bakın tam olarak “a” karakterinde sonra “k” “l” “r” karakterini barındırmayan ama üçüncü karakterinde “a” “b” ve “c” karakterlerinden herhangi birini barındıran tüm veriler filtrelenerek renklendirilmiş oldu.</p>

<p>Yani gördüğünüz gibi köşeli parantez sayesinde spesifik olarak tek bir karakterin nasıl olması veya olmaması gerektiğini belirtebiliyoruz. Ve tabii ki peş peşe burada olduğu gibi köşeli parantez kullanarak da hangi karakterin ne şekilde olabileceğini de spesifik olarak sınırlayabiliyoruz.</p>

<p>İşte basit regex genişletmeleri bu şekilde. Ben hepsine tek tek değinmek istemiyorum. Daha fazla bilgi almak için mutlaka buradaki blog yazısını baştan sonra okuyup öyle devam edin. Bu sayede Linux üzerinde Regex’i çok daha etkili şekilde kullanabiliyor olacaksınız.</p>

<h2 id="grep-üzerinde-genişletilmiş-regex-kullanımı">Grep Üzerinde Genişletilmiş Regex Kullanımı</h2>

<p>Ayrıca basit regex dışında, genişletilmiş regex kalıplarını kullanmamız da mümkün. Fakat ben bu eğitimde bunların detaylarına girmek istemiyorum. Daha fazla bilgi almak için blog yazısını okuyabilirsiniz.</p>

<p>Ben yalnızca örnek olması için genişletilmiş regex kullanımına bir tane örnek vermek istiyorum.</p>

<p>Örneğin regex için “ya da” anlamına gelen dik çizgi <code class="language-plaintext highlighter-rouge">|</code> işaretini kullanarak filtreleme yapmayı deneyebiliriz.</p>

<p>Ben “ahmet” “can” “ayse” isimlerinden birini barındıran satırları filtrelemek istersem <code class="language-plaintext highlighter-rouge">grep “ahmet|can|ayse” isimler.txt</code> şeklinde komutumu girebilirim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">grep</span> <span class="s2">"ahmet|can|ayse"</span> isimler.txt
</code></pre></div></div>

<p>Bakın bu şekilde girince bir çıktı almadık çünkü buradaki kullandığımız dikey çizgi <code class="language-plaintext highlighter-rouge">|</code> karakteri regex’in “ya da” anlamında kullandığı karakter olarak temsil edilmedi. Bunun yerine komutumuza <code class="language-plaintext highlighter-rouge">E</code> seçeneğini eklersek bu karakter beklendiği şekilde çalışacak. Hemen denemek için komutumuzu çağırıp büyük <code class="language-plaintext highlighter-rouge">E</code> seçeneğini ekleyelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">grep</span> <span class="nt">-E</span> <span class="s2">"ahmet|can|ayse"</span> isimler.txt                                           
ahmet
halil cansun
yiğit can
Halil cansun
Mustafa alican
ahmet kürşad
cansu
ahmet ali
kenan ahmet
Ahmet can
ahmet
can yıldırım
ahmet can durmus
can ahmet furkan
</code></pre></div></div>

<p>Bakın bu kez “ahmet” “can” veya “ayse” ifadelerini barındıran satırların filtrelenmesini sağlamış olduk. Buradaki büyük <code class="language-plaintext highlighter-rouge">E</code> seçeneği “<strong>E</strong>xtended<strong>”</strong> yani “genişletilmiş” ifadesinin kısaltmasından gelen seçeneğimiz. Bu seçenek sayesinde tıpkı buradaki dikey çizgi <code class="language-plaintext highlighter-rouge">|</code> gibi, doğrudan genişletilmiş regex karakteri olarak algılanmayan regex karakterlerinin kullanılabilmesi de mümkün oluyor.</p>

<p>Linux üzerinde <code class="language-plaintext highlighter-rouge">?</code> <code class="language-plaintext highlighter-rouge">+</code> <code class="language-plaintext highlighter-rouge">{}</code> ve <code class="language-plaintext highlighter-rouge">|</code> metakarakterleri genişletilmiş regex dahilinde ele alındığı için bunları kullanırken ilgili araca bu durumu <code class="language-plaintext highlighter-rouge">grep</code> aracının <code class="language-plaintext highlighter-rouge">-E</code> seçeneğinde olduğu gibi açıkça ifade etmemiz gerek. Ayrıca bu karakterleri genişletilmiş regex yerine basit regex kurallarıyla birlikte kullanırken bu karakterlerden önce ters slash <code class="language-plaintext highlighter-rouge">\</code> koyarak bu karakterlerin özel anlamları ile ele alınmasını da sağlayabiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">grep</span> <span class="s2">"ahmet</span><span class="se">\|</span><span class="s2">can</span><span class="se">\|</span><span class="s2">ayse"</span> isimler.txt                                  
ahmet
halil cansun
yiğit can
Halil cansun
Mustafa alican
ahmet kürşad
cansu
ahmet ali
kenan ahmet
Ahmet can
ahmet
can yıldırım
ahmet can durmus
can ahmet furkan
</code></pre></div></div>

<p>Bakın basit regex üzerinden genişletilmiş regex metakarakterlerini kullanmak için bu karakterlerden önce ters slash kullanabileceğimizi bizzat görmüş olduk. Birden fazla kez tekrarladığım gibi Linux üzerinde Regex kullanımını daha net anlamak için mutlaka buradaki blog içeriğine göz atın. Ben bu blog yazısını okuduğunuzu yani regex kullanımını bildiğinizi varsayarak eğitime devam ediyor olacağım.</p>

<p>Benim şimdilik regex ve <code class="language-plaintext highlighter-rouge">grep</code> aracı hakkında bahsetmek istediklerim bu kadar. Zaten temelde bilmemiz gerekenlerden bahsettik. Daha fazlası için hem <code class="language-plaintext highlighter-rouge">grep</code> aracının yardım sayfasına hem de regex için harici kaynaklara bakmanız yeterli.</p>

<h1 id="find">find</h1>

<p><code class="language-plaintext highlighter-rouge">find</code> aracı, açıkça isminden de anlaşılabileceği gibi sistem üzerindeki dosya ve klasörleri arayıp, konumlarını bulmamıza yardımcı olan bir araç. En yalın kullanımı <code class="language-plaintext highlighter-rouge">find</code> komutundan sonra hangi dizinde araştırıma yapılacağını belirtip daha sonra <code class="language-plaintext highlighter-rouge">-name</code> seçeneğinin ardından araştırılacak olan dosya ya da klasör isminin girilmesi şeklinde.</p>

<p>Ben aranacak dosya ve klasörleri kendim oluşturmak için <code class="language-plaintext highlighter-rouge">touch ~/Documents/bulbeni</code> ve <code class="language-plaintext highlighter-rouge">mkdir ~/Pictures/bulbeni</code> komutlarını giriyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">touch</span> ~/Documents/bulbeni
┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">mkdir</span> ~/Pictures/bulbeni
</code></pre></div></div>

<p>Böylelikle aynı isimli dosya ve klasörümüzü farklı dizinlerde oluşturmuş olduk.</p>

<p>Şimdi <code class="language-plaintext highlighter-rouge">find</code> komutumuzu bu dosya ve klasörleri bulmak için kullanabiliriz. Ben şu an ev dizinimdeyim, bulunduğum dizinden itibaren tüm alt dizinlere bakılıp aradığım kelime ile eşleşen dosya ya da klasör ismi var mı diye bakmak için <code class="language-plaintext highlighter-rouge">find .</code> yazıyorum buradaki nokta <code class="language-plaintext highlighter-rouge">.</code> bulunduğum dizini temsil ediyor. Aslında nokta yazmasam bile <code class="language-plaintext highlighter-rouge">find</code> komutu ekstra bir hedef belirtmediğimiz sürece mevcut dizinimizde araştırma yapıyor ama biz daha anlaşılır olması için mevcut dizinimizi nokta ile hedef gösterebiliriz. Yazacağım kelimeyle eşleşen dosya ve klasörleri bulmak için de <code class="language-plaintext highlighter-rouge">-name</code> seçeneğinin ardından aradığım kelimeyi giriyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>find <span class="nb">.</span> <span class="nt">-name</span> <span class="s2">"bulbeni"</span>                                    
./Documents/bulbeni
./Pictures/bulbeni
</code></pre></div></div>

<p>Bakın isimle eşleşen hem klasör hem de dosya, tam konumlarıyla birlikte listelenmiş oldu.</p>

<p><code class="language-plaintext highlighter-rouge">find</code> komutunun en yalın kullanımı bu şekilde. Tabii ki tüm kullanım imkanı bundan ibaret değil. Araştırma yapılırken filtreleme yapılabilmesi için aranacak dosya veya klasörün özelliklerine göre kullanabileceğimiz birden fazla seçenekler bulunuyor. Hemen kısaca bunlardan söz edelim.</p>

<h3 id="tipine-göre-filtreleme--dosya---dizin">Tipine Göre Filtreleme | Dosya - Dizin</h3>

<p>Eğer <strong>yalnızca dosyaları</strong> filtrelemek istiyorsak <code class="language-plaintext highlighter-rouge">type</code> seçeneğinin ardından “<strong>f</strong>ile” yani “dosya” ifadesinin kısaltmasından gelen <code class="language-plaintext highlighter-rouge">f</code> parametresini yazmamız gerekiyor. Eğer <strong>klasörleri filtrelemek</strong> istersek de “<strong>d</strong>irectory” yani “klasör” ifadesinin kısaltmasından gelen <code class="language-plaintext highlighter-rouge">d</code> ifadesini kullanabiliyoruz. Hemen örneğimiz üzerinden deneyelim.</p>

<p>Ben öncelikle “bulbeni” isimli <strong>dosyayı</strong> araştırmak istediğim için <code class="language-plaintext highlighter-rouge">find .  -name “bulbeni” -type f</code> şeklinde yazıyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>find <span class="nb">.</span> <span class="nt">-name</span> <span class="s2">"bulbeni"</span> <span class="nt">-type</span> f                               
./Documents/bulbeni
</code></pre></div></div>

<p>Bakın burada aldığımız çıktı yalnızca dosyanın konumunu veriyor.</p>

<p>Benzer şekilde yalnızca klasörü bulmak için <code class="language-plaintext highlighter-rouge">d</code> parametresi ile araştırma yapabiliriz.</p>

<p><code class="language-plaintext highlighter-rouge">find . -name “bulbeni” -type d</code> şeklinde araştıralım.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>find <span class="nb">.</span> <span class="nt">-name</span> <span class="s2">"bulbeni"</span> <span class="nt">-type</span> d
./Pictures/bulbeni
</code></pre></div></div>

<p>Bakın bu çıktı da klasörün konumuna işaret ediyor.</p>

<p>Yani bakın bizzat teyit ettiğimiz gibi <code class="language-plaintext highlighter-rouge">find</code> ile araştırma yapılırken bu şekilde dosya ve klasör olma durumuna göre yani tipine göre filtreleme yapabiliyoruz.</p>

<p>Mesela ben yalnızca mevcut bulunduğum dizinde araştırma yaptım ama aslında istediğim bir dizin altında araştırma yapılmasını sağlayabilirim. Denemek için bu kez “<strong><em>/etc/</em></strong>” dizini atlında sonu “<strong>.conf</strong>” ile biten tüm içerikleri bastırmak istiyorum. Bunun için <code class="language-plaintext highlighter-rouge">find /etc/ -name “*.conf”</code> komutunu girebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>find /etc/ <span class="nt">-name</span> <span class="s2">"*.conf"</span>                                    
/etc/inetsim/inetsim.conf
/etc/initramfs-tools/initramfs.conf
/etc/initramfs-tools/update-initramfs.conf
/etc/pulse/daemon.conf
/etc/pulse/client.conf.d/01-enable-autospawn.conf
/etc/pulse/client.conf
/etc/apparmor/parser.conf
...
..
<span class="nb">.</span>
</code></pre></div></div>

<p class="mavi"><strong>Not:</strong> Çıktı çok uzun olduğu için kısaltılarak verilmiştir.</p>

<p>Bakın “<strong><em>/etc/</em></strong>” dizini atlında isminin sonu “.conf” ile biten tüm dosya ve dizinler filtrelenmiş oldu. Eğer yalnızca “<strong><em>/etc/</em></strong>” dizini altında değil de tüm sistem genelinde araştırma yapmak istersek araştırılacak dizin olarak yalnızca slash <code class="language-plaintext highlighter-rouge">/</code> karakterini yazmamız da yeterli.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>find / <span class="nt">-name</span> <span class="s2">"*.conf"</span>                                    
/home/taylan/.config/qt5ct/qt5ct.conf
find: ‘/root’: Permission denied
/usr/lib32/gconv/gconv-modules.d/gconv-modules-extra.conf
/usr/lib/kernel/install.conf
/usr/lib/python3/dist-packages/cme/data/cme.conf
/usr/lib/python3/dist-packages/binwalk/config/extract.conf
/usr/lib/NetworkManager/conf.d/no-mac-addr-change.conf
/usr/lib/sysctl.d/50-bubblewrap.conf
/usr/lib/sysctl.d/50-pid-max.conf
/usr/lib/sysctl.d/99-protect-links.conf
/usr/lib/sysusers.d/systemd-journal.conf
/usr/lib/sysusers.d/systemd-resolve.conf
/usr/lib/sysusers.d/dbus.conf
...
..
<span class="nb">.</span>
</code></pre></div></div>

<p>Tabii ki bu işlem tüm sistem hiyerarşisinin kontrol edilmesini gerektirdiği için biraz vakit alabilir. Ancak neticede gördüğünüz gibi istediğimiz bir dizin altında aradığımız isimle eşleşen dosya ve dizinleri belirtebiliyoruz.</p>

<h3 id="boyutlarına-göre-filtreleme">Boyutlarına Göre Filtreleme</h3>

<p>Boyuta göre filtreleme yapmak için <code class="language-plaintext highlighter-rouge">size</code> seçeneğini kullanmamız gerekiyor. Örneğin bulunduğumuz dizin altındaki 1 megabayttan büyük olan tüm dosyaları getirmek için <code class="language-plaintext highlighter-rouge">find . -type f -size +1M</code> şeklinde komutumuzu kullanabiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>find <span class="nb">.</span> <span class="nt">-type</span> f <span class="nt">-size</span> +1M
./.mozilla/firefox/d5n1etpa.default-esr/storage/permanent/chrome/idb/3870112724rsegmnoittet-es.sqlite
./.mozilla/firefox/d5n1etpa.default-esr/places.sqlite
./.mozilla/firefox/d5n1etpa.default-esr/security_state/data.safe.bin
./.mozilla/firefox/d5n1etpa.default-esr/favicons.sqlite
...
..
<span class="nb">.</span>
</code></pre></div></div>

<p>Bakın buradaki tüm dosyalar 1 megabayttan büyük olan dosyalar. Eğer küçük olanları istersek artı yerine eksi <code class="language-plaintext highlighter-rouge">-</code> işaretini girebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>find <span class="nb">.</span> <span class="nt">-type</span> f <span class="nt">-size</span> <span class="nt">-1M</span>                                    
./dosya1
./dosya2
./klasor/dosya1
./klasor/dosya2
./klasor/dosys3
./.mozilla/firefox/d5n1etpa.default-esr/.parentlock
./.cache/go-build/e3/e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855-d
./.cache/mozilla/firefox/d5n1etpa.default-esr/cache2/ce_T151c2VyQ29udGV4dElkPTUsYSw<span class="o">=</span>
./.cache/mozilla/firefox/d5n1etpa.default-esr/cache2/ce_T151c2VyQ29udGV4dElkPTUs
./.ICEauthority
./Documents/bulbeni
./.config/xfce4/desktop/icons.screen0-1263x957.rc
./.config/xfce4/desktop/icons.screen0-2544x966.rc
./Desktop/test.txt
./dosys3
./calısma/y5t.jpg
</code></pre></div></div>

<p>Bakın bu aldığımız çıktılar da 1 megabayttan küçük olanlar.</p>

<p>Boyutu farklı girmek isterseniz;</p>

<p><strong>bayt</strong> için <strong>b,</strong></p>

<p><strong>kilobayt</strong> için <strong>k</strong></p>

<p><strong>megabayt</strong> için büyük <strong>M</strong></p>

<p><strong>gigabayt</strong> için büyük <strong>G</strong> kullanabilirsiniz.</p>

<p>Örneğin ben kök dizin altında 1 gigabayttan büyük olan dosyaları bulmak istiyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>find / <span class="nt">-type</span> f <span class="nt">-size</span> +1G 2&gt;/dev/null
/proc/kcore
</code></pre></div></div>

<p class="mavi"><strong>Not:</strong> Kök dizin altında yetki hatası aldığımız için hatalı çıktıları <code class="language-plaintext highlighter-rouge">2&gt; /dev/null</code> komutu ile yok ettim.</p>

<p>Gördüğünüz gibi 1 gigabayttan büyük olan dosyam bulunmuş oldu. Siz de istediğiniz büyüklük birimine göre filtreleme yapabilirsiniz.</p>

<h3 id="tarihlerine-göre-filtreleme">Tarihlerine Göre Filtreleme</h3>

<p>Ayrıca erişim, değişim ve düzenleme tarihlerine göre de filtrelemeniz de mümkün. Zaten bu tarihlerin neyi ifade ettiğini daha önce açıklamıştık.</p>

<p>Örneğin düzenlenme(modify) tarihi için <code class="language-plaintext highlighter-rouge">mtime</code> kullanılıyorken, değişim(change) tarihi için <code class="language-plaintext highlighter-rouge">ctime</code>, erişim(access) tarihi için de <code class="language-plaintext highlighter-rouge">atime</code> parametrelerini kullanabiliyoruz.</p>

<p>Daha azı için eksi <code class="language-plaintext highlighter-rouge">-</code></p>

<p>Daha fazlası için artı <code class="language-plaintext highlighter-rouge">+</code></p>

<p>Tam tarih için doğrudan günü belirtebiliyoruz.</p>

<p>Eğer ben mevcut bulunduğum dizinde <strong>tam olarak 10 gün önce</strong> düzenlenmiş içerikleri görmek istersem <code class="language-plaintext highlighter-rouge">find -mtime 10</code> şeklinde komutumu girebilirim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>find <span class="nt">-mtime</span> 10
./Documents/belgeler
./.config/xfce4/desktop/icons.screen0-1263x957.rc
./.config/xfce4/desktop/icons.screen0-2544x966.rc
</code></pre></div></div>

<p>Bakın buradaki içerikler tam olarak 10 gün önce düzenlenmiş dosya ve klasörler.</p>

<p>Eğer 2 günden daha kısa bir süre önce düzenlenmişleri öğrenmek istersek <code class="language-plaintext highlighter-rouge">-2</code> ile iki günden öncesini belirtebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>find <span class="nt">-mtime</span> <span class="nt">-2</span>
<span class="nb">.</span>
./.wget-hsts
./.vboxclient-draganddrop.pid
./dosya1
./dosya2
./liste.txt
./klasor
./klasor/oku-beni
./klasor/dosya1
./klasor/dosya2
./klasor/liste2
./klasor/deneme.txt
./klasor/liste
./klasor/dosys3
./isimler.txt
./.vboxclient-clipboard.pid
./.bash_history
./.xsession-errors
./.Xauthority
./liste
./Documents
./Documents/bulbeni
./sırala
./.vboxclient-display-svga-x11.pid
./dosys3
./Downloads
./.vboxclient-seamless.pid
./Pictures
./Pictures/bulbeni
./bul
./liste2.txt
</code></pre></div></div>

<p>Bakın bunlar bu gün veya dün düzenlenmiş olan içerikler.</p>

<p>Eğer düzenleme süresi 5 günden daha önceki tarihler olan içerikleri görmek istersek de <code class="language-plaintext highlighter-rouge">find -mtime +5</code> şeklinde düzenlenme tarihinden 5 günden daha fazla zaman geçmiş olacağını belirtebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>find <span class="nt">-mtime</span> +5
./.bashrc.original
./dosya.txt
./.gnupg
./.gnupg/private-keys-v1.d
./.java
./.java/.userPrefs
./.java/.userPrefs/burp
./.java/.userPrefs/burp/prefs.xml
...
..
<span class="nb">.</span>
</code></pre></div></div>

<p>Bakın buradaki dosyalarım tamamı, en yakın 6 gün önce düzenlemiş olanlar. Kimisi 100 gün önce de düzenlemiş olabilir. Neticede düzenleme tarihi <strong>son 5 günden öncesi</strong> olanları filtrelemek için <code class="language-plaintext highlighter-rouge">+5</code> parametresini kullandık.</p>

<p>Örneğin son 24 saatte düzenlenmiş olanları filtrelemek için <code class="language-plaintext highlighter-rouge">find -mtime -1</code> şeklinde girebiliriz. Buradaki <code class="language-plaintext highlighter-rouge">-1</code> bir günden daha kısa bir süre öncesinin zaman aralığını belirttiği için son 24 saatten şu ana kadar düzenlenmiş içerikler filtreleniyor.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>find <span class="nt">-mtime</span> <span class="nt">-1</span>
<span class="nb">.</span>
./.wget-hsts
./.vboxclient-draganddrop.pid
./dosya1
./dosya2
./liste.txt
./klasor
./klasor/oku-beni
./klasor/dosya1
./klasor/dosya2
./klasor/liste2
./klasor/deneme.txt
./klasor/liste
./klasor/dosys3
./isimler.txt
./.vboxclient-clipboard.pid
./.bash_history
./.xsession-errors
./.Xauthority
./liste
./Documents
./Documents/bulbeni
./sırala
./.vboxclient-display-svga-x11.pid
./dosys3
./Downloads
./.vboxclient-seamless.pid
./Pictures
./Pictures/bulbeni
./bul
./liste2.txt
</code></pre></div></div>

<p>Ben örnekler sırasında düzenlenme tarihleri için <code class="language-plaintext highlighter-rouge">mtime</code> seçeneğini kullandım ama siz değişim tarihleri için <code class="language-plaintext highlighter-rouge">ctime</code>, erişim tarihleri için de aynı şekilde <code class="language-plaintext highlighter-rouge">atime</code> seçeneklerini kullanarak arama sonuçlarını filtreleyebilirsiniz.</p>

<p>Ayrıca ben hep günler üzerinden ele aldım ancak aslında <code class="language-plaintext highlighter-rouge">min</code> parametresi sayesinde dakika üzerinden de bu filtrelemeyi yapmamız mümkün. Örneğin son 50 dakika içinde düzenlenmiş(modify) olanları filtrelemek için <code class="language-plaintext highlighter-rouge">find -mmin -50</code> şeklinde komutumu girebilirim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>find <span class="nt">-mmin</span> <span class="nt">-50</span>                                               
<span class="nb">.</span>
./.bash_history
./Documents
./Documents/bulbeni
./.config/xfce4/panel
./.config/xfce4/panel/genmon-15.rc
./.config/qterminal.org
./.config/qterminal.org/qterminal.ini
./Pictures
./Pictures/bulbeni
</code></pre></div></div>

<p>Bakın bunlar son 50 dakika içerisine düzenlenmiş olanlar. <strong>Günleri</strong> belirtirken <strong>time</strong> şeklinde yazıyorken, dakikaları belirtmek için “<strong>min</strong>utes” ifadesinin kısaltmasından gelen “<strong>min</strong>” seçeneğini kullanıyoruz. Yani düzenlenme(modify) dakikası için <code class="language-plaintext highlighter-rouge">mmin</code>, değişim(change) dakikası için <code class="language-plaintext highlighter-rouge">cmin</code>, erişim(access) dakikası için de <code class="language-plaintext highlighter-rouge">amin</code>, seçeneklerinin ardından dakikayı belirtebiliyoruz. Ben burada <code class="language-plaintext highlighter-rouge">-50</code> şeklinde yazdığım için <strong>son 50 dakika içerisindekileri</strong> kapsadım. Örneğin <code class="language-plaintext highlighter-rouge">+50</code> yazacak olursam, düzenlenme tarihi son 50 dakikayı geçmiş olan tüm içerikleri kastetmiş oluyorum.</p>

<p>Örneğin ben son 1 saat içerisinde hiç açmadığım yani erişmediğim içerikleri listelemek istersem, <code class="language-plaintext highlighter-rouge">find -amin +60</code> şeklinde komutumu girebilirim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>find <span class="nt">-amin</span> +60
./yepyenidosya
./.bashrc.original
./dosya.txt
./sonuc
./.gnupg
./.java
./.java/.userPrefs
./.java/.userPrefs/burp
./.java/.userPrefs/burp/prefs.xml
</code></pre></div></div>

<p>Bakın burada listelenmiş olan içeriklerin hiç birisine son 1 saat içerisinde erişim sağlamamışım. Tersi şekilde son bir saat içerisinde erişim sağladıklarımı görmek için de <code class="language-plaintext highlighter-rouge">-60</code> parametresini girebilirim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>find <span class="nt">-amin</span> <span class="nt">-60</span>                                              
<span class="nb">.</span>
./.gnupg/private-keys-v1.d
./.local/state/pipewire/media-session.d
./.bash_history
./.cache/gstreamer-1.0
./Documents
./Documents/bulbeni
./.config/xfce4/panel
./.config/xfce4/panel/genmon-15.rc
./.config/gtk-3.0
./.config/qterminal.org
./.config/qterminal.org/qterminal.ini
./Pictures
./Pictures/bulbeni
</code></pre></div></div>

<p>Bakın bunlar da son bir saat içerisinde erişim sağlanmış olanlar. Bence kullanımı son derece kolay. Biraz pratik yaparsanız tam olarak kullanımına alışırsınız zaten.</p>

<p>Ayrıca tüm bu bahsettiklerimiz dışında eğer <code class="language-plaintext highlighter-rouge">man find</code> şeklinde yazarsanız, aslında ne kadar çok filtreleme seçeneği olduğunu kendiniz de görebilirsiniz. Ancak ben hepsine değinmeyeceğim. İhtiyacınız olduğunda manuel sayfasından açıp bakabilirsiniz.</p>

<p>Henüz daha öğrenmediğimiz için yetkilere ve sahipliğe göre filtrelemeden bahsetmek istemiyorum. Ama zaten aynı şekilde <code class="language-plaintext highlighter-rouge">find</code> aracının yardım bilgilerinde belirtilen tüm seçenekleri ihtiyacınıza göre kullanabilirsiniz. Örneğin içerikleri yetkilerine göre filtrelemek için <code class="language-plaintext highlighter-rouge">perm</code> seçeneğini kullanıyorken, sahipliğine göre filtrelemek için de <code class="language-plaintext highlighter-rouge">user</code> seçeneğini kullanabiliyoruz. Ve bunlar gibi yardım sayfasında görebileceğiniz çeşitli filtreleme seçenekleri mevcut. İhtiyaç duyduğunuzda açıp yardım bilgisinden hangi seçeneği kullanmanız  gerektiğini öğrenebilirsiniz.</p>

<p>Ben dediğim gibi yetki ve sahip kavramlarından henüz bahsetmediğimiz için kafanızın karşımasını istemiyorum, zaten aynı şekilde tek yaptığımız bu özelliklere göre filtreleme yapmak. Bu konuları öğrendiğinizde dönüp <code class="language-plaintext highlighter-rouge">find</code> ile bu kriterlere göre filtreleme yapmakta özgürsünüz.</p>

<h3 id="olumsuzlama-seçeneği--not">Olumsuzlama Seçeneği | not</h3>

<p>İlgili seçenekten önce -not seçeneğini kullanarak, ilgili filtrelemenin tam tersini elde edebiliriz.</p>

<p>Örneğin ben <code class="language-plaintext highlighter-rouge">find -name “**.png”</code>* komutuyla mevcut dizinim altındaki sonu “<strong>.png</strong>” ile biten tüm içerikleri filtrelersem, gördüğünüz gibi tam istediğim gibi bu adresleri öğrenebiliyoruz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>find <span class="nt">-name</span> <span class="s2">"*.png"</span>                                           
./.cache/thumbnails/large/3ab698ceca6c7925eb3d1b884a26e75d.png
./.cache/thumbnails/large/c338c09e4cee3d0a205c77d2888f0fc0.png
./.cache/thumbnails/large/52e5c5b7a8eaeca56e0bf2634080a8f3.png
./.cache/thumbnails/large/b3fe8ef292b398b5ff2b48953a2dcaa3.png
./.cache/thumbnails/large/601fa98430e31526893c2cd4c497fb77.png
./.cache/thumbnails/large/e0142d1bb7807691d1f3c6fbef0db9d6.png
./.cache/thumbnails/large/4d47671573280bf1e30ef346ecd154ed.png
./.cache/thumbnails/normal/4ef1aeb4f74b05b642089a3fa725f6ff.png
./.cache/thumbnails/normal/fd024d11882b348b20550093e6339f54.png
./.cache/thumbnails/normal/ce9a4aafaf687c2389abce167751da5e.png
./.cache/thumbnails/normal/b229cfc54c3672c84da5bfb87f3c7ec9.png
./.cache/mozilla/firefox/d5n1etpa.default-esr/thumbnails/b8d33cbd34677070b8b70079044c40aa.png
./.cache/sessions/thumbs-taylan:0/Default.png
./Pictures/Screenshot_2023-05-30_10_28_23.png
./Pictures/Screenshot_2023-05-24_11_11_16.png
./Pictures/Screenshot_2022-07-03_06_45_05.png
./Pictures/Screenshot_2023-05-30_13_21_21.png
./Pictures/Screenshot_2022-07-03_06_45_04.png
./Pictures/Screenshot_2022-07-03_06_45_03.png
./Pictures/Screenshot_2022-06-30_03_23_40.png
./Pictures/Screenshot_2023-05-30_10_28_26.png
./Pictures/Screenshot_2023-05-30_10_28_19.png
./Pictures/Screenshot_2022-06-17_13_15_28.png
./Pictures/Screenshot_2022-07-03_06_45_02.png
./Pictures/Screenshot_2022-06-17_13_15_26.png
./Pictures/Screenshot_2023-05-28_10_42_36.png
./Pictures/Screenshot_2022-07-03_06_45_24.png
</code></pre></div></div>

<p>Eğer ben bu komutumu tekrar çağırıp, tersini kullanmak istediğim seçenekten hemen önce <code class="language-plaintext highlighter-rouge">-not</code> seçeneğini ekleyecek olursam yani <code class="language-plaintext highlighter-rouge">find -not -name *“**.png”</code> şeklinde komut girersem bu kez sonunda “.png” ismi olanlar hariç tüm içerikler bulunup konsola bastırılacak.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>find <span class="nt">-not</span> <span class="nt">-name</span> <span class="s2">"*.png"</span>
<span class="nb">.</span>
./yepyenidosya
./.bashrc.original
./dosya.txt
./sonuc
./.gnupg
./.gnupg/private-keys-v1.d
./.java
./.java/.userPrefs
./.java/.userPrefs/burp
./.java/.userPrefs/burp/prefs.xml
...
..
<span class="nb">.</span>
</code></pre></div></div>

<p>İşte burada benim yalnızca isim seçeneği üzerinden gösterdiğim bu <code class="language-plaintext highlighter-rouge">-not</code> seçeneği sayesinde tüm filtrelerin tersi şekilde çalışmasını sağlayabilirsiniz. Örneğin ben tam olarak 10 gün önce düzenlenmiş içerikleri filtrelemek için <code class="language-plaintext highlighter-rouge">find -mtime 10</code> şeklinde komut girersem, tam olarak 10 gün önce düzenlenmiş içerikler listeleniyor.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>find <span class="nt">-mtime</span> 10
./Documents/belgeler
./.config/xfce4/desktop/icons.screen0-1263x957.rc
./.config/xfce4/desktop/icons.screen0-2544x966.rc
</code></pre></div></div>

<p>Eğer buradaki <code class="language-plaintext highlighter-rouge">mtime</code> seçeneğinden önce <code class="language-plaintext highlighter-rouge">-not</code> seçeneğini ekleyecek olursak, bu kez tam tersi şekilde yani 10 gün önce oluşturulmamış olan tüm içerikler bastırılacaktır.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>find <span class="nt">-not</span> <span class="nt">-mtime</span> 10
<span class="nb">.</span>
./yepyenidosya
./.bashrc.original
./dosya.txt
./sonuc
./.gnupg
./.gnupg/private-keys-v1.d
./.java
./.java/.userPrefs
./.java/.userPrefs/burp
./.java/.userPrefs/burp/prefs.xml
</code></pre></div></div>

<p>Bu şekilde tüm filtreleme seçeneklerinden önce <code class="language-plaintext highlighter-rouge">-not</code> kullanarak ilgili filtrelemeyi tersine çevirmeniz mümkün.</p>

<h3 id="ve---ya-da-koşulları---and--or">Ve - Ya Da Koşulları | <code class="language-plaintext highlighter-rouge">-and</code> <code class="language-plaintext highlighter-rouge">-or</code></h3>

<p>Filtrelemeyi tek bir kritere göre değil de birden fazla kritere göre yapmak istersek koşul belirten “<code class="language-plaintext highlighter-rouge">-and</code>” “<code class="language-plaintext highlighter-rouge">-or</code>” gibi seçenekleri kullanabiliyoruz. Örneğin ben sonu “.txt” ile veya “.png” ile bitenleri filtrelemek istersem <code class="language-plaintext highlighter-rouge">find -name “*.txt” -or -name “*.png”</code> komutunu girebilirim.</p>

<p>Bakın burada isim filtrelemesi için iki özel isim belirtip, bu isimlerin arasına da <code class="language-plaintext highlighter-rouge">-or</code> seçeneği ile “veya” koşulu eklemiş olduk. Bu sayede sonu “.txt” ile veya “.png” biten tüm içerikler filtrelenecek.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>find <span class="nt">-name</span> <span class="s2">"*.txt"</span> <span class="nt">-or</span> <span class="nt">-name</span> <span class="s2">"*.png"</span>                         
./dosya.txt
./hatasız.txt
./metin1.txt
./harf.txt
./.local/lib/python3.9/site-packages/uro-1.0.0.dist-info/entry_points.txt
./.local/lib/python3.9/site-packages/uro-1.0.0.dist-info/top_level.txt
./.local/share/powershell/PSReadLine/ConsoleHost_history.txt
./.local/share/sqlmap/output/en.trendyol.com/target.txt
./.local/share/sqlmap/output/tech.trello.com/target.txt
./.local/share/sqlmap/output/blog.trello.com/target.txt
./.local/share/sqlmap/output/link2.trendyol.com/target.txt
./.local/share/sqlmap/output/api.trello.com/target.txt
./.local/share/sqlmap/output/api-gateway.trello.com/target.txt
./.local/share/sqlmap/output/help.trello.com/target.txt
./.local/share/sqlmap/output/br.blog.trello.com/target.txt
./.local/share/sqlmap/output/c.trello.com/target.txt
./.local/share/sqlmap/output/info.trello.com/target.txt
./.local/share/sqlmap/output/akademi.trendyol.com/target.txt
./.local/share/sqlmap/output/m.trendyol.com/target.txt
./liste.txt
./klasor/deneme.txt
./Public/metin1.txt
./Public/sonuc.txt
./Public/metin2.txt
./isimler.txt
./hatalı.txt
./.mozilla/firefox/d5n1etpa.default-esr/AlternateServices.txt
./.mozilla/firefox/d5n1etpa.default-esr/SiteSecurityServiceState.txt
./.mozilla/firefox/d5n1etpa.default-esr/pkcs11.txt
./hatasız2.txt
./.cache/thumbnails/large/3ab698ceca6c7925eb3d1b884a26e75d.png
./.cache/thumbnails/large/c338c09e4cee3d0a205c77d2888f0fc0.png
./.cache/thumbnails/large/52e5c5b7a8eaeca56e0bf2634080a8f3.png
./.cache/thumbnails/large/b3fe8ef292b398b5ff2b48953a2dcaa3.png
./.cache/thumbnails/large/601fa98430e31526893c2cd4c497fb77.png
./.cache/thumbnails/large/e0142d1bb7807691d1f3c6fbef0db9d6.png
./.cache/thumbnails/large/4d47671573280bf1e30ef346ecd154ed.png
./.cache/thumbnails/normal/4ef1aeb4f74b05b642089a3fa725f6ff.png
./.cache/thumbnails/normal/fd024d11882b348b20550093e6339f54.png
./.cache/thumbnails/normal/ce9a4aafaf687c2389abce167751da5e.png
./.cache/thumbnails/normal/b229cfc54c3672c84da5bfb87f3c7ec9.png
./.cache/mozilla/firefox/d5n1etpa.default-esr/thumbnails/b8d33cbd34677070b8b70079044c40aa.png
./.cache/sessions/thumbs-taylan:0/Default.png
./Documents/metin.txt
./sayi.txt
./metin2.txt
./hello.txt
./Desktop/test.txt
./Pictures/Screenshot_2023-05-30_10_28_23.png
./Pictures/Screenshot_2023-05-24_11_11_16.png
./Pictures/Screenshot_2022-07-03_06_45_05.png
./Pictures/Screenshot_2023-05-30_13_21_21.png
./Pictures/Screenshot_2022-07-03_06_45_04.png
./Pictures/Screenshot_2022-07-03_06_45_03.png
./Pictures/Screenshot_2022-06-30_03_23_40.png
./Pictures/Screenshot_2023-05-30_10_28_26.png
./Pictures/Screenshot_2023-05-30_10_28_19.png
./Pictures/Screenshot_2022-06-17_13_15_28.png
./Pictures/Screenshot_2022-07-03_06_45_02.png
./Pictures/Screenshot_2022-06-17_13_15_26.png
./Pictures/Screenshot_2023-05-28_10_42_36.png
./Pictures/Screenshot_2022-07-03_06_45_24.png
./karisik.txt
./liste2.txt
</code></pre></div></div>

<p>Bakın tam da beklediğimiz gibi koşul çalıştı ve “<strong>.txt</strong>” ile <strong>veya</strong> “<strong>.png</strong>” biten dosyaları aldık.</p>

<p><code class="language-plaintext highlighter-rouge">-and</code> koşuluna bir örnek vermemiz gerekirse örneğin sonu “<strong>.png</strong>” ile biten <strong>ve</strong> 100 kilobayttan büyük olanları filtrelemeyi deneyebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>find <span class="nt">-name</span> <span class="s2">"*.png"</span> <span class="nt">-and</span> <span class="nt">-size</span> +100k                          
./Pictures/Screenshot_2023-05-30_10_28_23.png
./Pictures/Screenshot_2023-05-24_11_11_16.png
./Pictures/Screenshot_2022-07-03_06_45_05.png
./Pictures/Screenshot_2023-05-30_13_21_21.png
./Pictures/Screenshot_2022-07-03_06_45_04.png
./Pictures/Screenshot_2022-07-03_06_45_03.png
./Pictures/Screenshot_2022-06-30_03_23_40.png
./Pictures/Screenshot_2023-05-30_10_28_26.png
./Pictures/Screenshot_2023-05-30_10_28_19.png
./Pictures/Screenshot_2022-06-17_13_15_28.png
./Pictures/Screenshot_2022-07-03_06_45_02.png
./Pictures/Screenshot_2022-06-17_13_15_26.png
./Pictures/Screenshot_2022-07-03_06_45_24.png
</code></pre></div></div>

<p>Bakın isim ve boyut filtreleri arasında kullanmış olduğumuz -and seçeneği sayesinde bu iki filtreyi birbirine bağlayıp hem “.png” ile biten hem de boyutu 100 kilobayttan büyük olanları filtrelemiş olduk.</p>

<p>İşte siz de bu şekilde spesifik olarak aradığınız özelliklere uyan filtremeler yapmak için bu koşul seçeneklerini kullanabilirsiniz.</p>

<h3 id="find-üzerinde-regex-kullanımı">find Üzerinde Regex Kullanımı</h3>

<p>Normalde firnd komutu biz aksini <code class="language-plaintext highlighter-rouge">-regex</code> seçeneği ile belirtmediğimiz sürece daha önce kabuk genişletmeleri bölümünde ele aldığımız “wildcards” yaklaşımını kullanıyor. Yani biz -name seçeneğini kullandığımızda isimler aslında “wildcards” kuralları dahilinde değerlendiriliyor.</p>

<p>Örneğin <code class="language-plaintext highlighter-rouge">find -name "*.png"</code>  komutunu kullandığımda, mevcut bulunduğum dizin altında başında herhangi bir karakter olan devamındaki “.png” ifadesi yer alan tüm dosya ve klasörler getiriliyor. Dosya ismi genişletmesinden bahsederken benzer örnekler yapmıştık hatırlarsanız.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>find <span class="nt">-name</span> <span class="s2">"*.png"</span> 
./.cache/thumbnails/large/3ab698ceca6c7925eb3d1b884a26e75d.png
./.cache/thumbnails/large/c338c09e4cee3d0a205c77d2888f0fc0.png
./.cache/thumbnails/large/52e5c5b7a8eaeca56e0bf2634080a8f3.png
./.cache/thumbnails/large/b3fe8ef292b398b5ff2b48953a2dcaa3.png
./.cache/thumbnails/large/601fa98430e31526893c2cd4c497fb77.png
./.cache/thumbnails/large/e0142d1bb7807691d1f3c6fbef0db9d6.png
./.cache/thumbnails/large/4d47671573280bf1e30ef346ecd154ed.png
./.cache/thumbnails/normal/4ef1aeb4f74b05b642089a3fa725f6ff.png
./.cache/thumbnails/normal/fd024d11882b348b20550093e6339f54.png
./.cache/thumbnails/normal/ce9a4aafaf687c2389abce167751da5e.png
./.cache/thumbnails/normal/b229cfc54c3672c84da5bfb87f3c7ec9.png
./.cache/mozilla/firefox/d5n1etpa.default-esr/thumbnails/b8d33cbd34677070b8b70079044c40aa.png
./.cache/sessions/thumbs-taylan:0/Default.png
./Pictures/Screenshot_2023-05-30_10_28_23.png
./Pictures/Screenshot_2023-05-24_11_11_16.png
./Pictures/Screenshot_2022-07-03_06_45_05.png
./Pictures/Screenshot_2023-05-30_13_21_21.png
./Pictures/Screenshot_2022-07-03_06_45_04.png
./Pictures/Screenshot_2022-07-03_06_45_03.png
./Pictures/Screenshot_2022-06-30_03_23_40.png
./Pictures/Screenshot_2023-06-17_06_27_08.png
./Pictures/Screenshot_2023-05-30_10_28_26.png
./Pictures/Screenshot_2023-05-30_10_28_19.png
./Pictures/Screenshot_2022-06-17_13_15_28.png
./Pictures/Screenshot_2022-07-03_06_45_02.png
./Pictures/Screenshot_2022-06-17_13_15_26.png
./Pictures/Screenshot_2023-05-28_10_42_36.png
./Pictures/Screenshot_2022-07-03_06_45_24.png
</code></pre></div></div>

<p>Eğer buradaki “<code class="language-plaintext highlighter-rouge">*.png</code>” ifadesi wildcards olarak ele alınmıyor olsaydı bu çıktıyı alamayacaktık. Denemek için aynı ifadeyi bu kez <code class="language-plaintext highlighter-rouge">-regex</code> seçeneği ile deneyelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>find <span class="nt">-name</span> <span class="s2">"*.png"</span> 

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="err">$</span>
</code></pre></div></div>

<p>Bakın herhangi bir çıktı alamadık çünkü regex kuralları gereği yıldız işareti kendisinden önceki karakteri sıfır veya daha fazla kez tekrar ediyor. Fakat burada yıldız karakterinden önce bir karakter bulunmadığı için regex kurallarına göre tekrar eden bir örüntü tanımlaması da yapılmamış oluyor. Regex ile bu filtrelemeyi yapmak için “<code class="language-plaintext highlighter-rouge">.*.png</code>” ifadesini kullanabiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>find <span class="nt">-regex</span> <span class="s2">".*.png"</span>                                         
./.cache/thumbnails/large/3ab698ceca6c7925eb3d1b884a26e75d.png
./.cache/thumbnails/large/c338c09e4cee3d0a205c77d2888f0fc0.png
./.cache/thumbnails/large/52e5c5b7a8eaeca56e0bf2634080a8f3.png
./.cache/thumbnails/large/b3fe8ef292b398b5ff2b48953a2dcaa3.png
./.cache/thumbnails/large/601fa98430e31526893c2cd4c497fb77.png
./.cache/thumbnails/large/e0142d1bb7807691d1f3c6fbef0db9d6.png
./.cache/thumbnails/large/4d47671573280bf1e30ef346ecd154ed.png
./.cache/thumbnails/normal/4ef1aeb4f74b05b642089a3fa725f6ff.png
./.cache/thumbnails/normal/fd024d11882b348b20550093e6339f54.png
./.cache/thumbnails/normal/ce9a4aafaf687c2389abce167751da5e.png
./.cache/thumbnails/normal/b229cfc54c3672c84da5bfb87f3c7ec9.png
./.cache/mozilla/firefox/d5n1etpa.default-esr/thumbnails/b8d33cbd34677070b8b70079044c40aa.png
./.cache/sessions/thumbs-taylan:0/Default.png
./Pictures/Screenshot_2023-05-30_10_28_23.png
./Pictures/Screenshot_2023-05-24_11_11_16.png
./Pictures/Screenshot_2022-07-03_06_45_05.png
./Pictures/Screenshot_2023-05-30_13_21_21.png
./Pictures/Screenshot_2022-07-03_06_45_04.png
./Pictures/Screenshot_2022-07-03_06_45_03.png
./Pictures/Screenshot_2022-06-30_03_23_40.png
./Pictures/Screenshot_2023-06-17_06_27_08.png
./Pictures/Screenshot_2023-05-30_10_28_26.png
./Pictures/Screenshot_2023-05-30_10_28_19.png
./Pictures/Screenshot_2022-06-17_13_15_28.png
./Pictures/Screenshot_2022-07-03_06_45_02.png
./Pictures/Screenshot_2022-06-17_13_15_26.png
./Pictures/Screenshot_2023-05-28_10_42_36.png
./Pictures/Screenshot_2022-07-03_06_45_24.png
</code></pre></div></div>

<p>Bakın bu kez “.png” uzantılı dosyaları bulabildik. Çünkü yıldız işaretinden önce kullandığımız nokta işareti herhangi bir tek karakteri temsil ediyor, dolayısıyla yıldız işareti de sıfır veya daha fazla sayıda herhangi bir karakteri barındıran ifadeleri kapsamış oluyor.</p>

<p><strong>Wildcards ve Regex farkını özetleyecek olursak;</strong></p>

<p><strong>Dosya ismi genişletmesi kuralına göre yıldız karakteri:</strong> sıfır veya sıfırdan daha fazla sayıda herhangi bir karakter ile eşleşebiliyor.</p>

<p><strong>Regex kuralına göre yıldız karakteri:</strong> kendisinden önceki karakteri sıfır veya daha fazla sayıda tekrar eden örüntüler ile eşleşebiliyor.</p>

<p>Aldığımız çıktılardaki değişimler de tam olarak bu farklardan kaynaklanıyor.</p>

<p>Örnekler üzerinden bizzat teyit ettiğimiz gibi biz aksini <code class="language-plaintext highlighter-rouge">-regex</code> seçeneği ile belirtmediğimiz sürece <code class="language-plaintext highlighter-rouge">-name</code> seçeneği wildcards kuralları dahilinde filtreleme yapılmasını sağlıyor.</p>

<p>Tamamdır, benim <code class="language-plaintext highlighter-rouge">find</code> komutu hakkında bahsetmek istediğim tüm temel bilgiler bu şekilde. Tabii ki yardım sayfasından da görebileceğimiz gibi aslında <code class="language-plaintext highlighter-rouge">find</code> aracının çok daha fazla özelliği mevcut ancak temel seviye için ilk aşamada bunların hepsi fazla gelebilir. Ayrıca tüm seçeneklere sürekli ihtiyacınız da olmayacak. İhtiyaç duydukça yardım sayfalarını açıp bakmakta özgürsünüz.</p>

<p>Ben şimdi araştırma yapma konusunda bir diğer alternatifimiz olan <code class="language-plaintext highlighter-rouge">locate</code> aracından bahsederek devam etmek istiyorum.</p>

<h1 id="locate">locate</h1>

<p><code class="language-plaintext highlighter-rouge">locate</code> komutu sayesinde sistemdeki dosya ve dizinleri isimleriyle araştırabiliyoruz.</p>

<p><code class="language-plaintext highlighter-rouge">locate</code> komutu daha önce ele aldığımız <code class="language-plaintext highlighter-rouge">find</code> aracından farklı olarak araştırma işlemi sırasında tüm dosya sistemine değil daha önceden oluşturulmuş veri tabanını kullanıyor. Bu sayede veri tabanı üzerinden yaptığımız araştırmada, <code class="language-plaintext highlighter-rouge">find</code> aracından çok daha hızlı şekilde sonuç verebiliyor.</p>

<p>Aracımızın en temel kullanımı <code class="language-plaintext highlighter-rouge">locate aranacak-isim</code> şeklinde. Fakat dediğim gibi <code class="language-plaintext highlighter-rouge">locate</code> aracı kendisine ait olan veritabanı üzerinden araştırma yaptığı için araştırmalarımız sırasında daha sağlıklı çıktılar elde edebilmek adına bu veritabanını güncellememiz gerekiyor.</p>

<p>Ben hemen test etmek için bir önceki derste <code class="language-plaintext highlighter-rouge">find</code> aracıyla bulmak için oluşturduğum farklı konumlardaki “<strong><em>bulbeni</em></strong>” isimli dosya ve klasörleri <code class="language-plaintext highlighter-rouge">locate bulbeni</code> komutuyla sorgulamak istiyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>locate bulbeni
┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="err">$</span>
</code></pre></div></div>

<p>Bakın herhangi bir çıktı almadık. Biz bu dosya ve klasörü yeni oluşturduğumuz için <code class="language-plaintext highlighter-rouge">locate</code> aracının kullandığı veritabanına bu dosya ve klasörün dizin adresi eklenmedi. Dolayısıyla bu isimde bir eşleşme olmadı.</p>

<h3 id="locate-veritabanını-güncellemek--updatedb">locate Veritabanını Güncellemek | <code class="language-plaintext highlighter-rouge">updatedb</code></h3>

<p><code class="language-plaintext highlighter-rouge">locate</code> veritabanını güncellemek için <code class="language-plaintext highlighter-rouge">sudo updatedb</code> şeklinde komutumuzu girebiliriz. İşlemi yetkili olarak gerçekleştirdiğimiz için parolamızı girip anlayamamız gerek.  Ayrıca yeni dizinlerin eklenmesini de bir süre beklememiz gerek.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">sudo </span>updatedb
<span class="o">[</span><span class="nb">sudo</span><span class="o">]</span> password <span class="k">for </span>taylan:
┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="err">$</span>
</code></pre></div></div>

<p>Şimdi dosya sistemindeki en son değişikliklerin veritabanına eklenmiş olması gerekiyor. Tekrar etmek için <code class="language-plaintext highlighter-rouge">locate bulbeni</code> şeklinde komutumuzu girebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>locate bulbeni
/home/taylan/Documents/bulbeni
/home/taylan/Pictures/bulbeni

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="err">$</span>
</code></pre></div></div>

<p>Bakın bu kez anında aradığım kelimeyle eşleşen dosya ve dizinlerin adresi konsola bastırıldı. Bizzat sizin de deneyimleyebileceğiniz gibi <code class="language-plaintext highlighter-rouge">locate</code> aracı hızlı çalışıyor olmasına rağmen, veritabanı <code class="language-plaintext highlighter-rouge">updatedb</code> komutu ile güncellenmediyse sistemde mevcut olan yeni dosya ve dizinleri bulamıyor. Dolayısıyla <code class="language-plaintext highlighter-rouge">locate</code> aracını kullanmadan önce sağlıklı çıktılar almak istiyorsanız mutlaka <code class="language-plaintext highlighter-rouge">updatedb</code> komutuyla güncelleme yapın. Normalde her gün düzenli olarak bu veritabanı otomatik olarak güncelleniyor ancak dediğim gibi kullanmadan önce stabil çıktılar istiyorsanız <code class="language-plaintext highlighter-rouge">updatedb</code> komutunu çalıştırmanız şart.</p>

<h3 id="harf-duyarlılığını-kaldırmak">Harf Duyarlılığını Kaldırmak</h3>

<p>Eğer aradığınız dosya isminde küçük büyük harf duyarlığının görmezden gelinmesini isterseniz komutunuza <code class="language-plaintext highlighter-rouge">i</code> seçeneğini de ekleyebilirsiniz.</p>

<p>Ben denemek için <code class="language-plaintext highlighter-rouge">locate ABC</code> şeklinde yazıp içerisinde tamamı büyük harflerden oluşan <strong>ABC</strong> karakterlerini barından dosya ve klasör isimlerini listelemek istiyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>locate ABC                                                   
/home/taylan/ABC
/home/taylan/.cache/mozilla/firefox/d5n1etpa.default-esr/cache2/entries/1F001ABC732598300E8297AC686A75B32E5186EB
</code></pre></div></div>

<p>Bakın buradaki çıktıların hepsinde yalnızca tamamı büyük olan ABC ifadesi geçiyor. Eğer küçük büyük harf duyarlılığını kaldırmak istersek komutumuzu tekrar çağırıp <code class="language-plaintext highlighter-rouge">i</code> seçeneğini ekleyebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>locate <span class="nt">-i</span> ABC
/home/taylan/ABC
/home/taylan/AbC
/home/taylan/aBc
/home/taylan/abc
/home/taylan/.cache/go-build/0d/0d0abc24b077b8fe4a2db64ca931edc2ed3107a8d4c35f0e230f762e70514359-a
</code></pre></div></div>

<p class="mavi"><strong>Not:</strong> Çıktılar kısaltılarak verilmiştir.</p>

<p>Bakın bu kez küçük büyük harf fark etmeksizin tüm dosya ve klasörler listelenmiş oldu.</p>

<h3 id="eşleşme-sayısını-öğrenmek">Eşleşme Sayısını Öğrenmek</h3>

<p>Kaç eşleşme olduğun saymak istersek “<strong>c</strong>ount” yani “saymak” ifadesinin kısaltmasından gelen <code class="language-plaintext highlighter-rouge">c</code> seçeneğini ekleyebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>locate <span class="nt">-ic</span> ABC                                               
142

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>locate <span class="nt">-c</span> ABC                                           
17
</code></pre></div></div>

<p>Gördüğünüz gibi harf duyarlılığı olamadan arma yaptığımızda 142 eşleşme olurken, harf duyarlılığı varken yalnızca 17 eşleşme bulunmuş.</p>

<h3 id="locate-üzerinde-regex-kullanımı">locate Üzerinde Regex Kullanımı</h3>

<p><code class="language-plaintext highlighter-rouge">locate</code> aracında regex kullanmak istediğimizde bunu özellikle <code class="language-plaintext highlighter-rouge">—regex</code> seçeneğiyle belirtmemiz gerekiyor. Ben denemek için öncelikle <code class="language-plaintext highlighter-rouge">locate "(\.rar|\.zip)”</code> şeklinde regex tanımıyla eşleşme sağlamak üzere komutumu giriyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>locate <span class="s2">"(</span><span class="se">\.</span><span class="s2">rar|</span><span class="se">\.</span><span class="s2">zip)"</span>

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="err">$</span>
</code></pre></div></div>

<p>Bakın herhangi bir çıktı almadık çünkü regex çalışmadı. Bu girmiş olduğumuz tanımın özellikle genişletilmiş regex kuralları dahilinde değerlendirilmesi için <code class="language-plaintext highlighter-rouge">—regex</code> seçeneğini eklememiz gerekiyor.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>locate <span class="nt">--regex</span> <span class="s2">"(</span><span class="se">\.</span><span class="s2">rar|</span><span class="se">\.</span><span class="s2">zip)"</span>                               
/home/taylan/Downloads/linux.zip
/usr/lib/jvm/java-11-openjdk-amd64/legal/jdk.zipfs
/usr/lib/jvm/java-11-openjdk-amd64/legal/jdk.zipfs/ASSEMBLY_EXCEPTION
/usr/share/exploitdb/exploits/windows/remote/17419.zip
/usr/share/icons/Flat-Remix-Blue-Dark/mimetypes/scalable/application-vnd.rar.svg
/usr/share/mime/application/vnd.rar.xml
/usr/share/powershell-empire/empire/server/csharp/Covenant/Data/EmbeddedResources/Lib.zip
/usr/share/powershell-empire/empire/server/data/misc/python_modules/keyboard.zip
/usr/share/powershell-empire/empire/server/data/misc/python_modules/mss.zip
/usr/share/set/src/teensy/x10/libraries.zip
</code></pre></div></div>

<p>Bakın bu kez tam olarak isminin herhangi bir noktasında “.rar” veya “.zip” geçen tüm içerikler bastırılmış oldu. Ayrıca mesela <code class="language-plaintext highlighter-rouge">locate —help</code> komutuyla bir bakacak olursak:</p>

<p><img src="https://superua1.github.io//egitim/metin/23.png" alt="23.png" class="responsive img-zoomable" /></p>

<p>Bakın genişletilmiş regex kuralları için <code class="language-plaintext highlighter-rouge">—regex</code> kullanırken, <strong>basit regex</strong> kuralları için de <code class="language-plaintext highlighter-rouge">-r</code> veya <code class="language-plaintext highlighter-rouge">—regexp</code> seçeneğini kullanabileceğimiz belirtilmiş. Ben aynı örneği basit regex üzerinden denemek istiyorum</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span>locate <span class="nt">-r</span> <span class="s2">"(</span><span class="se">\.</span><span class="s2">rar</span><span class="se">\|\.</span><span class="s2">zip)"</span>                            

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="err">$</span>
</code></pre></div></div>

<p>Komutu doğru girmiş olmama karşın herhangi bir çıktı almadım. Bunun sebebi <code class="language-plaintext highlighter-rouge">locate</code> aracının yalnızca Posix regex kurallarını destekliyor olması. Posix basit regex tanımında <code class="language-plaintext highlighter-rouge">|</code> metakarakteri bulunmadığı için locate aracını bu karakteri tanımadı. Dolayıısyla bir eşleşme de sağlanamadı. İşte tıpkı bu örneğimizde gördüğümüz gibi araçların regex kurallarını tanıma ve işleme noktasında bu gibi farklara sahip olabileceğinin farkında olmanız gerekiyor.</p>

<p>Tamamdır en nihayetinde benim <code class="language-plaintext highlighter-rouge">locate</code> aracı hakkında bahsetmek istediklerim bunlar. Son olarak <code class="language-plaintext highlighter-rouge">locate</code> ile <code class="language-plaintext highlighter-rouge">find</code> arasındaki farkı vurgulamak istiyorum.</p>

<h3 id="locate-ve-find-arasındaki-fark"><code class="language-plaintext highlighter-rouge">locate</code> ve <code class="language-plaintext highlighter-rouge">find</code> Arasındaki Fark</h3>

<p><code class="language-plaintext highlighter-rouge">find</code> komutu ile dosyaları özniteliklerine göre filtreleyebildiğiniz için çok daha fazla seçeneğe sahibiz. Zaten <code class="language-plaintext highlighter-rouge">find</code> komutunu ele alırken dosyaların çeşitli özelliklerine göre nasıl filtreleme yapabileceğimizi ele aldık. <code class="language-plaintext highlighter-rouge">locate</code> komutu ise yalnızca kendi veritabanındaki dosya isimleri ile eşleşme var mı diye kontrol ettiği için, <code class="language-plaintext highlighter-rouge">find</code> komutu ile kullanabileceğiniz dosya özelliklerini filtreleme gibi işlevleri e aracında kullanamazsınız.</p>

<p>Yalnızca dosya isimleri üzerinden hızlıca araştırma yapmak istiyorsanız <code class="language-plaintext highlighter-rouge">locate</code> aracını kullanabilirsiniz. Tabii ki araştırmadan önce <code class="language-plaintext highlighter-rouge">updatedb</code> komutuyla veritabanını güncellemeyi de unutmamız gerekiyor.</p>

<p>Eğer o anda sistemdeki spesifik bir dosya veya klasör hakkında araştırma yapmak istiyorsanız da <code class="language-plaintext highlighter-rouge">find</code> aracını kullanabilirsiniz. <code class="language-plaintext highlighter-rouge">find</code> aracı mevcut dosya sistemi üzerinde araştırma yaptığı için <code class="language-plaintext highlighter-rouge">locate</code> gibi bir statik veriler ile çalışmadan en güncel bilgileri filtreli şekilde sunabiliyor.</p>

<h1 id="cut">cut</h1>

<p><code class="language-plaintext highlighter-rouge">cut</code> komutu, satırların istenilen bölümlerinin kesilmesini sağlıyor. Zaten isminde geçen “cut” ifadesi Türkçe olarak “kesmek” anlamına geliyor. Ben örnekler sırasında basit bir metin dosyası üzerinde çalışıyor olacağım ancak siz okunabilir formatta olan tüm metinsel verilerinizi <code class="language-plaintext highlighter-rouge">cut</code> komutu ile kesip biçimlendirebilirsiniz.</p>

<p>Öncelikle dosya içeriğini <code class="language-plaintext highlighter-rouge">cat</code> komutu ile görüntüleyelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat </span>metin
satir1sutun1 satir1sutun2 satir1sutun3 satir1sutun4 satir1sutun5
satir2sutun1 satir2sutun2 satir2sutun3 satir2sutun4 satir2sutun5
satir3sutun1 satir3sutun2 satir3sutun3 satir3sutun4 satir3sutun5
satir4sutun1 satir4sutun2 satir4sutun3 satir4sutun4 satir4sutun5
satir5sutun1 satir5sutun2 satir5sutun3 satir5sutun4 satir5sutun5
satir6sutun1 satir6sutun2 satir6sutun3 satir6sutun4 satir6sutun5
satir7sutun1 satir7sutun2 satir7sutun3 satir7sutun4 satir7sutun5
satir8sutun1 satir8sutun2 satir8sutun3 satir8sutun4 satir8sutun5
</code></pre></div></div>

<p>Şimdi <code class="language-plaintext highlighter-rouge">cut</code> aracının kullanımına geçecek olursak, örneğin ben bu dosyadaki tüm sütunları değil de yalnızca 1 ila 3. sütunları istiyorsam <code class="language-plaintext highlighter-rouge">cut</code> komutuna bu durumu izah edebilirim. Bu işlem için <code class="language-plaintext highlighter-rouge">cut</code> komutuna bu verileri neye bakarak ayıracağını bildirmemiz gerekiyor. Tıpkı kabuğun komutları yorumlaması gibi <code class="language-plaintext highlighter-rouge">cut</code> aracı da elindeki verilerin hangi parçalardan oluştuğunu anlamak için bir “delimiter” yani “sınırlayıcı” karakter belirtmemizi istiyor. Bunun için <code class="language-plaintext highlighter-rouge">cut</code> komutundan sonra <code class="language-plaintext highlighter-rouge">-d</code> seçeneğinin hemen ardından sınırlayıcı karakteri yazmamız gerek.</p>

<p>Örneğin benim dosyamda boşluk karakteri sütunları birbirinden ayırdığı için ben tırnak için <code class="language-plaintext highlighter-rouge">“ “</code> boşluk karakterinin sınırlayıcı olduğunu belirteceğim. Şimdi son olarak hangi sütunların, yani aslında hangi bölümlerin kalmasını istiyorsak, bunu “fields” yani “alanlar-bölümler” seçeneğinin kısalması olan <code class="language-plaintext highlighter-rouge">-f</code> seçeneğinin hemen ardından belirtebiliyoruz. Ben 1 ila 3. bölümleri almak istediğim için <code class="language-plaintext highlighter-rouge">1-3</code> şeklinde yazıyorum ve işlenecek verilerin bulunduğu dosyanın ismini de ekleyip komutumu onaylıyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cut</span> <span class="nt">-d</span> <span class="s2">" "</span> <span class="nt">-f</span> 1-3 metin
satir1sutun1 satir1sutun2 satir1sutun3
satir2sutun1 satir2sutun2 satir2sutun3
satir3sutun1 satir3sutun2 satir3sutun3
satir4sutun1 satir4sutun2 satir4sutun3
satir5sutun1 satir5sutun2 satir5sutun3
satir6sutun1 satir6sutun2 satir6sutun3
satir7sutun1 satir7sutun2 satir7sutun3
satir8sutun1 satir8sutun2 satir8sutun3
</code></pre></div></div>

<p>Bakın yalnızca 1. den 3. bölüme kadar olan sütunlar bastırıldı. <code class="language-plaintext highlighter-rouge">cut</code> komutu ona söylediğimiz gibi dosya içeriğini okuyup dosyadaki boşluk karakterinin bulunduğu tüm bölümleri birbirinden ayırdı ve bizim belirttiğimiz bölümleri de filtreleyip bize sundu. Burada önemli olan, bölümleri birbirinden ayıran boşluk karakterinin <code class="language-plaintext highlighter-rouge">cut</code> komutuna bildirilmesi. Hatta bu durumda emin olmak için ben aynı içeriğin boşluk yerine virgüllerle ayrılmış sürümü üzerinden <code class="language-plaintext highlighter-rouge">cut</code> komutunu tekrar kullanmak istiyorum. Öncelikle dosya içeriğini kontrol etmek için <code class="language-plaintext highlighter-rouge">cat</code> komutu ile virgüllü dosyayı okuyalım.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat </span>metin2
satir1sutun1<span class="p">;</span>satir1sutun2<span class="p">;</span>satir1sutun3<span class="p">;</span>satir1sutun4<span class="p">;</span>satir1sutun5
satir2sutun1<span class="p">;</span>satir2sutun2<span class="p">;</span>satir2sutun3<span class="p">;</span>satir2sutun4<span class="p">;</span>satir2sutun5
satir3sutun1<span class="p">;</span>satir3sutun2<span class="p">;</span>satir3sutun3<span class="p">;</span>satir3sutun4<span class="p">;</span>satir3sutun5
satir4sutun1<span class="p">;</span>satir4sutun2<span class="p">;</span>satir4sutun3<span class="p">;</span>satir4sutun4<span class="p">;</span>satir4sutun5
satir5sutun1<span class="p">;</span>satir5sutun2<span class="p">;</span>satir5sutun3<span class="p">;</span>satir5sutun4<span class="p">;</span>satir5sutun5
satir6sutun1<span class="p">;</span>satir6sutun2<span class="p">;</span>satir6sutun3<span class="p">;</span>satir6sutun4<span class="p">;</span>satir6sutun5
satir7sutun1<span class="p">;</span>satir7sutun2<span class="p">;</span>satir7sutun3<span class="p">;</span>satir7sutun4<span class="p">;</span>satir7sutun5
satir8sutun1<span class="p">;</span>satir8sutun2<span class="p">;</span>satir8sutun3<span class="p">;</span>satir8sutun4<span class="p">;</span>satir8sutun5
</code></pre></div></div>

<p>Bakın buradaki tüm bölümler virgülle birbirinden ayrılmış durumda. Şimdi biz bu verileri kesmek istersek virgüllerin sınırlayıcı değer olduğunu özellikle belirtmemiz gerekiyor. Bu durumu bizzat teyit etmek için virgülü belirtmeden önceki komutumuzu yani boşluk karakterini sınırlayıcı olarak belirttiğimiz komutumuzu bu dosya üzerinde de uygulamayı deneyebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cut</span> <span class="nt">-d</span> <span class="s2">" "</span> <span class="nt">-f</span> 1-3 metin2                                    
satir1sutun1<span class="p">;</span>satir1sutun2<span class="p">;</span>satir1sutun3<span class="p">;</span>satir1sutun4<span class="p">;</span>satir1sutun5
satir2sutun1<span class="p">;</span>satir2sutun2<span class="p">;</span>satir2sutun3<span class="p">;</span>satir2sutun4<span class="p">;</span>satir2sutun5
satir3sutun1<span class="p">;</span>satir3sutun2<span class="p">;</span>satir3sutun3<span class="p">;</span>satir3sutun4<span class="p">;</span>satir3sutun5
satir4sutun1<span class="p">;</span>satir4sutun2<span class="p">;</span>satir4sutun3<span class="p">;</span>satir4sutun4<span class="p">;</span>satir4sutun5
satir5sutun1<span class="p">;</span>satir5sutun2<span class="p">;</span>satir5sutun3<span class="p">;</span>satir5sutun4<span class="p">;</span>satir5sutun5
satir6sutun1<span class="p">;</span>satir6sutun2<span class="p">;</span>satir6sutun3<span class="p">;</span>satir6sutun4<span class="p">;</span>satir6sutun5
satir7sutun1<span class="p">;</span>satir7sutun2<span class="p">;</span>satir7sutun3<span class="p">;</span>satir7sutun4<span class="p">;</span>satir7sutun5
satir8sutun1<span class="p">;</span>satir8sutun2<span class="p">;</span>satir8sutun3<span class="p">;</span>satir8sutun4<span class="p">;</span>satir8sutun5
</code></pre></div></div>

<p>Bakın herhangi bir kesme işlemi uygulanmadı. Şimdi buradaki “delimiter” yani “sınırlayıcı” karakteri olarak tırnak içine noktalı virgül karakterini ekleyip komutumuzu bu şekilde çalıştıralım.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cut</span> <span class="nt">-d</span> <span class="s2">";"</span> <span class="nt">-f</span> 1-3 metin2                                      
satir1sutun1<span class="p">;</span>satir1sutun2<span class="p">;</span>satir1sutun3
satir2sutun1<span class="p">;</span>satir2sutun2<span class="p">;</span>satir2sutun3
satir3sutun1<span class="p">;</span>satir3sutun2<span class="p">;</span>satir3sutun3
satir4sutun1<span class="p">;</span>satir4sutun2<span class="p">;</span>satir4sutun3
satir5sutun1<span class="p">;</span>satir5sutun2<span class="p">;</span>satir5sutun3
satir6sutun1<span class="p">;</span>satir6sutun2<span class="p">;</span>satir6sutun3
satir7sutun1<span class="p">;</span>satir7sutun2<span class="p">;</span>satir7sutun3
satir8sutun1<span class="p">;</span>satir8sutun2<span class="p">;</span>satir8sutun3
</code></pre></div></div>

<p>Bakın noktalı virgül karakteri sayesinde birbirinden ayrıştırılan bölümler <code class="language-plaintext highlighter-rouge">cut</code> komutu tarafından işlenip tam olarak istediğim bölüm aralığı sunuldu. Bu örnek üzerinden de görebildiğimiz gibi elimizdeki verinin türüne göre sınırlayıcı olan değeri doğru şekilde belirtmezsek, kesme işlemi de uygulanamıyor.</p>

<p>Eğer bir aralığı değil de spesifik olarak listelemek istediğiniz sütunlar varsa -f seçeneğinden sonra virgülle ayırarak belirtebilirsiniz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cut</span> <span class="nt">-d</span> <span class="s2">";"</span> <span class="nt">-f</span> 1,4 metin2                                    
satir1sutun1<span class="p">;</span>satir1sutun4
satir2sutun1<span class="p">;</span>satir2sutun4
satir3sutun1<span class="p">;</span>satir3sutun4
satir4sutun1<span class="p">;</span>satir4sutun4
satir5sutun1<span class="p">;</span>satir5sutun4
satir6sutun1<span class="p">;</span>satir6sutun4
satir7sutun1<span class="p">;</span>satir7sutun4
satir8sutun1<span class="p">;</span>satir8sutun4

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cut</span> <span class="nt">-d</span> <span class="s2">";"</span> <span class="nt">-f</span> 4 metin2                                      
satir1sutun4
satir2sutun4
satir3sutun4
satir4sutun4
satir5sutun4
satir6sutun4
satir7sutun4
satir8sutun4
</code></pre></div></div>

<p>Bakın tam olarak belirttiğim bölümler karşıma getirildi.</p>

<p>Aslında <code class="language-plaintext highlighter-rouge">cut</code> komutun başka seçenekleri de bulunuyor ancak diğer seçeneklerin detaylarına girmeyi düşünmüyorum. Zaten temel çalışma yapısını anladığınız için <code class="language-plaintext highlighter-rouge">cut —help</code> komutu ile elde edeceğiniz buradaki tüm açıklamaları rahatlıkla anlayıp uygulayarak test edebilirsiniz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cut</span> <span class="nt">--help</span>
Usage: <span class="nb">cut </span>OPTION... <span class="o">[</span>FILE]...                                   
Print selected parts of lines from each FILE to standard output.         
                                                                         
With no FILE, or when FILE is -, <span class="nb">read </span>standard input.                              
                                                                                   
Mandatory arguments to long options are mandatory <span class="k">for </span>short options too.           
  <span class="nt">-b</span>, <span class="nt">--bytes</span><span class="o">=</span>LIST        <span class="k">select </span>only these bytes                                        
  <span class="nt">-c</span>, <span class="nt">--characters</span><span class="o">=</span>LIST   <span class="k">select </span>only these characters                                   
  <span class="nt">-d</span>, <span class="nt">--delimiter</span><span class="o">=</span>DELIM   use DELIM instead of TAB <span class="k">for </span>field delimiter                          
  <span class="nt">-f</span>, <span class="nt">--fields</span><span class="o">=</span>LIST       <span class="k">select </span>only these fields<span class="p">;</span>  also print any line                        
                            that contains no delimiter character, unless                        
                            the <span class="nt">-s</span> option is specified                                          
  <span class="nt">-n</span>                      <span class="o">(</span>ignored<span class="o">)</span>                                                                     
      <span class="nt">--complement</span>        complement the <span class="nb">set </span>of selected bytes, characters
                            or fields
  <span class="nt">-s</span>, <span class="nt">--only-delimited</span>    <span class="k">do </span>not print lines not containing delimiters
      <span class="nt">--output-delimiter</span><span class="o">=</span>STRING  use STRING as the output delimiter
                            the default is to use the input delimiter
  <span class="nt">-z</span>, <span class="nt">--zero-terminated</span>    line delimiter is NUL, not newline
      <span class="nt">--help</span>     display this <span class="nb">help </span>and <span class="nb">exit</span>
      <span class="nt">--version</span>  output version information and <span class="nb">exit

</span>Use one, and only one of <span class="nt">-b</span>, <span class="nt">-c</span> or <span class="nt">-f</span><span class="nb">.</span>  Each LIST is made up of one
range, or many ranges separated by commas.  Selected input is written
<span class="k">in </span>the same order that it is <span class="nb">read</span>, and is written exactly once.
Each range is one of:

  N     N<span class="s1">'th byte, character or field, counted from 1
  N-    from N'</span>th byte, character or field, to end of line
  N-M   from N<span class="s1">'th to M'</span>th <span class="o">(</span>included<span class="o">)</span> byte, character or field
  <span class="nt">-M</span>    from first to M<span class="s1">'th (included) byte, character or field

GNU coreutils online help: &lt;https://www.gnu.org/software/coreutils/&gt;
Full documentation &lt;https://www.gnu.org/software/coreutils/cut&gt;
or available locally via: info '</span><span class="o">(</span>coreutils<span class="o">)</span> <span class="nb">cut </span>invocation<span class="s1">'
</span></code></pre></div></div>

<p>Örneğin bakın “complement” seçeneği, bizim belirttiğimiz bölümlerin haricindeki bölümleri bastıran bir seçenekmiş. Bu durumu görmek için en son girdiğimiz komutu tekrar girelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cut</span> <span class="nt">-d</span> <span class="s2">";"</span> <span class="nt">-f</span> 1,4 metin2
satir1sutun1<span class="p">;</span>satir1sutun4
satir2sutun1<span class="p">;</span>satir2sutun4
satir3sutun1<span class="p">;</span>satir3sutun4
satir4sutun1<span class="p">;</span>satir4sutun4
satir5sutun1<span class="p">;</span>satir5sutun4
satir6sutun1<span class="p">;</span>satir6sutun4
satir7sutun1<span class="p">;</span>satir7sutun4
satir8sutun1<span class="p">;</span>satir8sutun4

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cut</span> <span class="nt">-d</span> <span class="s2">";"</span> <span class="nt">-f</span> 1,4 metin2 <span class="nt">--complement</span>                                                                
satir1sutun2<span class="p">;</span>satir1sutun3<span class="p">;</span>satir1sutun5
satir2sutun2<span class="p">;</span>satir2sutun3<span class="p">;</span>satir2sutun5
satir3sutun2<span class="p">;</span>satir3sutun3<span class="p">;</span>satir3sutun5
satir4sutun2<span class="p">;</span>satir4sutun3<span class="p">;</span>satir4sutun5
satir5sutun2<span class="p">;</span>satir5sutun3<span class="p">;</span>satir5sutun5
satir6sutun2<span class="p">;</span>satir6sutun3<span class="p">;</span>satir6sutun5
satir7sutun2<span class="p">;</span>satir7sutun3<span class="p">;</span>satir7sutun5
satir8sutun2<span class="p">;</span>satir8sutun3<span class="p">;</span>satir8sutun5
</code></pre></div></div>

<p>Bakın ilk komutta tam olarak belirttiğimiz bölümler bastırılırken, “<code class="language-plaintext highlighter-rouge">—complement</code>” seçeneğini kullandığımızda belirttiğimiz bölümlerin haricindekiler bastırıldı.</p>

<p>İşte bu şekilde sütunları filtrelemek istediğimizde yani istediğimiz sütunları kesmek istediğimizde <code class="language-plaintext highlighter-rouge">cut</code> aracını kullanabiliyoruz. Diğer özellikleri için aynen burda olduğu gibi yardım sayfasına ya da internet üzerindeki harici kaynaklara bakabilirsiniz. Fakat temelde sütunları kesmek için bizim bahsetmiş olduklarımız yeterli.</p>

<h1 id="tr-komutu">tr Komutu</h1>

<p><code class="language-plaintext highlighter-rouge">tr</code> komutunun ismi “<strong>tr</strong>anslate” yani “çevirmek-dönüştürmek” ifadesinden geliyor. Temelde mevcut veriler içindeki karakterleri değiştirmek veya silmek için bu aracımızı kullanabiliyoruz. Küçük ve büyük harf değişimi, tekrar eden karakterlerin silinmesi, özel karakterlerin silinmesi ve bulup değiştirme gibi pek çok işlevi var. Biz temel birkaç işlevinden bahsediyor olacağız.</p>

<p><code class="language-plaintext highlighter-rouge">tr</code> komutu standart girdiden veri okuduğu için pipe ile veri aktarmak en sık tercih edilen kullanım yöntemidir. Ben kolay bir örnek olması için küçük “i” ve küçük “e” karakterlerini büyükleri ile değiştirmek üzere <code class="language-plaintext highlighter-rouge">echo "linux dersleri" | tr "ie" "IE"</code> şeklinde komutumu giriyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"linux dersleri"</span> | <span class="nb">tr</span> <span class="s2">"ie"</span> <span class="s2">"IE"</span>
lInux dErslErI
</code></pre></div></div>

<p>Burada girmiş olduğum argümanların sıralaması çok önemli. Çünkü <code class="language-plaintext highlighter-rouge">tr</code> komutu sıralamaya uyarak yani ilk argümanın ilk karakterini, ikinci argümanın ilk karakteri ile ve ilk argümanın ikinci karakterini de ikinci argümanın ikinci karakteri ile değişecek şekilde işlem yapıyor.</p>

<p>Zaten aldığımız çıktı da, belirtmiş olduğumuz sırlamaya uyuyor. Şimdi sıralamayı değiştirip deneyelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"linux dersleri"</span> | <span class="nb">tr</span> <span class="s2">"ie"</span> <span class="s2">"EI"</span>
lEnux dIrslIrE
</code></pre></div></div>

<p>Bakın bu çıktı da komutta belirttiğim sırlama dahilinde yani küçük “i” için büyük “E” küçük “e” için de büyük “I” karakteri şeklinde oldu.</p>

<p>Örneğin tüm küçük harfleri büyük harflere dönüştürmek istersek aralık belirterek komut girebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"linux dersleri"</span> | <span class="nb">tr</span> <span class="s2">"a-z"</span> <span class="s2">"A-Z"</span>
LINUX DERSLERI
</code></pre></div></div>

<p>Bakın tüm karakterler büyükleri ile otomatik olarak yer değiştirdi.</p>

<p>Ayrıca kullanabileceğimiz bazı özel kalıplar da bulunuyor. Bunları görmek için <code class="language-plaintext highlighter-rouge">tr —help</code> komutunu kullanabiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">tr</span> <span class="nt">--help</span>
Usage: <span class="nb">tr</span> <span class="o">[</span>OPTION]... SET1 <span class="o">[</span>SET2]
Translate, squeeze, and/or delete characters from standard input,
writing to standard output.

  <span class="nt">-c</span>, <span class="nt">-C</span>, <span class="nt">--complement</span>    use the complement of SET1
  <span class="nt">-d</span>, <span class="nt">--delete</span>            delete characters <span class="k">in </span>SET1, <span class="k">do </span>not translate
  <span class="nt">-s</span>, <span class="nt">--squeeze-repeats</span>   replace each sequence of a repeated character
                            that is listed <span class="k">in </span>the last specified SET,
                            with a single occurrence of that character
  <span class="nt">-t</span>, <span class="nt">--truncate-set1</span>     first <span class="nb">truncate </span>SET1 to length of SET2
      <span class="nt">--help</span>     display this <span class="nb">help </span>and <span class="nb">exit</span>
      <span class="nt">--version</span>  output version information and <span class="nb">exit

</span>SETs are specified as strings of characters.  Most represent themselves.
Interpreted sequences are:

  <span class="se">\N</span>NN            character with octal value NNN <span class="o">(</span>1 to 3 octal digits<span class="o">)</span>
  <span class="se">\\</span>              backslash
  <span class="se">\a</span>              audible BEL
  <span class="se">\b</span>              backspace
  <span class="se">\f</span>              form feed
  <span class="se">\n</span>              new line
  <span class="se">\r</span>              <span class="k">return</span>
  <span class="se">\t</span>              horizontal tab
  <span class="se">\v</span>              vertical tab
  CHAR1-CHAR2     all characters from CHAR1 to CHAR2 <span class="k">in </span>ascending order
  <span class="o">[</span>CHAR<span class="k">*</span><span class="o">]</span>         <span class="k">in </span>SET2, copies of CHAR <span class="k">until </span>length of SET1
  <span class="o">[</span>CHAR<span class="k">*</span>REPEAT]   REPEAT copies of CHAR, REPEAT octal <span class="k">if </span>starting with 0
  <span class="o">[</span>:alnum:]       all letters and digits
  <span class="o">[</span>:alpha:]       all letters
  <span class="o">[</span>:blank:]       all horizontal whitespace
  <span class="o">[</span>:cntrl:]       all control characters
  <span class="o">[</span>:digit:]       all digits
  <span class="o">[</span>:graph:]       all printable characters, not including space
  <span class="o">[</span>:lower:]       all lower <span class="k">case</span> letters
  <span class="o">[</span>:print:]       all printable characters, including space
  <span class="o">[</span>:punct:]       all punctuation characters
  <span class="o">[</span>:space:]       all horizontal or vertical whitespace
  <span class="o">[</span>:upper:]       all upper <span class="k">case</span> letters
  <span class="o">[</span>:xdigit:]      all hexadecimal digits
  <span class="o">[=</span><span class="nv">CHAR</span><span class="o">=]</span>        all characters which are equivalent to CHAR
</code></pre></div></div>

<p>Gördüğünüz gibi Linux üzerinde regex kullanımından bahsederken ele aldığımız bazı sembolik ifadeler de dahil, kullanabileceğimiz çeşitli özel karakterler yardım bilgisinde belirtilmiş. Örneğin bakın buradaki <code class="language-plaintext highlighter-rouge">[:lower:]</code> kalıbı küçük harfli olan tüm karakterleri kapsıyor, benzer şekilde <code class="language-plaintext highlighter-rouge">[:upper:]</code> da tüm büyük harfleri kapsıyor. Denemek için gelin bu kalıpları kullanarak küçük harfleri tekrar büyüğe dönüştürelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"linux dersleri"</span> | <span class="nb">tr</span> <span class="o">[</span>:lower:] <span class="o">[</span>:upper:]                                                      
LINUX DERSLERI
</code></pre></div></div>

<p>Gördüğünüz gibi tüm küçük harfli karakterler büyük harfler ile değiştirilmiş oldu. Tabii ki istersek tersi şekilde komut girerek, büyük harflerin küçük harfler ile değiştirilmesini de sağlayabiliriz.  Sizler de bu listeye göz atıp, ihtiyacınız olan kalıpları kolayca kullanabilirsiniz.</p>

<p>Bir örnek daha yapalım ben PATH değişkenin çıktıların yer alan iki nokta karakterini yeni satır karakteri ile değiştirmek istiyorum. Öncelikle standart şekilde nasıl göründüğüne bakmak için <code class="language-plaintext highlighter-rouge">echo $PATH</code> komutu ile değişkeni konsola bastıralım.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>taylan@virtualbox:~/arsiv<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$PATH</span>
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin

</code></pre></div></div>

<p>Bakın PATH yoluna ekli olan her bir dizin birbirinden iki nokta üst üste karakteri ayrılmış. Şimdi bu çıktı bana biraz karışık geldiği için her bir path dizinini yeni bir satırda görmek istiyorum. Bunu yapmak için iki nokta üst üste karakterini yeni satır karakteri ile yani yardım listesinde de görülen <code class="language-plaintext highlighter-rouge">\n</code> karakteri ile değiştirebiliriz. Hemen deneyelim. Ben komutumu <code class="language-plaintext highlighter-rouge">echo $PATH | tr “:” “\n”</code> şeklinde giriyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$PATH</span> | <span class="nb">tr</span> <span class="s2">":"</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span>                                                                            
/usr/local/sbin
/usr/local/bin
/usr/sbin
/usr/bin
/sbin
/bin
/usr/local/games
/usr/games
/home/taylan/Desktop/yeni-dizin
</code></pre></div></div>

<p>Bakın, her bir path dizinini ayrı ayrı satırlarda bastırmayı başardık. Bu şekilde tam istediğim gibi daha okunaklı bir çıktı elde etmiş oldum. Bence bu yaptığımız örnek, <code class="language-plaintext highlighter-rouge">tr</code> aracının kullanımına ve ayrıca yeni satıra geçilmesini sağlayan <code class="language-plaintext highlighter-rouge">\n</code> gibi kalıplara da iyi bir örnek oldu.</p>

<p>Yardım çıktısında yer alan buradaki kalıplar üzerinde pratik yaptığınız zaman zaten kolay hatırlanır isimleri dolayısıyla kolayca anımsayıp bu kalıplardan faydalanabilirsiniz. Ayrıca hatırlamadığınız durumda tabii ki yardım sayfası üzerinden de tekrar öğrenebilirsiniz. Zaten pek çok araç zaten benzer standardı izlediği için zaman içinde bu tür kalıplar aklınızda yer edecektir.</p>

<p>Bu ifadeler dışında biraz da seçeneklerinden bahsedebiliriz.</p>

<h3 id="peş-peşe-tekrar-eden-karakterlerin-sadeleştirilmesi">Peş Peşe Tekrar Eden Karakterlerin Sadeleştirilmesi</h3>

<p>Eğer peş peşe tekrar eden karakterlerden yalnızca bir tane kalmasını istersek, <code class="language-plaintext highlighter-rouge">-s</code> seçeneğini kullanabiliriz. Buradaki <code class="language-plaintext highlighter-rouge">s</code> seçeneği “<strong>s</strong>queeze” yani “sıkmak”, sıkıştırmaktan aklınıza gelebilir. Ben denemek için <a href="http://www.linuxdersleri.net">www.linuxdersleri.net</a> adresindeki “www” karakterlerini teke indirmek istiyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"www.linuxdersleri.net"</span> | <span class="nb">tr</span> <span class="nt">-s</span> <span class="s2">"w"</span>                                                           
w.linuxdersleri.net
</code></pre></div></div>

<p>Bakın “w” karakteri teke düşürüldü.</p>

<p>Hatta istersem bastırılabilir olan tüm tekrar eden karakterlerin otomatik olarak filtrelenmesi için bu tür karakterleri temsil eden <code class="language-plaintext highlighter-rouge">[:graph:]</code> seçeneğini kullanabilirim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"bbu biirrr deneeeme33344 yazısı123"</span> | <span class="nb">tr</span> <span class="nt">-s</span> <span class="o">[</span>:graph:] 
bu bir deneme34 yazısı123
</code></pre></div></div>

<p>Gördüğünüz gibi <code class="language-plaintext highlighter-rouge">[:graph:]</code> seçeneği sayesinde bastırılabilir(boşluk hariç, rakam, harf, sembol gibi) karakterleri kapsayıp, bunlar içinde tekrar edenleri teke düşürmek için de <code class="language-plaintext highlighter-rouge">-s</code> seçeneğini kullanmış olduk.</p>

<p>Yani bu örnek üzerinden de gördüğümüz gibi aslında spesifik olarak belirtmemiz gereken karakterler yoksa, <code class="language-plaintext highlighter-rouge">tr —help</code> komutunun çıktısında yer alan ifadeler ve kalıplar zaten pek çok tanımı karşılıyor. Örneğin yalnızca tekrar eden sayıları mı düzenlemek istiyorsunuz, <code class="language-plaintext highlighter-rouge">[:digit:]</code> tanımı kullanılabilir.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"bbu biirrr deneeeme33344 yazısı123##"</span> | <span class="nb">tr</span> <span class="nt">-s</span> <span class="o">[</span>:digit:]                                       
bbu biirrr deneeeme34 yazısı123##
</code></pre></div></div>

<p>Bakın <code class="language-plaintext highlighter-rouge">[:digit:]</code> kalıbı sayesinde yalnızca peş peşe tekrar eden sayılar teke indirilmiş oldu.</p>

<p>İşte sizler de gerektiğinde yardım sayfasından göz atıp, bu ifadeleri kolayca kullanabilirsiniz.</p>

<p>Her neyse, neticede <code class="language-plaintext highlighter-rouge">s</code> seçeneğinin <strong>art arda tekrar eden</strong> karakterleri teke düşürdüğünü teyit etmiş olduk. Tekrarların peşi sıra gerçekleştiğine dikkat edin.</p>

<h3 id="karakterlerin-silinmesi">Karakterlerin Silinmesi</h3>

<p>Doğrudan karakteri bulup silmek için de <code class="language-plaintext highlighter-rouge">tr</code> aracını kullanmamız mümkün. Bunun için “<code class="language-plaintext highlighter-rouge">d</code>elete” yani “silme” ifadesinin kısaltması olan <code class="language-plaintext highlighter-rouge">d</code> seçeneğini kullanabiliyoruz. Ben denemek için web adresindeki noktaları silmek istiyorum. Tek yapmam gereken <code class="language-plaintext highlighter-rouge">tr</code> aracının <code class="language-plaintext highlighter-rouge">-d</code> seçeneğini kullandıktan sonra silinmesini istediğim karakteri belirtmek.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo </span>www.linuxdersleri.net | <span class="nb">tr</span> <span class="nt">-d</span> <span class="s2">"."</span>
wwwlinuxderslerinet
</code></pre></div></div>

<p>Bakın gördüğünüz gibi yalnızca belirttiğim şekilde nokta karakterleri silinmiş. Bu şekilde metin içinde silinmesini istediğiniz tüm karakterleri belirtebiliyoruz. Fakat burada yazdığını karakterlerin yalnızca tek bir karakteri işaret ettiğini unutmayın lütfen. Yani örneğin ben aynı komutta <code class="language-plaintext highlighter-rouge">-d</code> seçeneğinden sonra “<code class="language-plaintext highlighter-rouge">de</code>” yazarsam, “d” ve “e” karakterinin hepsi bulunup silinecek. Yalnızca bütünleşik olan “de” kalıbını silmeyecek yani. Komutumuzu onaylayalım.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo </span>www.linuxdersleri.net | <span class="nb">tr</span> <span class="nt">-d</span> <span class="s2">"de"</span>                                                            
www.linuxrslri.nt
</code></pre></div></div>

<p>Bakın yazdığım tüm karakterler ayrı ayrı ele alındı ve eşleşen karakterler kaldırıldı. Yani doğrudan “de” ifadesini aranmadı, “d” ve “e” karakterleri ayrı ayrı aranıp bulunduğunda teker teker silindiler.</p>

<p>Eğer bitişik yapıdaki birden fazla karakteri kapsayacak değişiklikler istiyorsanız ileride ele alacağımız <code class="language-plaintext highlighter-rouge">sed</code> veya <code class="language-plaintext highlighter-rouge">awk</code> gibi araçlardan yararlanabilirsiniz. <code class="language-plaintext highlighter-rouge">tr</code> aracı yalnızca bir karakter ile başka bir tanesini değiştirme silme veya tekrar edenleri sadeleştirmek gibi işler için kullanılıyor.</p>

<p>Ayrıca son olarak, örneklerimiz sırasında verileri hep pipe üzerinden <code class="language-plaintext highlighter-rouge">tr</code> aracına yönlendirdik. İstersek yönlendirme operatörü ile de <code class="language-plaintext highlighter-rouge">tr</code> aracının standart girdisine veri aktarmamzı da mümkün. Ben denemek için echo “www.deneme…com” » site komutuyla dosyanın içerisine buradaki ifadeyi ekliyorum. Tamamdır. Şimdi tr aracına bu dosyayı girdi olarak yönlendirelim.</p>

<p>Ben peş peşe tekrar eden karakterlerin <code class="language-plaintext highlighter-rouge">tr</code> komutu ile teke düşürülmesi için yönlendirme operatörü ile dosyayı <code class="language-plaintext highlighter-rouge">tr</code> komutuna aktaracağım.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"bbu biirrr deneeeme33344 yazısı123##"</span> <span class="o">&gt;</span> <span class="nb">test</span>

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">tr</span> <span class="nt">-s</span> <span class="o">[</span>:graph:] &lt; <span class="nb">test
</span>bu bir deneme34 yazısı123#
</code></pre></div></div>

<p>Bakın gördüğünüz gibi yönlendirmiş olduğumuz dosyadaki veri <code class="language-plaintext highlighter-rouge">tr</code> komutu tarafından okunup, filtrelenmiş oldu. Yani bizzat teyit ettiğimiz gibi <code class="language-plaintext highlighter-rouge">tr</code> komutunu yalnızca pipe ile kullanmak zorunda değiliz. <code class="language-plaintext highlighter-rouge">tr</code> aracı verilerini standart girdiden okuyor. Dolayısıyla standart girdisine verileri yönlendirdiğimiz sürece <code class="language-plaintext highlighter-rouge">tr</code> aracı ilgili verileri işleyip çıktıları standart çıktıya yani biz aksini belirtmediğimiz sürece konsolumuza yönlendiriyor olacak.</p>

<p>Eğer bu çıktıları bir dosyaya kaydetmek istersek örneğin aynı komutun sonuna <code class="language-plaintext highlighter-rouge">&gt; kaydet</code> şeklinde yazabiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">tr</span> <span class="nt">-s</span> <span class="o">[</span>:graph:] &lt; <span class="nb">test</span> <span class="o">&gt;</span> kaydet

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat </span>kaydet                                                                                          
bu bir deneme34 yazısı123#
</code></pre></div></div>

<p>Bakın çıktıların “<strong><em>kaydet</em></strong>” isimli dosyaya sorunsuzca yönlendirilmiş olduğunu <code class="language-plaintext highlighter-rouge">cat</code> komutu ile de teyit etmiş olduk.</p>

<p>Benim <code class="language-plaintext highlighter-rouge">tr</code> aracı hakkında bahsetmek istediklerim bu kadar.</p>

<p class="mavi"><strong>Not:</strong> Temel eğitim kapsamına uygun dahil edilebilmesi için <code class="language-plaintext highlighter-rouge">sed</code> ve <code class="language-plaintext highlighter-rouge">awk</code> araçlarının açıklamaları nihai forma ulaşmamıştır. Yakın bir tarihte bu açıklamalar tamamlanmak üzere düzenlenecektir. Şimdilik bu araçların açıklamalarını atlayabilirsiniz.</p>

<h1 id="sed">sed</h1>

<p><code class="language-plaintext highlighter-rouge">sed</code> komutu “<strong>s</strong>tream <strong>ed</strong>itor” ifadesinin kısaltmasından gelen metin manipülasyon aracıdır. Daha önce, “her şey bir dosyadadır, her şey bir bayt akışıdır” demiştik. İşte “stream” ifadesindeki “akış-aktarım” ifadesi de bu bayt akışının manipülasyonu dolayısıyla kullanılmış.</p>

<p>Basit ve genişletilmiş regex kurallarının da yardımıyla <code class="language-plaintext highlighter-rouge">sed</code> aracı sayesinde, bulma değiştirme, ekleme, ve silme gibi işlemleri yerine getirebiliyor.</p>

<h2 id="bulup-değiştirme">Bulup Değiştirme</h2>

<h3 id="tüm-eşlemeler--global">Tüm Eşlemeler | Global</h3>

<p>Aradığımız ifade ile eşleşenlerin hepsinin değiştirilmesini istersek <code class="language-plaintext highlighter-rouge">sed ‘s/bulunacak/degiştirilecek/g’ dosya_ismi</code> şeklinde komutumuzu girmemiz gerek. Buradaki “<code class="language-plaintext highlighter-rouge">g</code>” seçeneği “<strong>g</strong>lobal” yani tüm eşleşmeleri kapsıyor. Ben denemek için bir dosya oluşturup bu dosya üzerinden örnekler vereceğim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat </span>veri
bu ilk satır bu ikinci satır bu da son satır
satır iki ve satır sonu
yeni satır ve son satır
yeni veri ve son veri
</code></pre></div></div>

<p>Şimdi ben bu dosyada geçen “satır” ifadelerinin hepsini “bölüm” ifadesi ile değiştirmek istiyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">sed</span> <span class="s1">'s/satır/bölüm/g'</span> veri
bu ilk bölüm bu ikinci bölüm bu da son bölüm
bölüm iki ve bölüm sonu
yeni bölüm ve son bölüm
yeni veri ve son veri
</code></pre></div></div>

<p>Gördüğünüz gibi “<strong>satır</strong>” ifadesini “<strong>bölüm</strong>” ile değiştirmiş oldum.</p>

<h3 id="tüm-satırlardaki-i̇lk-eşleşme">Tüm Satırlardaki İlk Eşleşme</h3>

<p>Eğer “<code class="language-plaintext highlighter-rouge">g</code>” parametresini kullanmazsak yalnızca ilk eşleşme değiştirilecekti.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">sed</span> <span class="s1">'s/satır/bölüm/'</span> veri
bu ilk bölüm bu ikinci satır bu da son satır
bölüm iki ve satır sonu
yeni bölüm ve son satır
yeni veri ve son veri
</code></pre></div></div>

<p>Bakın her bir satırdaki yalnızca ilk eşleşmeler değiştirildi.</p>

<h3 id="satır-numarası-belirtmek">Satır Numarası Belirtmek</h3>

<p>Özellikle hangi satırların dahil edileceğini <code class="language-plaintext highlighter-rouge">s</code> parametresinden önce belirtebiliriz.</p>

<p>Örneğin ben yalnızca 3. satırı kapsamak istersem <code class="language-plaintext highlighter-rouge">3s</code> şeklinde belirtebilirim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">sed</span> <span class="s1">'3s/satır/bölüm/'</span> veri
bu ilk satır bu ikinci satır bu da son satır
satır iki ve satır sonu
yeni bölüm ve son satır
yeni veri ve son veri

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">sed</span> <span class="s1">'3s/satır/bölüm/g'</span> veri                                                                               
bu ilk satır bu ikinci satır bu da son satır
satır iki ve satır sonu
yeni bölüm ve son bölüm
yeni veri ve son veri
</code></pre></div></div>

<p>Ayrıca birden fazla belirtmemiz de mümkün. Ben 1’den 3. satıra kadar olanları dahil etmek için <code class="language-plaintext highlighter-rouge">1,3s</code> şeklinde giriyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">sed</span> <span class="s1">'1,3s/satır/bölüm/'</span> veri                                                                              
bu ilk bölüm bu ikinci satır bu da son satır
bölüm iki ve satır sonu
yeni bölüm ve son satır
yeni veri ve son veri

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">sed</span> <span class="s1">'1,3s/satır/bölüm/g'</span> veri                                                                             
bu ilk bölüm bu ikinci bölüm bu da son bölüm
bölüm iki ve bölüm sonu
yeni bölüm ve son bölüm
yeni veri ve son veri
</code></pre></div></div>

<h2 id="silme">Silme</h2>

<h3 id="belirtilen-satırları-silme">Belirtilen Satırları Silme</h3>

<p>Spesifik olarak silmek istediğimiz satırları <code class="language-plaintext highlighter-rouge">d</code> seçeneğinden önce belirtebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat </span>veri
bu ilk satır bu ikinci satır bu da son satır
satır iki ve satır sonu
yeni satır ve son satır
yeni veri ve son veri

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">sed</span> <span class="s1">'2d'</span> veri
bu ilk satır bu ikinci satır bu da son satır
yeni satır ve son satır
yeni veri ve son veri

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">sed</span> <span class="s1">'2,4d'</span> veri                                                                                           
bu ilk satır bu ikinci satır bu da son satır
</code></pre></div></div>

<h3 id="eşleşme-sağlanan-satıları-silmek">Eşleşme Sağlanan Satıları Silmek</h3>

<p>Eğer aradığımız ifade ile eşleşme sağlanan satırları silmek istersek <code class="language-plaintext highlighter-rouge">sed ‘/aranan/d’</code> şeklinde komutumuzu girebiliriz. Ben denemek için “yeni” ifadesinin geçtiği tüm satırları silmek istiyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat </span>veri
bu ilk satır bu ikinci satır bu da son satır
satır iki ve satır sonu
yeni satır ve son satır
yeni veri ve son veri

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">sed</span> <span class="s1">'/yeni/d'</span> veri
bu ilk satır bu ikinci satır bu da son satır
satır iki ve satır sonu
</code></pre></div></div>

<p>Bakın “yeni” ifadesi ile eşleşme sağlananlar silinmiş oldu.</p>

<h3 id="eşleşme-haricindeki-satırları-silmek">Eşleşme Haricindeki Satırları Silmek</h3>

<p>Aradığımız ifade ile eşleşen satırlar hariç tüm satırları silmek istersek <code class="language-plaintext highlighter-rouge">d</code> parametresinden önce <code class="language-plaintext highlighter-rouge">!</code> ünlem işaretini kullanabiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">cat </span>veri                                                                                        
bu ilk satır bu ikinci satır bu da son satır
satır iki ve satır sonu
yeni satır ve son satır
yeni veri ve son veri

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">sed</span> <span class="s1">'/yeni/!d'</span> veri                                                                                       
yeni satır ve son satır
yeni veri ve son veri
</code></pre></div></div>

<p>Gördüğünüz gibi “yeni” ifadesiyle eşleşenler hariç tüm satırlar silinmiş oldu.</p>

<h2 id="ekleme">Ekleme</h2>

<h3 id="eşleşmeden-önceki-satıra-ekleme">Eşleşmeden Önceki Satıra Ekleme</h3>

<p>Eşleşmeden önceki satıra eklemek için <code class="language-plaintext highlighter-rouge">i</code> parametresini kullanıyoruz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">sed</span> <span class="s1">'/veri/i\oncesi'</span> veri                                                                                
bu ilk satır bu ikinci satır bu da son satır
satır iki ve satır sonu
yeni satır ve son satır
oncesi
yeni veri ve son veri
</code></pre></div></div>

<h3 id="eşleşmeden-sonraki-satıra-ekleme">Eşleşmeden Sonraki Satıra Ekleme</h3>

<p>Eşleşmeden sonraki satıra eklemek için <code class="language-plaintext highlighter-rouge">a</code> parametresini kullanıyoruz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">sed</span> <span class="s1">'/veri/a\sonrası'</span> veri                                                                                
bu ilk satır bu ikinci satır bu da son satır
satır iki ve satır sonu
yeni satır ve son satır
yeni veri ve son veri
sonrası
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">sed</code> komutu kesinlikle burada bahsettiklerimle sınırlı değil fakat ilk aşama için temelde bilmemiz gerekenler bu kadar. Eğer biraz araştırma yapacak olursanız <code class="language-plaintext highlighter-rouge">sed</code> aracının aslında script olarak yazılıp metinsel verileri ihtiyaca göre manipüle edebileceğini de göreceksiniz. Fakat ben bu eğitimde daha fazla detaydan bahsetmeyi planlamıyorum.</p>

<h1 id="awk--gawk">awk | gawk</h1>

<p><code class="language-plaintext highlighter-rouge">awk</code> aracının pek çok farklı sürümü bulunuyor. Biz <strong>GNU</strong> <code class="language-plaintext highlighter-rouge">awk</code> yani <code class="language-plaintext highlighter-rouge">gawk</code> aracını ele alacağız. Pek çok Linux dağıtımında <code class="language-plaintext highlighter-rouge">gawk</code> aracı <code class="language-plaintext highlighter-rouge">awk</code> komutuna sembolik olarak bağlı. Yani biz <code class="language-plaintext highlighter-rouge">awk</code> komutunu giriyoruz ama <code class="language-plaintext highlighter-rouge">gawk</code> aracını kullanıyoruz.</p>

<p><code class="language-plaintext highlighter-rouge">awk</code> aracıyla metinsel veriler üzerinde çeşitli manipülasyonlar yapmamız mümkün.</p>

<p><code class="language-plaintext highlighter-rouge">awk</code> aracında veriler, kayıtlar(records) ve alanlar(fields) olmak üzere iki parçaya ayrılıyorlar.</p>

<p><img src="https://superua1.github.io//egitim/metin/awk1.png" alt="awk1.png" class="responsive img-zoomable" /></p>

<p><code class="language-plaintext highlighter-rouge">awk</code>, girişin sonuna ulaşılana kadar her seferinde bir kayıt üzerinde çalışır. Kayıtlar(records), kayıt ayırıcı(record separator) adı verilen bir karakterle ayrılır. <code class="language-plaintext highlighter-rouge">RS</code> değişkeni kullanılarak yeni bir kayıt ayırıcı ayarlanabilir. Varsayılan kayıt ayırıcı, yeni satır karakteridir; bu, metin verilerindeki her satırın bir kayıt olduğu anlamına gelir. Yani awk aracı her seferinde sırasıyla tek bir satır üzerinde çalışır.</p>

<p><img src="https://superua1.github.io//egitim/metin/awk1.gif" alt="awk1.gif" class="responsive img-zoomable" /></p>

<p>Alanalar(fields) ise boşluk karakteri ile birbirinden ayrılıp, kayıtları(records) oluşturuyor. Her kayıttaki alanlara dolar işareti (<code class="language-plaintext highlighter-rouge">$</code>) ve ardından 1 ile başlayan alan numarası verilir. İlk alan <code class="language-plaintext highlighter-rouge">$1</code> ile, ikincisi <code class="language-plaintext highlighter-rouge">$2</code> ile vb. temsil edilir. Son alana <code class="language-plaintext highlighter-rouge">$NF</code> özel değişkeni ile de başvurulabilir. Tüm kayda <code class="language-plaintext highlighter-rouge">$0</code> ile başvurulabilir.</p>

<p><img src="https://superua1.github.io//egitim/metin/awk2.png" alt="awk2.png" class="responsive img-zoomable" /></p>

<h2 id="awk-programı">awk Programı</h2>

<p>awk aslında bir programlama dili gibi işlenecek veriler için çeşitli programlar yazabilmemize olanak tanıyor. Programın yazılabilmesi için de çeşitli komutlar var.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>desen <span class="o">{</span>aksiyon<span class="o">}</span>
desen <span class="o">{</span>aksiyon<span class="o">}</span>
..
<span class="nb">.</span>
</code></pre></div></div>

<p>Eğer “desen” kayıt yani satırla eşleşme sağlarsa “aksiyon” olarak belirtilen görev yerine getiriliyor. Aksiyonlar kıvırcık parantez içinde “ifadeler” ile birlikte belirtiliyor. İfadeler sayesinde aksiyonun ne olması gerektiğini belirtebiliyoruz. Awk üzerinde en yaygın kullanıma sahip olan ifadeler:</p>

<p><code class="language-plaintext highlighter-rouge">exit</code>: Tüm programın yürütülmesini durdurur ve çıkar.</p>

<p><code class="language-plaintext highlighter-rouge">next</code>: Geçerli kaydın(satırın) işlenmesini durdurur ve giriş verilerinde bir sonraki kayda geçer.</p>

<p><code class="language-plaintext highlighter-rouge">print</code>: Kayıtları, alanları, değişkenleri ve özel metni yazdırır.</p>

<p>Ben örnekler için aşağıdaki verilerle çalışıyor olacağım.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">cat </span>veri
Ahmet Yaz 33
hasan mert 19
aylin uzun 24
32 mehmet KARA
naz 29 sabah
</code></pre></div></div>

<p>Ben her bir satırın ilk bölümünü bastırmak istediğim için <code class="language-plaintext highlighter-rouge">awk ‘{ print $1}’ veri</code> şeklinde komutumu giriyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'{print $1}'</span> veri
Ahmet
hasan
aylin
32
naz
</code></pre></div></div>

<p>Bakın <code class="language-plaintext highlighter-rouge">awk</code> aracı her bir satırı ayrı ayrı ele aldığı ve <code class="language-plaintext highlighter-rouge">$1</code> parametresi de ilk alanı temsil ettiği için ilk sütunlardaki tüm verileri <code class="language-plaintext highlighter-rouge">print</code> ile bastırmış olduk. Burada tek tırnak kullanmamız önemli, çünkü süslü parantezin kabuk tarafından yorumlanmasını istemeyiz.</p>

<p>Örneğin ben son yani 3. sütundakileri filtrelemek istersem <code class="language-plaintext highlighter-rouge">$3</code> yada sonda olduğu için <code class="language-plaintext highlighter-rouge">$NF</code> değişkenini kullanabilirim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'{print $3}'</span> veri                                        
33
19
24
KARA
sabah
└─<span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'{print $NF}'</span> veri                                       
33
19
24
KARA
sabah
</code></pre></div></div>

<h2 id="regex-kullanımı">Regex Kullanımı</h2>

<p>awk üzerinde regex kullanmak için regex tanımlarını slash karakterleri arasında /regex/ şeklinde yazmamız gerek.</p>

<p>Örneğin ben satır sonunda sayı bulunanları filtreleyip, bu son sütunları bastırmak istiyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'/[0-9]$/{print $NF}'</span> veri                               
33
19
24
</code></pre></div></div>

<p>Gördüğünüz gibi <code class="language-plaintext highlighter-rouge">[0-9]$</code> regex tanımı sonunda sayısal veri bulunan satırlar ile eşleşme sağladı, <code class="language-plaintext highlighter-rouge">{print $NF}</code> ise bu satırların yalnızca son sütunlarının bastırılmasını sağladı.</p>

<h2 id="regex-için-spesifik-bölüm-belirtmek">Regex için Spesifik Bölüm Belirtmek</h2>

<p>Eğer regex kalıbının tüm kayıt üzerinde değil de yalnızca belirli alanlar üzerinde aranmasını istersek dolar işareti ile aranmasını istediğimiz bölümü belirtip peşine tilde <code class="language-plaintext highlighter-rouge">~</code> işareti eklememiz yeterli.</p>

<p>Örneğin ben yalnızca 2. sütununda rakam bulunduran satırların 1. sütunlarını bastırmak istiyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'$2 ~ /[0-9]/{print $1}'</span> veri                            
naz
</code></pre></div></div>

<p>Buradaki <code class="language-plaintext highlighter-rouge">$2 ~</code> tanımı <code class="language-plaintext highlighter-rouge">[0-9]</code> regex kalıbının yalnızca 2. alanda yani ikinci sütunda eşleşme aramasını sağladı. <code class="language-plaintext highlighter-rouge">{print $1}</code> ise sağlanmış olan bu eşleşmelerin 1. sütunlarını konsola bastırmış oldu. Yalnızca ilk sütunu değil de türm kaydı bastırırsak, zaten bu satırın 2. sütununda rakam geçtiğini kendimiz de görebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'$2 ~ /[0-9]/{print $0}'</span> veri                            
naz 29 sabah
</code></pre></div></div>

<h2 id="regex-için-kaçınılması-gereken-spesifik-bölüm-belirtmek">Regex için Kaçınılması Gereken Spesifik Bölüm Belirtmek</h2>

<p>Eğer spesifik olarak dahil edilmesini istemediğimiz alan varsa bunu tilde işaretinden önce ünlem işareti ekleyerek <code class="language-plaintext highlighter-rouge">!~</code> belirtebiliriz. Örneğin ben bir önceki örnekte olan 2. alandakilerin regex dahilinde aranmasını, 2. alandakilerin hariç tutularak aranması olarak değiştirmek istiyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'$2 !~ /[0-9]/{print $1}'</span> veri                           
Ahmet
hasan
aylin
32

└─<span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'$2 !~ /[0-9]/{print $0}'</span> veri                           
Ahmet Yaz 33
hasan mert 19
aylin uzun 24
32 mehmet KARA
</code></pre></div></div>

<p>Gördüğünüz gibi 2. sütununda sayısal veri bulunduran hariç tüm sütunlar regex genişletmesine dahil edilmiş oldu. Yani hariç tutmak istediğimiz alanları tilde işaretinden önce ünlem işareti <code class="language-plaintext highlighter-rouge">!~</code> ile özellikle belirtebiliyoruz.</p>

<h2 id="birden-fazla-sütunu-bastırmak">Birden Fazla Sütunu Bastırmak</h2>

<p>Dilersek birden fazla sütun üzerinde de çalışabiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'{print $1 $3}'</span> veri                                  
Ahmet33
hasan19
aylin24
32KARA
nazsabah
</code></pre></div></div>

<p>Fakat bu şekilde gördüğünüz gibi sütunlar arasında boşluk bulunmuyor. Eğer boşluk olmasını istiyorsak tırnak içinde bunu özellikle belirtebiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'{print $1 " " $3}'</span> veri                                 
Ahmet 33
hasan 19
aylin 24
32 KARA
naz sabah
</code></pre></div></div>

<h1 id="konsolda-okunaklı-çıktılar-almak">Konsolda Okunaklı Çıktılar Almak</h1>

<p>Şimdiye kadar nasıl dosya oluşturabileceğimizi, dosyaları nasıl okuyup, içeriklerini istediğimiz gibi filtreleyip değiştirebileceğimizi öğrendik. Şimdi de konsol üzerinden verileri okumak istediğimizde bizlere kolay okuma imkanı sunan araçlardan bahsedelim istiyorum.</p>

<p>Komut satırı üzerinde çalışıyorken, araçların ürettiği çıktıları yine komut satırımız üzerinde yazılı şekilde takip ediyoruz. Fakat sizin de bildiğiniz gibi komut satırının da bir görüntüleme sınırı var. Eğer grafiksel arayüzdeki bir komut satırında çalışıyorsak, zaten terminal aracı çıktıların konsola sığmayan kadarını görebilmemizi sağlayan kaydırma çubuğu gibi özellikler sunuyor.</p>

<p><img src="https://superua1.github.io//egitim/metin/terminal-scroll.gif" alt="terminal-scroll.gif" class="responsive img-zoomable" /></p>

<p>İşte bizzat test ettiğimiz gibi grafiksel arayüzdeki bu konsol aracımız, çıktıların tamamını bu pencere içerisinde tek seferde gösteremiyor olsa da, tamamını görebilmemiz için bize kolaylık sağlıyor. Fakat komut satırı arayüzündeki tty konsollarında çalışırken, önceki çıktılara dönme gibi bir imkanımız olmuyor. Dolayısıyla uzun çıktılar üreten araçların tüm çıktılarını yalnız komut satırı arayüzünün bulunduğu tty konsollarında tam şekilde görüntüleyemiyoruz.</p>

<p>Denemek isterseniz komut satırı arayüzüne geçip uzun bir dosya içeriğini <code class="language-plaintext highlighter-rouge">cat</code> komutu ile okuyabilirsiniz. Ben denemek için daha önce oluşturduğum “<strong><em>isimler.txt</em></strong>” dosyamı okumak için <code class="language-plaintext highlighter-rouge">cat isimler.txt</code> komutunu giriyorum.</p>

<p><img src="https://superua1.github.io//egitim/metin/tty-scroll.png" alt="tty-scroll.png" class="responsive img-zoomable" /></p>

<p>Bakın yalnızca dosyanın sonunu görebiliyoruz. Faremizin scroll tuşu ile daha önceki çıktıları görme imkanımız da yok.</p>

<p>İşte bu duruma çözüm olarak araçların çıktılarını bize parça parça sunabilecek ek araçlara ihtiyacımız var. Ben de anlatımın devamında bize bu imkanı tanıyan <code class="language-plaintext highlighter-rouge">more</code> <code class="language-plaintext highlighter-rouge">less</code> <code class="language-plaintext highlighter-rouge">head</code> ve <code class="language-plaintext highlighter-rouge">tail</code> araçlarından bahsedip, komut satırı arayüzündeki hakimiyetimizi arttırmak istiyorum.</p>

<h2 id="more-komutu">more Komutu</h2>

<p><code class="language-plaintext highlighter-rouge">more</code> aracı, kendisine yönlendirilmiş olan verilerin en başından itibaren ekrana sığan kadarlık kısmını sırasıyla parça parça bize sunuyor. Örneğin bir dosya içeriğinin ilk 10 satırı ekranımıza sığıyorsa, ilk olarak 10 satırı daha sonra bir sonraki 10 satırı ve bir sonraki 10 satırı gösterecek şekilde tüm içerik bitene kadar baştan sonra tüm verileri parça parça bize sunuyor.</p>

<p>Zaten <code class="language-plaintext highlighter-rouge">more</code> ismi de “daha” anlamına geliyor. Biz istedikçe verilerin geri kalanını yani daha fazlasını bize parça parça sunduğu için <code class="language-plaintext highlighter-rouge">more</code> ismi verilmiş.</p>

<p>Ben örnek olması için <strong><em>/etc</em></strong> dizinin içeriğini listeleyip, tüm listeye parça parça bakmak istiyorum. Örneğin <code class="language-plaintext highlighter-rouge">ls -l /etc</code> şeklinde komutumuzu girdiğimizde tek seferde tüm çıktıları göremeyiz.</p>

<p><img src="https://superua1.github.io//egitim/metin/without-more.png" alt="without-more.png" class="responsive img-zoomable" /></p>

<p>Bu sorunu çözmek içim bu çıktıları pipe ile <code class="language-plaintext highlighter-rouge">more</code> aracına yönlendirip çıktılara parça parça bakabiliriz.</p>

<p><img src="https://superua1.github.io//egitim/metin/more.gif" alt="more.gif" class="responsive img-zoomable" /></p>

<p>Gördüğünüz gibi bu kez, içerik listesinin en başından itibaren yalnızca ekranıma sığan kadarlık kısmını görüyoruz ve altta “<strong>more</strong>”  ifadesi var. Bu ifade, ileride daha fazla verinin olduğuna işaret ediyor. Eğer bir satır sonrasını görmek istersek <kbd>enter</kbd> tuşunu, eğer ekranımıza sığan bir sonraki tüm bölümü görmek istersek de <kbd>space</kbd> tuşunu kullanabiliyoruz.</p>

<p>Gördüğünüz gibi tamamı konsol ekranımıza sığmayacak kadar olan tüm verileri, <code class="language-plaintext highlighter-rouge">more</code> aracına yönlendirip, bu araç vasıtasıyla ekranımıza sığan kadarlık kısmını parça parça veya satır satır <strong>ileriye doğru</strong> görüntüleyebiliyoruz. Fark ettiyseniz özellikle “ileriye doğru” dedim çünkü <code class="language-plaintext highlighter-rouge">more</code> aracı önceki çıktılara dönmemizi sağlamıyor. Tek yönlü şekilde yani hep daha fazlası için en baştan en sona doğru verileri görüntüleyebiliyoruz. Örneğin space ile geçtiğiniz önceki parçaya dönmek isterseniz bu <code class="language-plaintext highlighter-rouge">more</code> aracı ile mümkün değil. Bunun için birazdan bahsedeceğimiz <code class="language-plaintext highlighter-rouge">less</code> aracını kullanabiliriz.</p>

<p>Eğer yalnızca ileriye doğru okuma yapacaksanız dosyalar veya pipe üzerinden <code class="language-plaintext highlighter-rouge">more</code> aracına okunacak verileri verebilirsiniz. Biz özellikle ele almadık ama elbette <code class="language-plaintext highlighter-rouge">more</code> aracı ile doğrudan dosya içeriklerini de okuyabiliyoruz.</p>

<p><img src="https://superua1.github.io//egitim/metin/more-with-file.gif" alt="more-with-file.gif" class="responsive img-zoomable" /></p>

<p>Yani bizzat test ettiğimiz gibi more aracı standart girdiden veri almasına ek olarak, kendisine argüman olarak verilmiş olan dosya içeriğini de parça parça konsol üzerinden görüntüleyebilmemize olanak tanıyor.</p>

<p>Hatta dilerseniz <code class="language-plaintext highlighter-rouge">more</code> aracına aynı anda birden fazla dosya ismini verip, birden fazla verinin de sırasıyla <code class="language-plaintext highlighter-rouge">more</code> aracı üzerinden okunmasını sağlayabilirsiniz.</p>

<p>Tüm bunlar dışında eğer <code class="language-plaintext highlighter-rouge">more</code> aracını kullanırken içeriğin sonuna gelmeyi beklemeden aracı sonlandırmak isterseniz <kbd>q</kbd> tuşuna basmanız yeterli. Ben denemek için birden fazla dosyayı more ile açıp, dosyaların sonuna gelmeden <kbd>q</kbd> tuşuna basıp <code class="language-plaintext highlighter-rouge">more</code> aracını kapatıyorum.</p>

<p><img src="https://superua1.github.io//egitim/metin/quit-more.gif" alt="quit-more.gif" class="responsive img-zoomable" /></p>

<p>Bakın <kbd>q</kbd> tuşuna bastığım anda araç kapatıldı.</p>

<h2 id="less-komutu">less Komutu</h2>

<p><code class="language-plaintext highlighter-rouge">more</code> aracının çıktılarda geriye doğru kaydırma yapamamasından bıkan başka bir geliştirici “less is more” yani “az çoktan fazladır” cümlesine atıfta bulunarak <code class="language-plaintext highlighter-rouge">less</code> aracını geliştirmiştir.</p>

<p><code class="language-plaintext highlighter-rouge">less</code> komutu <code class="language-plaintext highlighter-rouge">more</code> komutundan farklı olarak dosya içeriğinde aşağı yukarı, sağa ve sola doğru kaydırma hareketlerine imkan tanıyor.</p>

<p>Test etmek için <strong><em>/etc/passwd</em></strong> dosyasını okumayı deneyebiliriz.</p>

<p>Eğer bir satır aşağı inmek istersem klavyemdeki aşağı yön tuşunu kullanabilirim. Benzer şekilde bir üst satıra çıkmak için de klavyemdeki yukarı yön tuşunu kullanmam yeterli. Ayrıca <code class="language-plaintext highlighter-rouge">more</code> komutunda olduğu şekilde <kbd>enter</kbd> ile de bir satır aşağı inip, <kbd>space</kbd> ile birer sayfa ileriye atlayabiliyoruz. Space tuşu haricinde bir sayfa ileri gitmek için “<strong>f</strong>orward” yani “ileri” ifadesinin kısaltması olan <kbd>f</kbd> tuşunu da kullanabiliyoruz. Bir sayfa geri gelmek için de “<strong>b</strong>ackward” yani “geriye” ifadesinin kısaltması olan <kbd>b</kbd> tuşunu kullanabiliyoruz. Okuma işimiz bittiğinde aracı kapatmak için <kbd>q</kbd> tuşuna basmamız yeterli.</p>

<p><img src="https://superua1.github.io//egitim/metin/less.gif" alt="less.gif" class="responsive img-zoomable" /></p>

<p>Ben doğrudan dosya ismini argüman olarak verdim ancak dilerseniz tabii ki standart girdiden de istediğiniz veriyi yönlendirebilirsiniz. Örneğim <code class="language-plaintext highlighter-rouge">ls -l /etc | less</code> komutu ile <strong><em>/etc</em></strong> dizininin ayrıntılı çıktılarını parça parça inceleyebilirsiniz.</p>

<p>Bence <code class="language-plaintext highlighter-rouge">less</code> aracı hakkında bu kadarlık bilgi yeterli.  Daha fazlasını öğrenmek veya unuttuğunuzda hatırlamak için <code class="language-plaintext highlighter-rouge">less —help</code> komutunu kullanıp <code class="language-plaintext highlighter-rouge">less</code> aracının yardım sayfasından faydalanabilirsiniz.</p>

<h2 id="head-komutu">head Komutu</h2>

<p>İsminin de çağrışım yaptığı gibi <code class="language-plaintext highlighter-rouge">head</code> komutu kendisine yönlendirilen içeriğin başından itibaren okunabilmesini sağlıyor. Herhangi bir seçenek belirtmediğimizde <code class="language-plaintext highlighter-rouge">head</code> aracı ilk 10 satırı konsola bastırıyor. Ben denemek için <code class="language-plaintext highlighter-rouge">head /etc/passwd</code> komutu ile dosyamı okumak istiyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">head</span> /etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
<span class="nb">sync</span>:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
</code></pre></div></div>

<p>Dosya içeriğinin yalnızca ilk 10 satırı bastırılmış oldu.</p>

<p>Birden fazla dosya okunmasını da sağlayabiliriz. Eğer aynı anda birden fazla dosya okunuyorsa her bir dosyanın ilk 10 satırını bastırıyor. Hemen deneyelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">head</span> /etc/passwd /etc/group
<span class="o">==&gt;</span> /etc/passwd &lt;<span class="o">==</span>
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
<span class="nb">sync</span>:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin

<span class="o">==&gt;</span> /etc/group &lt;<span class="o">==</span>
root:x:0:
daemon:x:1:
bin:x:2:
sys:x:3:
adm:x:4:taylan,root
<span class="nb">tty</span>:x:5:
disk:x:6:
lp:x:7:
mail:x:8:
news:x:9:
</code></pre></div></div>

<p>Bakın en başta hangi dosya olduğunu da açıkça belirtilerek her iki dosyanın da ilk 10’ar satırı bastırılmış.</p>

<p>Bu temel kullanım dışında eğer kaç satır bastırılmasını gerektiğini belirtmek istiyorsak, <code class="language-plaintext highlighter-rouge">-n</code> seçeneğinin ardından kaç satır basılacağını da yazabiliyor. Ben denemek için dosyanın ilk 5 satırını bastırmak üzere <code class="language-plaintext highlighter-rouge">head -n 5 dosya_adı</code> şeklinde komutumu giriyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">head</span> <span class="nt">-n</span> 5 /etc/passwd /etc/group                                   
<span class="o">==&gt;</span> /etc/passwd &lt;<span class="o">==</span>
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
<span class="nb">sync</span>:x:4:65534:sync:/bin:/bin/sync

<span class="o">==&gt;</span> /etc/group &lt;<span class="o">==</span>
root:x:0:
daemon:x:1:
bin:x:2:
sys:x:3:
adm:x:4:taylan,root

┌──<span class="o">(</span>taylan@linuxdersleri<span class="o">)</span>-[~]
└─<span class="nv">$ </span><span class="nb">head</span> <span class="nt">-n</span> 5 /etc/passwd                                    
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
<span class="nb">sync</span>:x:4:65534:sync:/bin:/bin/sync
</code></pre></div></div>

<p>Bakın dosyaların yalnızca ilk 5 satırı bastırıldı. Ayrıca bu kullanım dışında doğrudan <code class="language-plaintext highlighter-rouge">head -5 dosya_adı</code> komutu ile de aynı şekilde ilk 5 satırın bastırılmasını sağlayabiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">head</span> <span class="nt">-5</span> /etc/passwd /etc/group                                    
<span class="o">==&gt;</span> /etc/passwd &lt;<span class="o">==</span>
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
<span class="nb">sync</span>:x:4:65534:sync:/bin:/bin/sync

<span class="o">==&gt;</span> /etc/group &lt;<span class="o">==</span>
root:x:0:
daemon:x:1:
bin:x:2:
sys:x:3:
adm:x:4:taylan,root
</code></pre></div></div>

<p>Yani bakın, <code class="language-plaintext highlighter-rouge">n</code> seçeneği olmadan doğrudan tire işaretinden sonra kaç satır bastırılmasını gerektiğini de bu şekilde belirtebiliyoruz. Aynı çıktıyı aldık.</p>

<p>Tahmin ettiğiniz gibi tabii ki yalnızca dosyalar üzerinde çalışmak zorunda da değiliz. Örneğin <code class="language-plaintext highlighter-rouge">ls -l /etc</code> komutunu çıktılarını pipe ile <code class="language-plaintext highlighter-rouge">head</code> aracına yönlendirip ilk 10 satırın bastırılmasını sağlayabiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-l</span> /etc/ | <span class="nb">head
</span>total 1320
<span class="nt">-rw-r--r--</span>  1 root     root      2981 Feb 11  2022 adduser.conf
<span class="nt">-rw-r--r--</span>  1 root     root        44 Feb 11  2022 adjtime
drwxr-xr-x  3 root     root      4096 Feb 11  2022 alsa
drwxr-xr-x  2 root     root     20480 Jun 28  2022 alternatives
drwxr-xr-x  8 root     root      4096 Feb 11  2022 apache2
drwxr-xr-x  2 root     root      4096 Feb 11  2022 apparmor
drwxr-xr-x  9 root     root      4096 Feb 11  2022 apparmor.d
drwxr-xr-x  7 root     root      4096 Jun 14 11:40 apt
drwxr-xr-x  3 root     root      4096 Feb 11  2022 avahi
</code></pre></div></div>

<p>Bakın yalnızca 10 satırı bastırıldı. Mesela bastırılan satır sayısını teyit etmek için pipe ile <code class="language-plaintext highlighter-rouge">nl</code> aracını da kullanabiliriz.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-l</span> /etc/ | <span class="nb">head</span> | <span class="nb">nl
     </span>1  total 1320                                                         
     2  <span class="nt">-rw-r--r--</span>  1 root     root      2981 Feb 11  2022 adduser.conf    
     3  <span class="nt">-rw-r--r--</span>  1 root     root        44 Feb 11  2022 adjtime               
     4  drwxr-xr-x  3 root     root      4096 Feb 11  2022 alsa
     5  drwxr-xr-x  2 root     root     20480 Jun 28  2022 alternatives
     6  drwxr-xr-x  8 root     root      4096 Feb 11  2022 apache2
     7  drwxr-xr-x  2 root     root      4096 Feb 11  2022 apparmor
     8  drwxr-xr-x  9 root     root      4096 Feb 11  2022 apparmor.d
     9  drwxr-xr-x  7 root     root      4096 Jun 14 11:40 apt
    10  drwxr-xr-x  3 root     root      4096 Feb 11  2022 avahi
</code></pre></div></div>

<p>Bakın <code class="language-plaintext highlighter-rouge">ls</code> komutunun çıktıları <code class="language-plaintext highlighter-rouge">head</code> aracına iletildi ve 10 satırla sınırlandıktan sonra bu çıktılar <code class="language-plaintext highlighter-rouge">nl</code> aracı sayesine numaralandırılmış oldu.</p>

<p>Ayrıca <code class="language-plaintext highlighter-rouge">head</code> aracının başka seçenekleri de var fakat diğer seçeneklerine neredeyse hiç ihtiyaç duymayacağınızı düşündüğüm için bahsetmiyorum. Merak ediyorsanız, <code class="language-plaintext highlighter-rouge">head —help</code> komutunu kullanabilirsiniz.</p>

<h2 id="tail-komutu">tail Komutu</h2>

<p><code class="language-plaintext highlighter-rouge">tail</code> ifadesi Türkçe “kuyruk” anlamına geliyor. İsminden de kolayca anlaşılabileceği gibi <code class="language-plaintext highlighter-rouge">tail</code> komutu dosyaların <strong>sondaki satırlarının</strong> bastırılmasını sağlıyor. Yani <code class="language-plaintext highlighter-rouge">tail</code> aracını <code class="language-plaintext highlighter-rouge">head</code> aracının tersten çalışan versiyonu olarak düşünebilirsiniz. <code class="language-plaintext highlighter-rouge">tail</code>, ekstra bir seçenek kullanılmadığında varsayılan olarak ilgili dosyanın <strong>sondan 10</strong> satırını bastırıyor. Hemen denemek için <strong><em>/etc/passwd</em></strong> dosyasını okumayı deneyelim.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">tail</span> /etc/passwd                                                        
sslh:x:125:130::/nonexistent:/usr/sbin/nologin
postgres:x:126:131:PostgreSQL administrator,,,:/var/lib/postgresql:/bin/bash
pulse:x:127:132:PulseAudio daemon,,,:/run/pulse:/usr/sbin/nologin
saned:x:128:135::/var/lib/saned:/usr/sbin/nologin
inetsim:x:129:137::/var/lib/inetsim:/usr/sbin/nologin
lightdm:x:130:138:Light Display Manager:/var/lib/lightdm:/bin/false
colord:x:131:139:colord colour management daemon,,,:/var/lib/colord:/usr/sbin/nologin
geoclue:x:132:140::/var/lib/geoclue:/usr/sbin/nologin
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
taylan:x:1000:1000:taylan,,,:/home/taylan:/usr/bin/bash
</code></pre></div></div>

<p>Bakın dosya içeriğinin sondan 10 satırı bastırıldı. Dilersek kaç satır bastırılacağını <code class="language-plaintext highlighter-rouge">-n</code> seçeneğinin ardından belirtmemiz de mümkün. Ben son 6 satırı bastırmak için <code class="language-plaintext highlighter-rouge">tail -n 6 /etc/passwd</code> şeklinde komutumu giriyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">tail</span> <span class="nt">-n</span> 6 /etc/passwd
inetsim:x:129:137::/var/lib/inetsim:/usr/sbin/nologin
lightdm:x:130:138:Light Display Manager:/var/lib/lightdm:/bin/false
colord:x:131:139:colord colour management daemon,,,:/var/lib/colord:/usr/sbin/nologin
geoclue:x:132:140::/var/lib/geoclue:/usr/sbin/nologin
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
taylan:x:1000:1000:taylan,,,:/home/taylan:/usr/bin/bash
</code></pre></div></div>

<p>Bakın yalnızca sondan 6 satır bastırılmış.</p>

<p>Ayrıca tıpkı <code class="language-plaintext highlighter-rouge">head</code> komutunda olduğu gibi elbette birden fazla dosyayı da aynı anda açabiliriz. Ben <strong><em>passwd</em></strong> ve <strong><em>group</em></strong> dosyalarının sondan 3 satırını bastırmak için <code class="language-plaintext highlighter-rouge">tail -n 3 /etc/passwd /etc/group</code> komutunu giriyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">tail</span> <span class="nt">-n3</span> /etc/passwd /etc/group                                              
<span class="o">==&gt;</span> /etc/passwd &lt;<span class="o">==</span>
geoclue:x:132:140::/var/lib/geoclue:/usr/sbin/nologin
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
taylan:x:1000:1000:taylan,,,:/home/taylan:/usr/bin/bash

<span class="o">==&gt;</span> /etc/group &lt;<span class="o">==</span>
kaboxer:x:143:taylan,root
yeni-grup:x:1003:
ali:x:1001:
</code></pre></div></div>

<p>Bakın sırasıyla her iki dosyanın da sondan 3 er satırı bastırıldı.</p>

<p>Dosya içeriklerinin okunması yerine standart girdiden alınan verilerin kullanılması da mümkün. Ben <code class="language-plaintext highlighter-rouge">ls /etc/</code> komutu ile dizin içeriğinin listelenip, pipe ile bu çıktıların <code class="language-plaintext highlighter-rouge">tail</code> aracına aktarılmasını istiyorum.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span><span class="nb">ls</span> /etc/ | <span class="nb">tail                                                              
</span>wgetrc
wireshark
wpa_supplicant
X11
xattr.conf
xdg
xfce4
xl2tpd
zsh
zsh_command_not_found
</code></pre></div></div>

<p>Bakın bu sayede gördüğünüz gibi <strong><em>/etc</em></strong> dizin içeriğinin sondan 10 satırı konsola bastırılmış oldu.</p>

<h3 id="verilerin-anlık-takibi--f">Verilerin Anlık Takibi <code class="language-plaintext highlighter-rouge">-f</code></h3>

<p>Bu basit kullanımlar dışında, <code class="language-plaintext highlighter-rouge">tail</code> aracının <code class="language-plaintext highlighter-rouge">-f</code> seçeneği sayesinde sürekli güncellenen verilerin takip etmemiz de mümkün oluyor. Bu <code class="language-plaintext highlighter-rouge">-f</code> seçeneği, özellikle log dosyalarındaki en son değişikliklerin takibi için sıklıkla kullanıyor.</p>

<p>Ben test etmek için iki konsol üzerinden çalışacağım. İlk konsola <code class="language-plaintext highlighter-rouge">cat &gt; yeni.txt</code> komutu ile yeni bir dosya açıp veri girişi yapmak üzere giriş yapıyorum. İkinci konsola da <strong><em>yeni.txt</em></strong> dosyasındaki değişikliklerin anlık olarak takip edilmesi için <code class="language-plaintext highlighter-rouge">tail -f yeni.txt</code> komutunu giriyorum. Bu sayede ben <strong><em>yeni.txt</em></strong> dosyasına veri ekledikçe bunları <code class="language-plaintext highlighter-rouge">tail -f</code> komutu sayesinde anlık olarak takip edebiliyor olacağız.</p>

<p><img src="https://superua1.github.io//egitim/metin/tail-f.gif" alt="tail-f.gif" class="responsive img-zoomable" /></p>

<p>Bakın ne kadar yeni veri girersem, <code class="language-plaintext highlighter-rouge">tail -f</code> komutu o kadar veriyi bastırıyor. Bu komut özellikle anlık değişimlerin takibi için log dosyalarını okumak için sıklıkla kullanılıyor.</p>

<p>İleride log kayıtları ile uğraşırken <code class="language-plaintext highlighter-rouge">tail -f</code> komutunu sizler de sıklıkla kullanıyor olacaksınız. Eğer bu <code class="language-plaintext highlighter-rouge">tail</code> komutunun <code class="language-plaintext highlighter-rouge">f</code> seçeneğini kullanmazsak, dosyalardaki en son değişiklikler yerine yalnızca o dosyayı açtığımız andaki verilere ulaşabiliyoruz. <code class="language-plaintext highlighter-rouge">tail -f</code> komutu anlık olarak dosya içeriğindeki verileri takip etmemizi sağlıyor. Ayrıca bu şekilde sürekli yeni veri var mı diye beklendiği için aracı kapatmak için <kbd>ctrl</kbd> + <kbd>c</kbd> ile durdurmamız gerekiyor.</p>

<p>Böylelikle temel olarak <code class="language-plaintext highlighter-rouge">tail</code> aracının işlevinden ve kullanımından da haberdar olduk. Tabii diğer seçenekleri için yardım sayfalarına göz atabilirsiniz.</p>

<p>Ayrıca ben özellikle ele almadım ancak pipe mekanizmasının da yardımıyla ihtiyacınıza yönelik olarak bu bölümde öğrenmiş olduğunu uygun yapıdaki tüm araçları birbirine bağlayarak çalıştırabileceğinizi zaten biliyorsunuz. Ben yalnızca araçların temel kullanımlardan bahsettiğim için özellikle birden fazla aracın birlikte kullanıldığı farklı durumlara örnekler verme fırsatım olmadı ama siz kendiniz pratikler yaparak deneyimleyebilirsiniz.</p>

<p></p>
          <div align="center" class="custom-control custom-switch">
                
            <input type="checkbox" class="custom-control-input" id="readCheckbox"  onchange="markAsRead()">
            <label class="custom-control-label" for="readCheckbox">Okundu Olarak İşaretle  </label>
          </div>
          <p></p>
          <div align="center">
            <button id="linkedinShareButton" class="mavi btn btn-outline-primary">
              <svg width="24px" height="24px" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" fill="none"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"><path fill="#0A66C2" d="M12.225 12.225h-1.778V9.44c0-.664-.012-1.519-.925-1.519-.926 0-1.068.724-1.068 1.47v2.834H6.676V6.498h1.707v.783h.024c.348-.594.996-.95 1.684-.925 1.802 0 2.135 1.185 2.135 2.728l-.001 3.14zM4.67 5.715a1.037 1.037 0 01-1.032-1.031c0-.566.466-1.032 1.032-1.032.566 0 1.031.466 1.032 1.032 0 .566-.466 1.032-1.032 1.032zm.889 6.51h-1.78V6.498h1.78v5.727zM13.11 2H2.885A.88.88 0 002 2.866v10.268a.88.88 0 00.885.866h10.226a.882.882 0 00.889-.866V2.865a.88.88 0 00-.889-.864z"></path></g></svg>
              Paylaş
            </button>
            <button id="twitterShareButton" class="mavi btn btn-outline-primary">
              <svg width="24px" height="24px" viewBox="0 -4 48 48" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000000"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <title>Twitter-color</title> <desc>Created with Sketch.</desc> <defs> </defs> <g id="Icons" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"> <g id="Color-" transform="translate(-300.000000, -164.000000)" fill="#00AAEC"> <path d="M348,168.735283 C346.236309,169.538462 344.337383,170.081618 342.345483,170.324305 C344.379644,169.076201 345.940482,167.097147 346.675823,164.739617 C344.771263,165.895269 342.666667,166.736006 340.418384,167.18671 C338.626519,165.224991 336.065504,164 333.231203,164 C327.796443,164 323.387216,168.521488 323.387216,174.097508 C323.387216,174.88913 323.471738,175.657638 323.640782,176.397255 C315.456242,175.975442 308.201444,171.959552 303.341433,165.843265 C302.493397,167.339834 302.008804,169.076201 302.008804,170.925244 C302.008804,174.426869 303.747139,177.518238 306.389857,179.329722 C304.778306,179.280607 303.256911,178.821235 301.9271,178.070061 L301.9271,178.194294 C301.9271,183.08848 305.322064,187.17082 309.8299,188.095341 C309.004402,188.33225 308.133826,188.450704 307.235077,188.450704 C306.601162,188.450704 305.981335,188.390033 305.381229,188.271578 C306.634971,192.28169 310.269414,195.2026 314.580032,195.280607 C311.210424,197.99061 306.961789,199.605634 302.349709,199.605634 C301.555203,199.605634 300.769149,199.559408 300,199.466956 C304.358514,202.327194 309.53689,204 315.095615,204 C333.211481,204 343.114633,188.615385 343.114633,175.270495 C343.114633,174.831347 343.106181,174.392199 343.089276,173.961719 C345.013559,172.537378 346.684275,170.760563 348,168.735283" id="Twitter"> </path> </g> </g> </g></svg>
              Paylaş
            </button>
            <p></p>
            <h5>📮 Hata, eksik ve öneri bildirimlerinizi <a href="https://superua1.github.io//bildirim.html">buradan</a> iletebilirsiniz. </h5>
          </div>

        <p></p>



  

  

  

  

  

  

  

  

  

  

  
    
    
    
    


<div data-pagefind-ignore="all" class="row mb-2">
  
      
    <div class="col-md-6">
      <div class="no-gutters border rounded overflow-hidden flex-md-row mb-4 shadow-sm h-md-250 position-relative">
        <div class="col p-4 d-flex flex-column position-static">
          <div class="row">
            <div align="left" class="align-self-center col-2">
              <svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 320 512">
                <!--! Font Awesome icon code -->
                <path d="M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l192 192c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L77.3 256 246.6 86.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-192 192z" fill="currentColor"/>
              </svg>
            </div>
            <div align="right" class="col-10">
              <div class="mb-1 text-muted"><strong>Önceki</strong></div>
              <p class="card-text">Metinsel Verileri İşlemek</p>
            </div>
          </div>
          <a href="https://superua1.github.io//egitim/metinsel-verileri-islemek/" title="Metinsel Verileri İşlemek" class="stretched-link"></a>
        </div>
      </div>
    </div>
  

  
      
    <div class="col-md-6">
      <div class="no-gutters border rounded overflow-hidden flex-md-row mb-4 shadow-sm h-md-250 position-relative">
        <div class="col p-4 d-flex flex-column position-static">
          <div class="row">
            <div align="left" class="col-10">
              <div class="mb-1 text-muted"><strong>Sonraki</strong></div>
              <p class="card-text">Kopyalama Taşıma Silme</p>
            </div>
            <div align="right" class="align-self-center col-2">
              <svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 320 512">
                <!--! Font Awesome icon code -->
                <path d="M310.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-192 192c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L242.7 256 73.4 86.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l192 192z" fill="currentColor"/>
              </svg>
            </div>
          </div>
          <a href="https://superua1.github.io//egitim/kopyalama-ta%C5%9F%C4%B1ma-silme-i%C5%9Flemleri/" title="Kopyalama Taşıma Silme" class="stretched-link"></a>
        </div>
      </div>
    </div>
  
</div>


      </div>

      <div class="col-md-3">
        <p></p>
        <div class="no-gutters border rounded overflow-hidden flex-md-row mb-4 shadow-sm h-md-250 position-relative">
          <h3 align="center" class="mavi">Sayfa İçeriği</h3>
          <div data-pagefind-subpage>
            <ul id="toc" class="section-nav">
<li class="toc-entry <hh1"><a href="#pipe-hakkında">pipe Hakkında</a></li>
<li class="toc-entry <hh1"><a href="#xargs-komutu">xargs Komutu</a></li>
<li class="toc-entry <hh1"><a href="#tee">tee</a>
<ul>
<li class="toc-entry <hh3"><a href="#üzerine-ekleme">Üzerine Ekleme</a></li>
</ul>
</li>
<li class="toc-entry <hh1"><a href="#grep">grep</a>
<ul>
<li class="toc-entry <hh2"><a href="#ters-arama--hariç-tutmak">Ters Arama | Hariç Tutmak</a></li>
<li class="toc-entry <hh2"><a href="#özyinelemeli-araştırma">Özyinelemeli Araştırma</a></li>
<li class="toc-entry <hh2"><a href="#yalnızca-dizin-i̇simlerini-bastırmak">Yalnızca Dizin İsimlerini Bastırmak</a></li>
<li class="toc-entry <hh2"><a href="#tırnak-kullanımı">Tırnak Kullanımı</a></li>
<li class="toc-entry <hh2"><a href="#küçük-büyük-harf-duyarlılığı">Küçük Büyük Harf Duyarlılığı</a></li>
<li class="toc-entry <hh2"><a href="#kelime-odaklı-filtreleme">Kelime Odaklı Filtreleme</a></li>
<li class="toc-entry <hh2"><a href="#okunaklı-çıktılar">Okunaklı Çıktılar</a></li>
<li class="toc-entry <hh2"><a href="#çoklu-filtre">Çoklu Filtre</a></li>
<li class="toc-entry <hh2"><a href="#grep-üzerinde-regex-kullanımı">Grep Üzerinde Regex Kullanımı</a>
<ul>
<li class="toc-entry <hh3"><a href="#satır-başı-">Satır Başı: ^</a></li>
<li class="toc-entry <hh3"><a href="#satır-sonu-">Satır Sonu: $</a></li>
<li class="toc-entry <hh3"><a href="#nokta-i̇şareti-">Nokta İşareti .</a></li>
<li class="toc-entry <hh3"><a href="#köşeli-parantez-">Köşeli Parantez []</a></li>
</ul>
</li>
<li class="toc-entry <hh2"><a href="#grep-üzerinde-genişletilmiş-regex-kullanımı">Grep Üzerinde Genişletilmiş Regex Kullanımı</a></li>
</ul>
</li>
<li class="toc-entry <hh1"><a href="#find">find</a>
<ul>
<li class="toc-entry <hh3"><a href="#tipine-göre-filtreleme--dosya---dizin">Tipine Göre Filtreleme | Dosya - Dizin</a></li>
<li class="toc-entry <hh3"><a href="#boyutlarına-göre-filtreleme">Boyutlarına Göre Filtreleme</a></li>
<li class="toc-entry <hh3"><a href="#tarihlerine-göre-filtreleme">Tarihlerine Göre Filtreleme</a></li>
<li class="toc-entry <hh3"><a href="#olumsuzlama-seçeneği--not">Olumsuzlama Seçeneği | not</a></li>
<li class="toc-entry <hh3"><a href="#ve---ya-da-koşulları---and--or">Ve - Ya Da Koşulları | -and -or</a></li>
<li class="toc-entry <hh3"><a href="#find-üzerinde-regex-kullanımı">find Üzerinde Regex Kullanımı</a></li>
</ul>
</li>
<li class="toc-entry <hh1"><a href="#locate">locate</a>
<ul>
<li class="toc-entry <hh3"><a href="#locate-veritabanını-güncellemek--updatedb">locate Veritabanını Güncellemek | updatedb</a></li>
<li class="toc-entry <hh3"><a href="#harf-duyarlılığını-kaldırmak">Harf Duyarlılığını Kaldırmak</a></li>
<li class="toc-entry <hh3"><a href="#eşleşme-sayısını-öğrenmek">Eşleşme Sayısını Öğrenmek</a></li>
<li class="toc-entry <hh3"><a href="#locate-üzerinde-regex-kullanımı">locate Üzerinde Regex Kullanımı</a></li>
<li class="toc-entry <hh3"><a href="#locate-ve-find-arasındaki-fark">locate ve find Arasındaki Fark</a></li>
</ul>
</li>
<li class="toc-entry <hh1"><a href="#cut">cut</a></li>
<li class="toc-entry <hh1"><a href="#tr-komutu">tr Komutu</a>
<ul>
<li class="toc-entry <hh3"><a href="#peş-peşe-tekrar-eden-karakterlerin-sadeleştirilmesi">Peş Peşe Tekrar Eden Karakterlerin Sadeleştirilmesi</a></li>
<li class="toc-entry <hh3"><a href="#karakterlerin-silinmesi">Karakterlerin Silinmesi</a></li>
</ul>
</li>
<li class="toc-entry <hh1"><a href="#sed">sed</a>
<ul>
<li class="toc-entry <hh2"><a href="#bulup-değiştirme">Bulup Değiştirme</a>
<ul>
<li class="toc-entry <hh3"><a href="#tüm-eşlemeler--global">Tüm Eşlemeler | Global</a></li>
<li class="toc-entry <hh3"><a href="#tüm-satırlardaki-i̇lk-eşleşme">Tüm Satırlardaki İlk Eşleşme</a></li>
<li class="toc-entry <hh3"><a href="#satır-numarası-belirtmek">Satır Numarası Belirtmek</a></li>
</ul>
</li>
<li class="toc-entry <hh2"><a href="#silme">Silme</a>
<ul>
<li class="toc-entry <hh3"><a href="#belirtilen-satırları-silme">Belirtilen Satırları Silme</a></li>
<li class="toc-entry <hh3"><a href="#eşleşme-sağlanan-satıları-silmek">Eşleşme Sağlanan Satıları Silmek</a></li>
<li class="toc-entry <hh3"><a href="#eşleşme-haricindeki-satırları-silmek">Eşleşme Haricindeki Satırları Silmek</a></li>
</ul>
</li>
<li class="toc-entry <hh2"><a href="#ekleme">Ekleme</a>
<ul>
<li class="toc-entry <hh3"><a href="#eşleşmeden-önceki-satıra-ekleme">Eşleşmeden Önceki Satıra Ekleme</a></li>
<li class="toc-entry <hh3"><a href="#eşleşmeden-sonraki-satıra-ekleme">Eşleşmeden Sonraki Satıra Ekleme</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry <hh1"><a href="#awk--gawk">awk | gawk</a>
<ul>
<li class="toc-entry <hh2"><a href="#awk-programı">awk Programı</a></li>
<li class="toc-entry <hh2"><a href="#regex-kullanımı">Regex Kullanımı</a></li>
<li class="toc-entry <hh2"><a href="#regex-için-spesifik-bölüm-belirtmek">Regex için Spesifik Bölüm Belirtmek</a></li>
<li class="toc-entry <hh2"><a href="#regex-için-kaçınılması-gereken-spesifik-bölüm-belirtmek">Regex için Kaçınılması Gereken Spesifik Bölüm Belirtmek</a></li>
<li class="toc-entry <hh2"><a href="#birden-fazla-sütunu-bastırmak">Birden Fazla Sütunu Bastırmak</a></li>
</ul>
</li>
<li class="toc-entry <hh1"><a href="#konsolda-okunaklı-çıktılar-almak">Konsolda Okunaklı Çıktılar Almak</a>
<ul>
<li class="toc-entry <hh2"><a href="#more-komutu">more Komutu</a></li>
<li class="toc-entry <hh2"><a href="#less-komutu">less Komutu</a></li>
<li class="toc-entry <hh2"><a href="#head-komutu">head Komutu</a></li>
<li class="toc-entry <hh2"><a href="#tail-komutu">tail Komutu</a>
<ul>
<li class="toc-entry <hh3"><a href="#verilerin-anlık-takibi--f">Verilerin Anlık Takibi -f</a></li>
</ul>
</li>
</ul>
</li>
</ul>
          </div>
        </div>
        <p></p>

	  
	  
      <div class="no-gutters border rounded overflow-hidden flex-md-row mb-4 shadow-sm h-md-250 position-relative">
        <div class="col p-4 d-flex flex-column position-static">
			<p align="center" class="mavi text-primary">Video Eğitim</p>
		<img src="https://superua1.github.io//video-egitim.png"/>
          <p class="card-text mb-auto">Buradaki anlatımları, video eğitim üzerinden takip etmek ve gerektiğinde soru sorabilmek isterseniz kursa gözatın.</p>
         <a href="https://www.udemy.com/course/kali-linux-ile-sifirdan-temel-linux-egitimi/?referralCode=04ABD09E6ED5DA93F7A2" class=" stretched-link"></a>
        </div>
        </div>
  
        <p></p>

	  
	  
      <div class="no-gutters border rounded overflow-hidden flex-md-row mb-4 shadow-sm h-md-250 position-relative">
        <div class="col p-4 d-flex flex-column position-static">
			<p align="center" class="kirmizi text-danger">Kitap</p>
		<img src="https://superua1.github.io//kitap.png"/>
          <p class="card-text mb-auto">Linux sistem yönetimine giriş için kitap arıyorsnız gözatın.</p>
         <a href="https://www.udemy.com/course/kali-linux-ile-sifirdan-temel-linux-egitimi/?referralCode=04ABD09E6ED5DA93F7A2" class=" stretched-link"></a>
        </div>
        </div>
  
      </div>
	  
    </div>
</div>
  
  <hr>

<footer class="container py-5">
  <div class="row">
    <div class="col-6 col-md">
 <h5><a href="/">Linux Dersleri</a> | <a target="_blank" href="https://github.com/Linux-Dersleri/linux-dersleri.github.io"><i class="fa fa-github fa-lg"></i></a></h5>
 <p class="small">GNU/Linux için Türkçe içerik sağlamak üzere kurulmuş bir platformdur.</p>
	 
	  
    </div>
    <div class="col-6 col-md">
      <h5>Eğitim Serileri</h5>
      <ul class="list-unstyled text-small">
        <li><a class="text-muted" href="#">Sıralı Doküman</a></li>
        <li><a class="text-muted" href="#">Video Eğitim</a></li>
      </ul>
    </div>
    
  
    <div class="col-6 col-md">
      <h5>Hakkında</h5>
      <ul class="list-unstyled text-small">
        <li><a class="text-muted" href="https://superua1.github.io//sıkca-sorulan-sorular.html">S.S.S.</a></li>
        <li><a class="text-muted" href="https://superua1.github.io//gizlilik.html">Veri Politikası</a></li>
        <li><a class="text-muted" href="https://superua1.github.io//bildirim.html">Geri Bildirim</a></li>
		<li><a class="text-muted" href="mailto: info@linuxdersleri.net">İletişim</a></li>
      </ul>
    </div>
	<div class="col-6 col-md">
      <h5>Android Uygulaması</h5>
      <ul class="list-unstyled text-small">
        <a href='https://play.google.com/store/apps/details?id=com.bildik.linuxdersleri&pcampaignid=pcampaignidMKT-Other-global-all-co-prtnr-py-PartBadge-Mar2515-1'><img style="width: 75%;" alt='Google Play'den alın' src='https://play.google.com/intl/en_us/badges/static/images/badges/tr_badge_web_generic.png'/></a>
	  </ul>
	  
    </div>
  </div>
</footer>


<script src="https://superua1.github.io//assets/js/jquery-3.3.1.slim.min.js"></script>
<script src="https://superua1.github.io//assets/js/script.js"></script>		
<script src="https://superua1.github.io//assets/js/bootstrap.min.js"></script>

<script>
    // Twitter share button functionality
    var twitterShareButton = document.getElementById("twitterShareButton");
        twitterShareButton.addEventListener("click", function() {
          var tweetText = " #Linux Dersleri platformundaki \"Metinleri Filtrelemek\" içeriğini faydalı bulduğum için paylaşmak istedim. https://superua1.github.io//egitim/metinleri-filtrelemek/";
          var tweetUrl = "https://twitter.com/intent/tweet?text=" + encodeURIComponent(tweetText);
          window.open(tweetUrl, "_blank");
        });
  
        // LinkedIn share button functionality
        var linkedinShareButton = document.getElementById("linkedinShareButton");
        linkedinShareButton.addEventListener("click", function() {
          var postUrl = "https://www.linkedin.com/sharing/share-offsite/?mini=true&url=https://superua1.github.io//egitim/metinleri-filtrelemek/&title=Metinleri Filtrelemek&summary=\"Metinleri Filtrelemek\" içeriğini faydalı bulduğum için paylaşmak istedim.";
          window.open(postUrl, "_blank");
        });
        </script>
<script src="https://superua1.github.io//assets/js/read.js"></script>
<script src="https://superua1.github.io//assets/js/zooming.min.js"></script>
<script>
   // Listen to images after DOM content is fully loaded
   document.addEventListener('DOMContentLoaded', function () {
        new Zooming({
          // options...
        }).listen('.img-zoomable')
      })
</script>
</body>

</html>
